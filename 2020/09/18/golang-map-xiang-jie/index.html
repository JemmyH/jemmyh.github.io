<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Golang-map详解 | Jemmy's Blog</title><meta name="description" content="一、设计原理 哈希表(也就是我们说的map)是计算机应用领域非常重要的数据结构之一，读写的时间复杂度均是O(1)，是典型的 以空间换时间 设计。它的优点除了读写性能优异，还在于它提供了键值之间的映射，为程序设计提供了极大的方便。要想实现一个性能优异的哈希表，需要关注两个关键点：哈希函数 和 冲突解决方法。  1. 哈希函数 可以将任意长度的数据 映射 到有限长度的域上。通俗解释：你可以把它抽象成"><meta name="keywords" content="Golang,map,哈希表"><meta name="author" content="Jemmy"><meta name="copyright" content="Jemmy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://blog.hujm.net/2020/09/18/golang-map-xiang-jie/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Golang-map详解"><meta property="og:url" content="http://blog.hujm.net/2020/09/18/golang-map-xiang-jie/"><meta property="og:site_name" content="Jemmy's Blog"><meta property="og:description" content="一、设计原理 哈希表(也就是我们说的map)是计算机应用领域非常重要的数据结构之一，读写的时间复杂度均是O(1)，是典型的 以空间换时间 设计。它的优点除了读写性能优异，还在于它提供了键值之间的映射，为程序设计提供了极大的方便。要想实现一个性能优异的哈希表，需要关注两个关键点：哈希函数 和 冲突解决方法。  1. 哈希函数 可以将任意长度的数据 映射 到有限长度的域上。通俗解释：你可以把它抽象成"><meta property="og:image" content="https://pic.downk.cc/item/5f61dc63160a154a6777224d.png"><meta property="article:published_time" content="2020-09-18T15:41:39.000Z"><meta property="article:modified_time" content="2020-09-18T16:04:07.906Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.2.0',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
    },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-09-19 00:04:07'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 5.2.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://avatars1.githubusercontent.com/u/38834787?s=460&amp;u=86d024163fa24335179b43e01806edb2baba6ddc&amp;v=4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">15</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">24</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">12</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86"><span class="toc-text"> 一、设计原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span class="toc-text"> 1. 哈希函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text"> 2. 解决哈希冲突的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#21-%E5%BC%80%E6%94%BE%E5%AF%BB%E5%9D%80%E6%B3%95"><span class="toc-text"> 2.1 开放寻址法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-%E6%8B%89%E9%93%BE%E6%B3%95"><span class="toc-text"> 2.2 拉链法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E7%94%A8%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text"> 二、用到的数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E4%BD%BF%E7%94%A8"><span class="toc-text"> 三、使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text"> 1. 初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%86%99"><span class="toc-text"> 2. 写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AF%BB"><span class="toc-text"> 3. 读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%89%A9%E5%AE%B9"><span class="toc-text"> 4. 扩容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%88%A0%E9%99%A4"><span class="toc-text"> 5. 删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E9%81%8D%E5%8E%86"><span class="toc-text"> 6. 遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E6%80%BB%E7%BB%93"><span class="toc-text"> 四、总结</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://pic.downk.cc/item/5f61dc63160a154a6777224d.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Jemmy's Blog</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Golang-map详解</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-09-18T15:41:39.000Z" title="发表于 2020-09-18 23:41:39">2020-09-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-09-18T16:04:07.906Z" title="更新于 2020-09-19 00:04:07">2020-09-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/">技术博客</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/">技术细节</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/Golang/">Golang</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>37分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="一-设计原理"><a class="markdownIt-Anchor" href="#一-设计原理"></a> 一、设计原理</h2>
<p>哈希表(也就是我们说的<code>map</code>)是计算机应用领域非常重要的数据结构之一，读写的时间复杂度均是<code>O(1)</code>，是典型的 <strong>以空间换时间</strong> 设计。它的优点除了读写性能优异，还在于它提供了键值之间的映射，为程序设计提供了极大的方便。要想实现一个性能优异的哈希表，需要关注两个关键点：<strong>哈希函数</strong> 和 <strong>冲突解决方法</strong>。</p>
<h3 id="1-哈希函数"><a class="markdownIt-Anchor" href="#1-哈希函数"></a> 1. 哈希函数</h3>
<p><strong>可以将任意长度的数据 映射 到有限长度的域上</strong>。通俗解释：你可以把它抽象成一个黑盒(一个函数 f)，它的输入是任意数据 m，输出是另一段固定范围的数据 n，即<code>f(m) = n</code>，n 可以作为 m 的特征(指纹)。</p>
<p>对任意两个输入<code>m1</code>和<code>m2</code>，如果他们的输出均不同，则称这个函数为 <strong>完美哈希函数</strong>。如果存在<code>m1</code>和<code>m2</code>，有 <code>f(m1) = f(m2)</code>，则称这个函数为 <strong>不均匀哈希函数</strong>，这个现象称为 <strong>哈希碰撞</strong>。</p>
<p>完美哈希函数很难找到，比较实际的做法是 <strong>让哈希函数的结果尽可能地分布均匀，然后通过工程上的手段解决哈希碰撞的问题</strong>。但是哈希的结果一定要尽可能均匀，结果不均匀的哈希函数会造成更多的冲突并导致更差的读写性能。</p>
<h3 id="2-解决哈希冲突的方法"><a class="markdownIt-Anchor" href="#2-解决哈希冲突的方法"></a> 2. 解决哈希冲突的方法</h3>
<p>在通常情况下，哈希函数输入的范围一定会远远大于输出的范围，所以在使用哈希表时一定会遇到冲突，哪怕我们使用了完美的哈希函数，当输入的键足够多最终也会造成冲突。</p>
<p>然而我们的哈希函数往往都是不完美的，输出的范围是有限的，所以一定会发生哈希碰撞，这时就需要一些方法来解决哈希碰撞的问题，常见方法的就是<strong>开放寻址法</strong>和<strong>拉链法</strong>。</p>
<h4 id="21-开放寻址法"><a class="markdownIt-Anchor" href="#21-开放寻址法"></a> 2.1 开放寻址法</h4>
<p>这种方法的核心思想在于 <strong>线性探测</strong>，通常情况下，这种哈希表的底层数据结构就是数组。先计算<code>index</code>，判断数组的这个<code>index</code>处是否有值，如果没有，直接存入；否则从这个<code>index</code>向后遍历，直到找到一个为空的<code>index</code>。可以大致用下面的代码表示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hash1</span><span class="params">(source <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    arr := <span class="built_in">make</span>([]<span class="keyword">string</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line">    index := hash(source) % <span class="built_in">len</span>(arr)</span><br><span class="line">    tmp := index</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> arr[index%<span class="built_in">len</span>(arr)] == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            index++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> index == tmp &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>  <span class="comment">// 没找到</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找的时候，还是先计算 <code>index</code> ，如果数组在该位置的数刚好是要找的，直接返回，否则需要向后逐步遍历比较。在某些情况下，当装载的元素太多时，哈希表的性能会急剧下降，最差的结果就是每次增加和查找，都需要遍历整个数组，此时整个哈希表完全失效。</p>
<h4 id="22-拉链法"><a class="markdownIt-Anchor" href="#22-拉链法"></a> 2.2 拉链法</h4>
<p>与开放地址法相比，拉链法是哈希表中最常见的实现方法，大多数的编程语言都用拉链法实现哈希表，它的实现比较开放地址法稍微复杂一些，但是平均查找的长度也比较短，各个用于存储节点的内存都是动态申请的，可以节省比较多的存储空间。</p>
<p>拉链法使用链表作为底层数据结构，我们把这个链表称为桶。这种方法对哈希冲突的解决方法是：直接在相同哈希值的结点后面增加一个链表结点。查询的时候，先找到对应链表第一个结点，之后遍历链表寻找符合要求的那个。</p>
<p>在一个性能比较好的哈希表中，每一个桶中都应该有 0~1 个元素，有时会有 2~3 个，很少会超过这个数量，<strong>计算哈希</strong>、<strong>定位桶</strong>和<strong>遍历链表</strong>三个过程是哈希表读写操作的主要开销，使用拉链法实现的哈希也有装载因子这一概念：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">装载因子 := 元素数量/桶数量</span><br></pre></td></tr></table></figure>
<p>与开放地址法一样，拉链法的装载因子越大，哈希的读写性能就越差，在一般情况下使用拉链法的哈希表装载因子都不会超过 1，当哈希表的装载因子较大时就会触发哈希的扩容，创建更多的桶来存储哈希中的元素，保证性能不会出现严重的下降。如果有 1000 个桶的哈希表存储了 10000 个键值对，它的性能是保存 1000 个键值对的 1/10，但是仍然比在链表中直接读写好 1000 倍。</p>
<h2 id="二-用到的数据结构"><a class="markdownIt-Anchor" href="#二-用到的数据结构"></a> 二、用到的数据结构</h2>
<p>我的 Go 版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go version go1.14.6 darwin/amd64</span><br></pre></td></tr></table></figure>
<p>Go 语言中对哈希表的实现方案是：使用拉链法解决哈希冲突。同时使用了多个数据结构组合来标识哈希表。</p>
<p>在源码中，表示<code>map</code> 的结构体是 <code>hmap</code>：</p>
<figure class="highlight go"><figcaption><span>/usr/local/go/src/runtime/map.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A header for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    count     <span class="keyword">int</span>               <span class="comment">// 当前哈希表中元素个数，调用len(m)时直接返回此值</span></span><br><span class="line">    flags     <span class="keyword">uint8</span>             <span class="comment">//</span></span><br><span class="line">    B         <span class="keyword">uint8</span>             <span class="comment">// 当前哈希表持有的 buckets 数量的对数，即 buckets数量 = 2^B</span></span><br><span class="line">    noverflow <span class="keyword">uint16</span>            <span class="comment">// overflow 的 buckets 的近似数(buckets&lt;16时是准确的)</span></span><br><span class="line">    hash0     <span class="keyword">uint32</span>            <span class="comment">// 哈希种子，在创建哈希表时确定的随机数，并在调用哈希函数的时候作为参数传入</span></span><br><span class="line"></span><br><span class="line">    buckets    unsafe.Pointer   <span class="comment">// 指向 buckets 数组，大小为 2^B，如果元素个数为0则为nil</span></span><br><span class="line">    oldbuckets unsafe.Pointer   <span class="comment">// 渐进式扩容时用于保存之前的 buckets，扩容的时候，buckets 长度会是 oldbuckets 的两倍</span></span><br><span class="line">    nevacuate  <span class="keyword">uintptr</span>          <span class="comment">// 指示扩容进度，表示即将迁移的旧桶编号</span></span><br><span class="line"></span><br><span class="line">    extra *mapextra <span class="comment">// optional fields</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mapextra holds fields that are not present on all maps. 溢出桶相关信息</span></span><br><span class="line"><span class="keyword">type</span> mapextra <span class="keyword">struct</span> &#123;</span><br><span class="line">    overflow    *[]*bmap  <span class="comment">// 目前已经使用的溢出桶的地址</span></span><br><span class="line">    oldoverflow *[]*bmap  <span class="comment">// 在扩容阶段存储旧桶用到的溢出桶的地址</span></span><br><span class="line"></span><br><span class="line">    nextOverflow *bmap    <span class="comment">// 指向下一个空闲溢出桶</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>buckets</code> 是一个指针，最终指向的是一个结构体：</p>
<figure class="highlight go"><figcaption><span>/usr/local/go/src/runtime/map.go</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A bucket for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    tophash [bucketCnt]<span class="keyword">uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>bmap</code> 结构体其实不止包含 <code>tophash</code> 字段，由于哈希表中可能存储不同类型的键值对并且 Go 语言也不支持泛型，所以键值对占据的内存空间大小只能在编译时进行推导，这些字段在运行时也都是通过计算内存地址的方式直接访问的，所以它的定义中就没有包含这些字段，实际上的 <code>bmap</code> 是这样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    topbits  [<span class="number">8</span>]<span class="keyword">uint8</span>       <span class="comment">// tophash数组</span></span><br><span class="line">    keys     [<span class="number">8</span>]keytype     <span class="comment">// key数组</span></span><br><span class="line">    values   [<span class="number">8</span>]valuetype   <span class="comment">// value数组</span></span><br><span class="line">    pad      <span class="keyword">uintptr</span></span><br><span class="line">    overflow <span class="keyword">uintptr</span>    <span class="comment">// 当当前桶存满时，发现还有可用的溢出桶，就会用此指针链接一个溢出桶，溢出桶也是 bmap 结构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.downk.cc/item/5f6182f1160a154a67617498.png" alt="map数据结构" /></p>
<p>如上图所示，<code>hmap</code>的桶就是 <code>bmap</code>，每一个 <code>bmap</code> 最多能存储 8 个键值对，这些键值对之所以会落在同一个桶，是因为他们经过哈希计算之后，得到的哈希结果是 “一类的”。当单个桶中存储的数据过多而无法装满时，就会使用 <code>extra.overflow</code> 中的桶存储溢出的数据。上面两种桶在内存中是连续的，我们暂且称之为 <strong>常规桶</strong> 和 <strong>溢出桶</strong>。</p>
<p>我们来看看 <code>bmap</code> 的内部组成：</p>
<p><img src="https://pic.downk.cc/item/5f61dc63160a154a6777224d.png" alt="bmap内部组成" /></p>
<p>最开始是 8 个 <code>tophash</code>，每个 <code>tophash</code> 都是对应哈希值的高 8 位。需要注意的是，key 和 value 是各自放在一起的，这样的好处是为了<strong>padding</strong> 时节省空间。每一个桶被设计成最多只能存放 8 个键值对，如果有第 9 个键值对落入当前的桶，那就需要再构建一个桶(溢出桶)，然后用 <code>overflow</code> 指针连接起来。</p>
<h2 id="三-使用"><a class="markdownIt-Anchor" href="#三-使用"></a> 三、使用</h2>
<h3 id="1-初始化"><a class="markdownIt-Anchor" href="#1-初始化"></a> 1. 初始化</h3>
<p>无论是通过字面量还是运行时，最终底层都会调用 <code>makemap</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="keyword">int</span>, h *hmap)</span> *<span class="title">hmap</span></span> &#123;</span><br><span class="line">    <span class="comment">// 计算哈希占用的内存是否溢出或者产出能分配的最大值</span></span><br><span class="line">    mem, overflow := math.MulUintptr(<span class="keyword">uintptr</span>(hint), t.bucket.size)</span><br><span class="line">    <span class="keyword">if</span> overflow || mem &gt; maxAlloc &#123;</span><br><span class="line">        hint = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">        h = <span class="built_in">new</span>(hmap)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取随机的哈希种子</span></span><br><span class="line">    h.hash0 = fastrand()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据传入的hint计算需要的最少的桶的数量</span></span><br><span class="line">    B := <span class="keyword">uint8</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> overLoadFactor(hint, B) &#123;</span><br><span class="line">        B++</span><br><span class="line">    &#125;</span><br><span class="line">    h.B = B</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建用于保存桶的数组</span></span><br><span class="line">    <span class="keyword">if</span> h.B != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> nextOverflow *bmap</span><br><span class="line">        h.buckets, nextOverflow = makeBucketArray(t, h.B, <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">            h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">            h.extra.nextOverflow = nextOverflow</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是 <code>makeBucketArray</code> 函数，这个函数会根据传入的 <code>B</code> 计算出的需要创建的桶的数量 在内存中分配一片连续的空间用于存储数据。当桶的数量小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">2^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span> 时，由于数据较少，使用溢出桶的可能性比较低，这时会省略创建的过程以减少额外开销；当桶的数量多于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">2^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span> 时，就会额外创建 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>B</mi><mo>−</mo><mn>4</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{B-4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span><span class="mbin mtight">−</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span> 个溢出桶。正常情况下，溢出桶和常规桶在内存中的存储空间是连续的，只不过被 <code>hmap</code> 的不同字段引用。</p>
<blockquote>
<p>另外注意<code>makemap</code> 的返回，是一个 <code>*hmap</code> ，指针类型，这个时候传给函数在函数中改变的就是原来的 <code>map</code> ，即 改变<code>map</code>类型的形参，是可以影响实参的。这一点和之前的 <code>slice</code> 不同，<code>slice</code> 返回的是一个 <code>slice</code> 结构体，虽底层共用数组，但是扩容后就与原来的数据脱钩了。</p>
</blockquote>
<p>举个例子，下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span> := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>Go 源码中的负载因子是 <code>6.5</code> ，在源码 <code>/usr/local/go/src/runtime/map.go:70</code> 可以找到：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Maximum average load of a bucket that triggers growth is 6.5.</span></span><br><span class="line"><span class="comment">// Represent as loadFactorNum/loadFactDen, to allow integer math.</span></span><br><span class="line">loadFactorNum = <span class="number">13</span></span><br><span class="line">loadFactorDen = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>这里的<code>map</code> 的键值对个数是 10，根据 <code>负载因子 = 键值对个数/桶个数</code>，得到 需要的桶的个数为 2。此时不会创建更多的溢出桶。</p>
<h3 id="2-写"><a class="markdownIt-Anchor" href="#2-写"></a> 2. 写</h3>
<p>源码中执行 <strong>写入</strong> 操作的是 <code>mapassign</code> 函数，该函数较长，我们分步来看(每一步我会在关键位置写上注释，也更容易理解过程)。</p>
<ol>
<li><strong>首先，函数会根据传入的键计算哈希，确定所在的桶：</strong></li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapassign</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">    <span class="comment">// a.调用key类型对应的哈希算法得到哈希</span></span><br><span class="line">    hash := t.hasher(key, <span class="keyword">uintptr</span>(h.hash0))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b.设置 写 标志位</span></span><br><span class="line">    h.flags ^= hashWriting</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> h.buckets == <span class="literal">nil</span> &#123;</span><br><span class="line">        h.buckets = newobject(t.bucket) <span class="comment">// newarray(t.bucket, 1)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">    <span class="comment">// c.根据 hash 计算位于哪个 bucket</span></span><br><span class="line">    bucket := hash &amp; bucketMask(h.B)</span><br><span class="line">    <span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">        <span class="comment">// d.如果 map 正在扩容，此操作确保此 bucket 已经从 hmap.oldbuckets 被搬运到 hmap.buckets</span></span><br><span class="line">        growWork(t, h, bucket)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// e.取得 bucket 所在的内存地址</span></span><br><span class="line">    b := (*bmap)(unsafe.Pointer(<span class="keyword">uintptr</span>(h.buckets) + bucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">    <span class="comment">// f.计算此bucket中的tophash，方法是：取高8位</span></span><br><span class="line">    top := tophash(hash)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 64 位机器上，步骤 a 计算得到的 hash 值共有 64 个 bit 位。之前提到过，<code>hmap.B</code> 表示桶的数量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>h</mi><mi mathvariant="normal">.</mi><mi>B</mi></mrow></msup></mrow><annotation encoding="application/x-tex">2^{h.B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mord mtight">.</span><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span></span></span></span></span></span></span></span></span>。这里用得到的哈希值的<strong>最后 <code>B</code> 个 bit 位表示落在了哪个桶中</strong>，用哈希值的 <strong>高 8 位表示此 key 在 bucket 中的位置</strong>。</p>
<blockquote>
<p>还是以上面的<code>map = make(map[string]int, 10)</code>为例，计算可知 <code>B=2</code>，则应该用后 2 位用来选择桶，高 8 位用来表示 tophash。 某个 key 经过哈希之后得到的 <code>hash=01100100 001011100001101110110010011011001000101111000111110010 01</code>，后两位 <code>01</code> 代表 1 号桶。</p>
</blockquote>
<ol start="2">
<li><strong>然后，会有两层循环，最外层循环 <code>bucket</code> 以及其链接的溢出桶(如果有的话)，内存逐个遍历所有的<code>tophash</code>：</strong></li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> inserti *<span class="keyword">uint8</span>  <span class="comment">// 目标元素在桶中的索引</span></span><br><span class="line">    <span class="keyword">var</span> insertk unsafe.Pointer <span class="comment">// 桶中键的相对地址</span></span><br><span class="line">    <span class="keyword">var</span> elem unsafe.Pointer  <span class="comment">// 桶中值的相对地址</span></span><br><span class="line">bucketloop:</span><br><span class="line"> <span class="comment">// 最外层是一个死循环，其实是当前 bucket 后面链接的溢出桶(overflow)</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// bucketCnt=8，因为一个bucket最多只能存储8个键值对</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">        <span class="comment">// 找到一个tophash不同的</span></span><br><span class="line">        <span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">            <span class="comment">// isEmpty判断当前tophash是否为正常tophash值而不是系统迁移标志</span></span><br><span class="line">            <span class="keyword">if</span> isEmpty(b.tophash[i]) &amp;&amp; inserti == <span class="literal">nil</span> &#123;</span><br><span class="line">                inserti = &amp;b.tophash[i]</span><br><span class="line">                insertk = add(unsafe.Pointer(b), dataOffset+i*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">                elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+i*<span class="keyword">uintptr</span>(t.elemsize))</span><br><span class="line">                <span class="comment">// 已经找到一个可以放置的位置了，为什么不直接break掉？是因为有可能K已经存在，需要找到对应位置然后更新掉</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果余下位置都是空的，则不再需要往下找了</span></span><br><span class="line">            <span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">                <span class="keyword">break</span> bucketloop</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// tophash 相同后，还需要再比较实际的key是否相同</span></span><br><span class="line">        k := add(unsafe.Pointer(b), dataOffset+i*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">        <span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">            k = *((*unsafe.Pointer)(k))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !t.key.equal(key, k) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// key已经在map中了，更新之</span></span><br><span class="line">        <span class="keyword">if</span> t.needkeyupdate() &#123;</span><br><span class="line">            typedmemmove(t.key, k, key)</span><br><span class="line">        &#125;</span><br><span class="line">        elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+i*<span class="keyword">uintptr</span>(t.elemsize))</span><br><span class="line">        <span class="keyword">goto</span> done</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 外层循环接着遍历这个bucket后面链接的overflow</span></span><br><span class="line">    ovf := b.overflow(t)</span><br><span class="line">    <span class="keyword">if</span> ovf == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    b = ovf</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中有出现<code>isEmpty</code> 以及 <code>emptyRest</code> 等标志位，这其实是 <code>tophash</code> 的状态值，在源码 <code>/usr/local/go/src/runtime/map.go:92</code> 中可以找到：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// // Possible tophash values. We reserve a few possibilities for special marks.</span></span><br><span class="line">emptyRest      = <span class="number">0</span> <span class="comment">// 这个 cell 是空的, 并且在当前bucket的更高的index 或者 overflow中，其他的都是空的</span></span><br><span class="line">emptyOne       = <span class="number">1</span> <span class="comment">// 这个 cell 是空的</span></span><br><span class="line">evacuatedX     = <span class="number">2</span> <span class="comment">// K-V 已经搬迁完毕，但是 key 在新的 bucket 的前半部分(扩容时会提到)</span></span><br><span class="line">evacuatedY     = <span class="number">3</span> <span class="comment">// 同上，key 在新的 bucket 的后半部分</span></span><br><span class="line">evacuatedEmpty = <span class="number">4</span> <span class="comment">// cell 是空的，并且已经被迁移到新的 bucket 上</span></span><br><span class="line">minTopHash     = <span class="number">5</span> <span class="comment">// 正常的 tophash 的最小值</span></span><br></pre></td></tr></table></figure>
<p>由此也可知，<strong>正常的 <code>tophash</code> 是 大于 <code>minTopHash</code> 的</strong>。</p>
<ol start="3">
<li><strong>如果此时 (键值对数已经超过负载因子 或者 已经有太多的溢出桶) &amp;&amp; 当前没有处在扩容阶段，那么 开始扩容：</strong></li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If we hit the max load factor or we have too many overflow buckets,</span></span><br><span class="line"><span class="comment">// and we&#x27;re not already in the middle of growing, start growing.</span></span><br><span class="line"><span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">   hashGrow(t, h)</span><br><span class="line">   <span class="keyword">goto</span> again <span class="comment">// Growing the table invalidates everything, so try again</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的扩容过程后面再细说，这里暂不讨论。</p>
<ol start="4">
<li><strong>如果没有找到合适的 cell 来存放这个键值对(桶满了)，则 使用预先申请的保存在 <code>hmap.extra.nextoverflow</code> 指向的溢出桶 或者 创建新桶 来保存数据，之后将键值对插入到相应的位置：</strong></li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> inserti == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// all current buckets are full, allocate a new one.</span></span><br><span class="line">    newb := h.newoverflow(t, b)</span><br><span class="line">    inserti = &amp;newb.tophash[<span class="number">0</span>]</span><br><span class="line">    insertk = add(unsafe.Pointer(newb), dataOffset)</span><br><span class="line">    elem = add(insertk, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// store new key/elem at insert position</span></span><br><span class="line"><span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">    kmem := newobject(t.key)</span><br><span class="line">    *(*unsafe.Pointer)(insertk) = kmem</span><br><span class="line">    insertk = kmem</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> t.indirectelem() &#123;</span><br><span class="line">    vmem := newobject(t.elem)</span><br><span class="line">    *(*unsafe.Pointer)(elem) = vmem</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将键值对移动到对应的空间</span></span><br><span class="line">typedmemmove(t.key, insertk, key)</span><br><span class="line">*inserti = top</span><br><span class="line">h.count++</span><br></pre></td></tr></table></figure>
<p>而使用预分配的溢出桶还是申请新的桶，在 <code>newoverflow</code> 函数中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hmap)</span> <span class="title">newoverflow</span><span class="params">(t *maptype, b *bmap)</span> *<span class="title">bmap</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ovf *bmap</span><br><span class="line">    <span class="keyword">if</span> h.extra != <span class="literal">nil</span> &amp;&amp; h.extra.nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 如果有预分配的 bucket</span></span><br><span class="line">        ovf = h.extra.nextOverflow</span><br><span class="line">        <span class="keyword">if</span> ovf.overflow(t) == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 并且预分配的溢出桶还没有使用完，则使用这个溢出桶，并更新 h.extra.nextOverflow 指针</span></span><br><span class="line">            h.extra.nextOverflow = (*bmap)(add(unsafe.Pointer(ovf), <span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 预分配的溢出桶已经用完了，则置空 h.extra.nextOverflow指针</span></span><br><span class="line">            ovf.setoverflow(t, <span class="literal">nil</span>)</span><br><span class="line">            h.extra.nextOverflow = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有可用的溢出桶，则申请一个新桶</span></span><br><span class="line">        ovf = (*bmap)(newobject(t.bucket))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新h.noverflow(overflow的树木)，如果h.B &lt; 16，则自增1，否则“看可能性”自增(没啥用，感兴趣可以自己研究一下)</span></span><br><span class="line">    h.incrnoverflow()</span><br><span class="line">    <span class="keyword">if</span> t.bucket.ptrdata == <span class="number">0</span> &#123;</span><br><span class="line">        h.createOverflow()</span><br><span class="line">        *h.extra.overflow = <span class="built_in">append</span>(*h.extra.overflow, ovf)</span><br><span class="line">    &#125;</span><br><span class="line">    b.setoverflow(t, ovf)</span><br><span class="line">    <span class="keyword">return</span> ovf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-读"><a class="markdownIt-Anchor" href="#3-读"></a> 3. 读</h3>
<p>我们再来说说 <strong>读</strong> 的过程。<code>map</code> 的读取有两种方式：带 <code>comma</code> 和 不带 <code>comma</code> 的。这两种方式，其实底层调用的分别是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess1</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span>       // <span class="title">v1</span> := <span class="title">m</span>[<span class="title">key</span>]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess2</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="params">(unsafe.Pointer, <span class="keyword">bool</span>)</span>  // <span class="title">v2</span>, <span class="title">isExist</span> := <span class="title">m</span>[<span class="title">key</span>]</span></span><br></pre></td></tr></table></figure>
<p>这两个函数大同小异，我们只看 <code>mapaccess1</code>。我们还是采用分步的方式来从源码中探究细节：</p>
<ol>
<li><strong>根据 <code>key</code> 计算得到 <code>hash</code> 值，同时确定在哪个 <code>bucket</code> 中寻找：</strong></li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数永远不会返回 nil ，如果map是空的，则返回对应类型的 零值</span></span><br><span class="line"><span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> t.hashMightPanic() &#123;</span><br><span class="line">        t.hasher(key, <span class="number">0</span>) <span class="comment">// see issue 23734</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">    throw(<span class="string">&quot;concurrent map read and map write&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 得到 hash 值</span></span><br><span class="line">hash := t.hasher(key, <span class="keyword">uintptr</span>(h.hash0))</span><br><span class="line">m := bucketMask(h.B)  <span class="comment">// 本例中m=31</span></span><br><span class="line"><span class="comment">// 得到 bucket</span></span><br><span class="line">b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line"><span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 正处在扩容阶段</span></span><br><span class="line">    <span class="comment">// 如果不是等量扩容(后面会讲到)</span></span><br><span class="line">    <span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">        <span class="comment">// There used to be half as many buckets; mask down one more power of two.</span></span><br><span class="line">        <span class="comment">// 非等量扩容，那就是渐进式扩容，在原来基础上增加了2倍，为了得到原来的，这里除以2</span></span><br><span class="line">        m &gt;&gt;= <span class="number">1</span>  <span class="comment">// m=15</span></span><br><span class="line">    &#125;</span><br><span class="line">    oldb := (*bmap)(add(c, (hash&amp;m)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">    <span class="comment">// 是否处于扩容阶段</span></span><br><span class="line">    <span class="keyword">if</span> !evacuated(oldb) &#123;</span><br><span class="line">        b = oldb</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">top := tophash(hash)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>和前面 写 的过程类似，也是两个大循环，外层遍历 <code>bucket</code> 以及链接在后面的 溢出桶，内层遍历每个 <code>bucket</code> 中的 <code>tophash</code>，直至找到需要的 键值对：</strong></li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">bucketloop:</span><br><span class="line">    <span class="comment">// 外层循环溢出桶</span></span><br><span class="line">    <span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">        <span class="comment">// bucketCnt=8</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">                <span class="comment">// 和当前index的tophash不相等，并且后面的cell都是空的，说明后面就没不要再去遍历了，直接退出循环，返回对应元素的零值</span></span><br><span class="line">                <span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">                    <span class="keyword">break</span> bucketloop</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找到对应的 key</span></span><br><span class="line">            k := add(unsafe.Pointer(b), dataOffset+i*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">            <span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">                k = *((*unsafe.Pointer)(k))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// tophash相同，还要判断完整的key是否相同</span></span><br><span class="line">            <span class="keyword">if</span> t.key.equal(key, k) &#123;</span><br><span class="line">                e := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+i*<span class="keyword">uintptr</span>(t.elemsize))</span><br><span class="line">                <span class="keyword">if</span> t.indirectelem() &#123;</span><br><span class="line">                    e = *((*unsafe.Pointer)(e))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 根据偏移找到对应的value，直接返回</span></span><br><span class="line">                <span class="keyword">return</span> e</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">// 没找到，返回对应类型的零值</span></span><br><span class="line"> <span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>另外，编译器还会根据 <code>key</code> 的类型，将具体的操作用更具体的函数替换，比如 <code>string</code> 对应的是 <code>mapaccess1_faststr(t *maptype, h *hmap, ky string) unsafe.Pointer</code>，函数的参数直接就是具体的类型，这么做是因为提前知道了元素类型，而且由于 <code>bmap</code> 中 <code>key</code> 和 <code>value</code> 各自放在一起，内存布局非常清晰，这也是前面说的 “减少 padding 带来的浪费”的原因。</p>
<h3 id="4-扩容"><a class="markdownIt-Anchor" href="#4-扩容"></a> 4. 扩容</h3>
<p>在前面介绍 <strong>写</strong> 过程时，我们跳过了有关扩容的内容，现在回过头来看一下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapassign</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">        hashGrow(t, h)</span><br><span class="line">        <span class="keyword">goto</span> again</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断h是否正在扩容。 扩容结束之后，h.oldbuckets 会被置空</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hmap)</span> <span class="title">growing</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h.oldbuckets != <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断map中的键值对数目与已有的buckets 是否超过负载因子 即 count/2^B 与 6.5的大小关系</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">overLoadFactor</span><span class="params">(count <span class="keyword">int</span>, B <span class="keyword">uint8</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> count &gt; bucketCnt &amp;&amp; <span class="keyword">uintptr</span>(count) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否有太多的bucket</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tooManyOverflowBuckets</span><span class="params">(noverflow <span class="keyword">uint16</span>, B <span class="keyword">uint8</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// If the threshold is too low, we do extraneous work.</span></span><br><span class="line">    <span class="comment">// If the threshold is too high, maps that grow and shrink can hold on to lots of unused memory.</span></span><br><span class="line">    <span class="comment">// &quot;too many&quot; means (approximately) as many overflow buckets as regular buckets.</span></span><br><span class="line">    <span class="keyword">if</span> B &gt; <span class="number">15</span> &#123;</span><br><span class="line">        B = <span class="number">15</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 翻译一下这条语句：</span></span><br><span class="line">    <span class="comment">//   如果 B &lt; 15， 即 bucket总数 &lt; 2^15 时，overflow的bucket数目不超过 2^B</span></span><br><span class="line">    <span class="comment">//      如果 B &gt;= 15，即 bucket总数 &gt; 2^15 时，overflow的bucket数目不超过 2^15</span></span><br><span class="line">    <span class="comment">// 即 noverflow &gt;= 2^(min(B,15))</span></span><br><span class="line">    <span class="keyword">return</span> noverflow &gt;= <span class="keyword">uint16</span>(<span class="number">1</span>)&lt;&lt;(B&amp;<span class="number">15</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从现实角度出发，会有以下两种情形：</p>
<ol>
<li>在没有溢出、且所有的桶都装满了的情况下，装载因子是 8，超过了 6.5，表明很多的 <code>bucket</code> 中都快装满了，读写效率都会降低，此时进行扩容是必要的；</li>
<li>当装载因子很小、但是 <code>bucket</code> 很多的时候，<code>map</code> 的读写效率也会很低。什么时候会出现 “键值对总数很小、但 bucket 很多”的情况呢？不停地插入、删除元素。当插入很多元素时，导致创建了更多的 <code>bucket</code> ，之后再删除，导致某个 <code>bucket</code> 中的键值对数量非常少。“这就像是一座空城，房子很多，但是住户很少，都分散了，找起人来很困难。”</li>
</ol>
<p>对于上述两种情况，Go 有着不同的策略：</p>
<ol>
<li>对于第一种情况，城中人多房少，直接将 <code>B</code> 加一，建更多的房子即可；</li>
<li>对第二种情况，新开辟一块同样大小的空间，然后将旧空间中的键值对全部搬运过去，然后重新组织。</li>
</ol>
<p><strong>扩容</strong> 最基础的一个操作是 将原有的键值对搬到新开辟的空间，如果键值对数量太多，将严重影响性能。因此对于情况一，Go 采取 <strong>渐进式扩容</strong>，并不会一次全部搬完，每次最多只搬迁 2 个 bucket；第二种情况，称之为 <strong>等量扩容</strong> ，可以理解成“内存整理”。接下来我们通过源码来分析实际的过程：</p>
<p>执行扩容的函数是 <code>hashGrow</code> ， <code>hashGrow()</code> 函数实际上并没有真正地“搬迁”，它只是分配好了新的 buckets，并将老的 <code>buckets</code> 挂到了 <code>oldbuckets</code> 字段上。真正搬迁 <code>buckets</code> 的动作在 <code>growWork()</code> 函数和 <code>evacuate()</code> 函数中，而调用 <code>growWork()</code> 函数的动作是在 <code>mapassign</code> 和 <code>mapdelete</code> 函数中。也就是插入或修改、删除 <code>key</code> 的时候，都会尝试进行搬迁 <code>buckets</code> 的工作。先检查 <code>oldbuckets</code> 是否搬迁完毕，具体来说就是检查 <code>oldbuckets</code> 是否为 <code>nil</code>。</p>
<p>我们来看看 <code>hashGrow</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashGrow</span><span class="params">(t *maptype, h *hmap)</span></span> &#123;</span><br><span class="line">    <span class="comment">// If we&#x27;ve hit the load factor, get bigger.</span></span><br><span class="line">    <span class="comment">// Otherwise, there are too many overflow buckets,</span></span><br><span class="line">    <span class="comment">// so keep the same number of buckets and &quot;grow&quot; laterally.</span></span><br><span class="line">    <span class="comment">// 首先通过 是否超过负载因子 判断进行渐进式扩容还是等量扩容</span></span><br><span class="line">    bigger := <span class="keyword">uint8</span>(<span class="number">1</span>)  <span class="comment">// 默认等量扩容</span></span><br><span class="line">    <span class="keyword">if</span> !overLoadFactor(h.count+<span class="number">1</span>, h.B) &#123;</span><br><span class="line">        <span class="comment">// 如果没有超过负载因子，则进行等量扩容</span></span><br><span class="line">        bigger = <span class="number">0</span></span><br><span class="line">        h.flags |= sameSizeGrow</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 申请新的 bucket 空间，并将原来的 h.buckets 字段 转移到 h.oldbuckets</span></span><br><span class="line">    oldbuckets := h.buckets</span><br><span class="line">    newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将以前原有的buckets的标志位也转移到新申请的buckets去</span></span><br><span class="line">    flags := h.flags &amp;^ (iterator | oldIterator)</span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;iterator != <span class="number">0</span> &#123;</span><br><span class="line">        flags |= oldIterator</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行grow操作 (atomic wrt gc)</span></span><br><span class="line">    h.B += bigger</span><br><span class="line">    h.flags = flags</span><br><span class="line">    h.oldbuckets = oldbuckets</span><br><span class="line">    h.buckets = newbuckets</span><br><span class="line">    h.nevacuate = <span class="number">0</span>  <span class="comment">// h.nevacuate指示扩容进度，表示当前正在搬迁旧的第几个bucket</span></span><br><span class="line">    h.noverflow = <span class="number">0</span>  <span class="comment">// 将溢出桶个数置为零</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将extra中的overflow扔到oldoverflow中去</span></span><br><span class="line">    <span class="keyword">if</span> h.extra != <span class="literal">nil</span> &amp;&amp; h.extra.overflow != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// Promote current overflow buckets to the old generation.</span></span><br><span class="line">        <span class="keyword">if</span> h.extra.oldoverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;oldoverflow is not nil&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        h.extra.oldoverflow = h.extra.overflow</span><br><span class="line">        h.extra.overflow = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> h.extra == <span class="literal">nil</span> &#123;</span><br><span class="line">            h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">        &#125;</span><br><span class="line">        h.extra.nextOverflow = nextOverflow</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the actual copying of the hash table data is done incrementally</span></span><br><span class="line">    <span class="comment">// by growWork() and evacuate().</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第 17 行涉及到的 <code>flag</code> 如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flags</span></span><br><span class="line">iterator     = <span class="number">1</span> <span class="comment">// 可能有迭代器使用 buckets</span></span><br><span class="line">oldIterator  = <span class="number">2</span> <span class="comment">// 可能有迭代器使用 oldbuckets</span></span><br><span class="line">hashWriting  = <span class="number">4</span> <span class="comment">// 有协程正在向 map 中写入 key</span></span><br><span class="line">sameSizeGrow = <span class="number">8</span> <span class="comment">// 等量扩容（对应第二种情况）</span></span><br></pre></td></tr></table></figure>
<p>我们再来看看实际执行扩容的 <code>growWork</code> 和 <code>evacuate</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growWork</span><span class="params">(t *maptype, h *hmap, bucket <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 确认搬迁老的 bucket 对应正在使用的 bucket</span></span><br><span class="line">    evacuate(t, h, bucket&amp;h.oldbucketmask())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还没搬迁完成的话，再搬迁一个 bucket，以加快搬迁进程</span></span><br><span class="line">    <span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">        evacuate(t, h, h.nevacuate)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>evacuate</code> 函数非常长，我们还是逐步去深入：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evacuate</span><span class="params">(t *maptype, h *hmap, oldbucket <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 定位到老的bucket</span></span><br><span class="line">    b := (*bmap)(add(h.oldbuckets, oldbucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">    newbit := h.noldbuckets() <span class="comment">// 存放增长之前的bucket数，结果为 2^B</span></span><br><span class="line">    <span class="keyword">if</span> !evacuated(b) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> reuse overflow buckets instead of using new ones, if there</span></span><br><span class="line">    <span class="comment">// is no iterator using the old buckets.  (If !oldIterator.)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// xy contains the x and y (low and high) evacuation destinations.</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            // evacDst表示搬迁的目的区域.</span></span><br><span class="line"><span class="comment">            type evacDst struct &#123;</span></span><br><span class="line"><span class="comment">                    b *bmap          // 搬去的bucket</span></span><br><span class="line"><span class="comment">                i int            // bucket中键值对的index</span></span><br><span class="line"><span class="comment">                k unsafe.Pointer // pointer to current key storage</span></span><br><span class="line"><span class="comment">                e unsafe.Pointer // pointer to current elem storage</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">// 这里设置两个目标桶，如果是等量扩容，则只会初始化其中一个；</span></span><br><span class="line">            <span class="comment">// xy 指向新空间的高低区间的起点</span></span><br><span class="line">        <span class="keyword">var</span> xy [<span class="number">2</span>]evacDst</span><br><span class="line">        x := &amp;xy[<span class="number">0</span>]</span><br><span class="line">        x.b = (*bmap)(add(h.buckets, oldbucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">        x.k = add(unsafe.Pointer(x.b), dataOffset)</span><br><span class="line">        x.e = add(x.k, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是翻倍扩容，则同时初始化，之后会将旧桶中的键值对“分流”到两个新的目标桶中</span></span><br><span class="line">        <span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">            <span class="comment">// Only calculate y pointers if we&#x27;re growing bigger.</span></span><br><span class="line">            <span class="comment">// Otherwise GC can see bad pointers.</span></span><br><span class="line">            y := &amp;xy[<span class="number">1</span>]</span><br><span class="line">            y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">            y.k = add(unsafe.Pointer(y.b), dataOffset)</span><br><span class="line">            y.e = add(y.k, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有的 bucket，包括 overflow buckets</span></span><br><span class="line">        <span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">            k := add(unsafe.Pointer(b), dataOffset)</span><br><span class="line">            e := add(k, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">            <span class="comment">// 遍历 bucket 中的所有 cell</span></span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; bucketCnt; i, k, e = i+<span class="number">1</span>, add(k, <span class="keyword">uintptr</span>(t.keysize)), add(e, <span class="keyword">uintptr</span>(t.elemsize)) &#123;</span><br><span class="line">                top := b.tophash[i]  <span class="comment">// 当前cell的tophash</span></span><br><span class="line">                <span class="keyword">if</span> isEmpty(top) &#123;</span><br><span class="line">                    <span class="comment">// 当前cell为空，即没有key，则标志其为 “搬迁过”，然后继续下一个 cell</span></span><br><span class="line">                    b.tophash[i] = evacuatedEmpty</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 正常情况下，tophash只能是 evacuatedEmpty 或者 正常的tophash(大于等于minTopHash)</span></span><br><span class="line">                <span class="keyword">if</span> top &lt; minTopHash &#123;</span><br><span class="line">                    throw(<span class="string">&quot;bad map state&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                k2 := k</span><br><span class="line">                <span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">                    k2 = *((*unsafe.Pointer)(k2))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">var</span> useY <span class="keyword">uint8</span></span><br><span class="line">                <span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">                    <span class="comment">// 计算如何分流(将这个键值对放到x中还是y中)</span></span><br><span class="line">                    <span class="comment">// 计算方法与前面相同</span></span><br><span class="line">                    hash := t.hasher(k2, <span class="keyword">uintptr</span>(h.hash0))</span><br><span class="line">                    <span class="comment">// !t.key.equal(k2, k2)这种情况，只能是float的NaN了</span></span><br><span class="line">                    <span class="comment">// 没有协程正在使用map &amp;&amp; 不是float的NaN</span></span><br><span class="line">                    <span class="keyword">if</span> h.flags&amp;iterator != <span class="number">0</span> &amp;&amp; !t.reflexivekey() &amp;&amp; !t.key.equal(k2, k2) &#123;</span><br><span class="line">                        <span class="comment">// 在这种情况下，我们使用 tophash 的低位来作为分流的标准</span></span><br><span class="line">                        useY = top &amp; <span class="number">1</span></span><br><span class="line">                        top = tophash(hash)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> hash&amp;newbit != <span class="number">0</span> &#123;</span><br><span class="line">                            useY = <span class="number">1</span>  <span class="comment">// 新的位置位于高区间</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> evacuatedX+<span class="number">1</span> != evacuatedY || evacuatedX^<span class="number">1</span> != evacuatedY &#123;</span><br><span class="line">                    throw(<span class="string">&quot;bad evacuatedN&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                b.tophash[i] = evacuatedX + useY <span class="comment">// evacuatedX + 1 == evacuatedY</span></span><br><span class="line">                dst := &amp;xy[useY]                 <span class="comment">// 放到高位置还是低位置</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 是否要放到 overflow 中</span></span><br><span class="line">                <span class="keyword">if</span> dst.i == bucketCnt &#123;</span><br><span class="line">                    dst.b = h.newoverflow(t, dst.b)</span><br><span class="line">                    dst.i = <span class="number">0</span></span><br><span class="line">                    dst.k = add(unsafe.Pointer(dst.b), dataOffset)</span><br><span class="line">                    dst.e = add(dst.k, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">                &#125;</span><br><span class="line">                dst.b.tophash[dst.i&amp;(bucketCnt<span class="number">-1</span>)] = top <span class="comment">// mask dst.i as an optimization, to avoid a bounds check</span></span><br><span class="line">                <span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">                    *(*unsafe.Pointer)(dst.k) = k2 <span class="comment">// copy pointer</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    typedmemmove(t.key, dst.k, k) <span class="comment">// copy elem</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> t.indirectelem() &#123;</span><br><span class="line">                    *(*unsafe.Pointer)(dst.e) = *(*unsafe.Pointer)(e)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    typedmemmove(t.elem, dst.e, e)</span><br><span class="line">                &#125;</span><br><span class="line">                dst.i++</span><br><span class="line">                <span class="comment">// These updates might push these pointers past the end of the</span></span><br><span class="line">                <span class="comment">// key or elem arrays.  That&#x27;s ok, as we have the overflow pointer</span></span><br><span class="line">                <span class="comment">// at the end of the bucket to protect against pointing past the</span></span><br><span class="line">                <span class="comment">// end of the bucket.</span></span><br><span class="line">                dst.k = add(dst.k, <span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">                dst.e = add(dst.e, <span class="keyword">uintptr</span>(t.elemsize))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有协程在使用老的 buckets，就把老 buckets 清除掉，帮助gc</span></span><br><span class="line">        <span class="keyword">if</span> h.flags&amp;oldIterator == <span class="number">0</span> &amp;&amp; t.bucket.ptrdata != <span class="number">0</span> &#123;</span><br><span class="line">            b := add(h.oldbuckets, oldbucket*<span class="keyword">uintptr</span>(t.bucketsize))</span><br><span class="line">            <span class="comment">// 只清除bucket 的 key,value 部分，保留 top hash 部分，指示搬迁状态</span></span><br><span class="line">            ptr := add(b, dataOffset)</span><br><span class="line">            n := <span class="keyword">uintptr</span>(t.bucketsize) - dataOffset</span><br><span class="line">            memclrHasPointers(ptr, n)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后会调用 advanceEvacuationMark 增加哈希的 nevacuate 计数器，在所有的旧桶都被分流后清空哈希的 oldbuckets 和 oldoverflow 字段</span></span><br><span class="line">    <span class="keyword">if</span> oldbucket == h.nevacuate &#123;</span><br><span class="line">        advanceEvacuationMark(h, t, newbit)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单总结一下分流规则：</p>
<ol>
<li>对于等量扩容，从旧的 <code>bucket</code> 到新的 <code>bucket</code>，数量不变，因此可以按照 <code>bucket</code> 一一对应，原来是 0 号，搬过去之后还是 0 号；</li>
<li>对于渐进式扩容，要重新计算 <code>key</code> 的 哈希，才能决定落在哪个 <code>bucket</code> 。原来只有 <code>2^B</code> 个<code>bucket</code> ，确定某个 key 位于哪个 <code>bucket</code> 需要使用最后<code>B</code> 位；现在 <code>B</code> 增加了 1，那就应该使用最后的 <code>B+1</code> 位，即向前看一位。比如原来的 <code>B=3</code>，<code>key1</code>和<code>key2</code>的哈希后四位分别是 <code>0x0101</code> 和 <code>0x1101</code>，因为二者的后三位相同，所以会落在同一个 <code>bucket</code> 中，现在进行渐进式扩容，需要多看一位，此时<code>key1</code>和<code>key2</code>的哈希后四位不相同，因为倒数第 4 位有 0 和 1 两种取值，这也就是我们源码中说的 <code>X</code> 和 <code>Y</code>，<code>key1</code>和<code>key2</code>也就会落入不同的 <code>bucket</code> 中——如果是 0，分配到<code>X</code>，如果是 1 ，分配到 <code>Y</code>。</li>
</ol>
<p>还有一种情况是上面函数中第 64 行 <code>!t.key.equal(k2, k2)</code>，即相同的 <code>key</code> ，对它进行哈希计算，两次结果竟然不相同，这种情况来自于 <code>math.NaN()</code>，<code>NaN</code> 的意思是 <code>Not a Number</code>，在 Go 中是 <code>float64</code> 类型(打印出来直接显示 “NaN”)，当使用它作为某个 <code>map</code> 的 <code>key</code> 时，前后计算出来的哈希是不同的，这样的后果是，我们永远无法通过 GET 操作获取到这个键值对，即使用 <code>map[math.NaN]</code> 是取不到想要的结果的，只有在遍历整个 <code>map</code> 的时候才会出现。这种情况下，在决定分流到 <code>X</code> 还是 <code>Y</code> 中时，就只能 使用<code>tophash</code>的最低位来决定 这个策略了——如果 tophash 的最低位是 0 ，分配到 X part；如果是 1 ，则分配到 Y part。</p>
<blockquote>
<p>关于 <code>NaN</code>：In <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Computing">computing</a>, <strong>NaN</strong>, standing for <strong>Not a Number</strong>, is a member of a numeric <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Data_type">data type</a> that can be interpreted as a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Value_(mathematics)">value</a> that is undefined or unrepresentable, especially in <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Floating-point_arithmetic">floating-point arithmetic</a>.</p>
<p>在计算机科学中，<code>NaN</code> 代表 <code>Not a Number</code>，是一个 能够被打印出来的 未定义或者不可预知的 数字类型。<br />
我们简单总结一下哈希表的扩容设计和原理，哈希在存储元素过多时会触发扩容操作，每次都会将桶的数量翻倍，整个扩容过程并不是原子的，而是通过 <code>growWork</code>增量触发的，在扩容期间访问哈希表时会使用旧桶，向哈希表写入数据时会触发旧桶元素的分流；除了这种正常的扩容之外，为了解决大量写入、删除造成的内存泄漏问题，哈希引入了 <code>sameSizeGrow(等量扩容)</code> 这一机制，在出现较多溢出桶时会对哈希进行『内存整理』减少对空间的占用。————<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/#%E6%89%A9%E5%AE%B9">Go 语言设计与实现 3.3 哈希表</a></p>
</blockquote>
<h3 id="5-删除"><a class="markdownIt-Anchor" href="#5-删除"></a> 5. 删除</h3>
<p>Go 语言中删除一个 <code>map</code> 中的 <code>key</code>，使用的是特定的关键字 <code>delete(map, key)</code>。在底层，实际调用的 <code>/usr/local/go/src/runtime/map.go</code> 中的 <code>mapdelete</code>。这个函数的执行过程和 <strong>写</strong> 过程类似，如果在删除期间当前操作的桶遇到了扩容，就会对该桶进行分流，分流之后找到同种的目标元素完成键值对的删除工作。</p>
<h3 id="6-遍历"><a class="markdownIt-Anchor" href="#6-遍历"></a> 6. 遍历</h3>
<p>理论上<code>map</code> 的遍历比较简单——“遍历所有的 <code>bucket</code> 以及它后面挂的 <code>overflow bucket</code>，然后挨个遍历 <code>bucket</code> 中的所有 <code>cell</code>。每个 <code>bucket</code> 中包含 8 个 <code>cell</code>，从有 <code>key</code> 的 <code>cell</code> 中取出 <code>key</code> 和 <code>value</code>，这个过程就完成了。” 但实际情况是，当我们在遍历一个处在扩容阶段的 <code>map</code> 时，不仅要考虑到已经搬过去的位于 <code>h.buckets</code> 的，还要考虑还没有搬的位于 <code>h.oldbuckets</code> 中的。</p>
<p>接下来我们还是通过源码的方式逐步探寻 <strong>map 遍历</strong> 的奥秘。</p>
<p>与之相关的函数分别是 <code>mapiterinit</code> 和 <code>mapiternext</code>，前者会初始化一个迭代器，之后循环调用后者进行迭代。迭代器结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hiter <span class="keyword">struct</span> &#123;</span><br><span class="line">    key         unsafe.Pointer  <span class="comment">// key的指针，必须放在第一位，nil表示迭代结束</span></span><br><span class="line">    elem        unsafe.Pointer  <span class="comment">// value指针，必须放在第二位</span></span><br><span class="line">    t           *maptype        <span class="comment">// map中key的类型</span></span><br><span class="line">    h           *hmap           <span class="comment">// 指向map的指针</span></span><br><span class="line">    buckets     unsafe.Pointer  <span class="comment">// 初始化时指向的 bucket</span></span><br><span class="line">    bptr        *bmap           <span class="comment">// 当前遍历到的 map</span></span><br><span class="line">    overflow    *[]*bmap        <span class="comment">// keeps overflow buckets of hmap.buckets alive</span></span><br><span class="line">    oldoverflow *[]*bmap        <span class="comment">// keeps overflow buckets of hmap.oldbuckets alive</span></span><br><span class="line">    startBucket <span class="keyword">uintptr</span>         <span class="comment">// 起始迭代的 bucket 编号</span></span><br><span class="line">    offset      <span class="keyword">uint8</span>           <span class="comment">// 遍历时的偏移量(可以理解成遍历开始的 cell 号)</span></span><br><span class="line">    wrapped     <span class="keyword">bool</span>            <span class="comment">// 是否从头遍历</span></span><br><span class="line">    B           <span class="keyword">uint8</span>           <span class="comment">// h.B</span></span><br><span class="line">    i           <span class="keyword">uint8</span>           <span class="comment">// 当前的 cell 编号</span></span><br><span class="line">    bucket      <span class="keyword">uintptr</span>         <span class="comment">// 当前的 bucket</span></span><br><span class="line">    checkBucket <span class="keyword">uintptr</span>         <span class="comment">// 因为扩容，需要检查的 bucket</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mapiterinit</code> 主要是对 <code>hiter</code> 的初始化，需要关注的是这几行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapiterinit</span><span class="params">(t *maptype, h *hmap, it *hiter)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// decide where to start</span></span><br><span class="line">    r := <span class="keyword">uintptr</span>(fastrand())</span><br><span class="line">    <span class="comment">// bucketCntBits=3</span></span><br><span class="line">    <span class="keyword">if</span> h.B &gt; <span class="number">31</span>-bucketCntBits &#123;</span><br><span class="line">        r += <span class="keyword">uintptr</span>(fastrand()) &lt;&lt; <span class="number">31</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bucketMask 即 1&lt;&lt;h.B -1</span></span><br><span class="line">    it.startBucket = r &amp; bucketMask(h.B)</span><br><span class="line">    <span class="comment">// bucketCnt=8</span></span><br><span class="line">    it.offset = <span class="keyword">uint8</span>(r &gt;&gt; h.B &amp; (bucketCnt - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>r</code> 是一个随机数，这里假设我们的 <code>m = make(map[string]int)</code>， <code>h.B=2</code>，即有 <code>2^2=4</code> 个桶，可以计算得到 <code>bucketMask(h.B)=3</code>，二进制表示为 <code>0000 0011</code>，将 <code>r</code> 与这个数相与，就能得到 <code>0~3</code> 的 <code>bucket</code> 序号；同样，第 12 行，7 的二进制表示为 <code>0000 0111</code>，将 <code>r</code> 右移两位之后，与 7 相与，可以得到 <code>0~7</code> 的一个 <code>cell</code> 序号。<strong>这就是 <code>map</code> 每次遍历的 <code>key</code> 都是无序的原因</strong>。</p>
<p>之后，使用这个随机的 <code>bucket</code> ，在里面的随机的这个 <code>cell</code> 处开始遍历，取出其中的键值对，直到回到这个 <code>bucket</code> 。</p>
<p>接下来我们看 <code>mapiternext</code> 的细节：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapiternext</span><span class="params">(it *hiter)</span></span> &#123;</span><br><span class="line">    h := it.h</span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        callerpc := getcallerpc()</span><br><span class="line">        racereadpc(unsafe.Pointer(h), callerpc, funcPC(mapiternext))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;concurrent map iteration and map write&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    t := it.t</span><br><span class="line">    bucket := it.bucket</span><br><span class="line">    b := it.bptr</span><br><span class="line">    i := it.i</span><br><span class="line">    checkBucket := it.checkBucket</span><br><span class="line"></span><br><span class="line">next:</span><br><span class="line">    <span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> bucket == it.startBucket &amp;&amp; it.wrapped &#123;</span><br><span class="line">            <span class="comment">// 回到了最开始遍历的那个 bucket，说明遍历结束了，可以退出迭代了</span></span><br><span class="line">            it.key = <span class="literal">nil</span></span><br><span class="line">            it.elem = <span class="literal">nil</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> h.growing() &amp;&amp; it.B == h.B &#123;</span><br><span class="line">            <span class="comment">// 如果我们当前遍历的 bucket 对应的原来的老的 bucket 的状态位显示为 “未搬迁”，则不再遍历当前的 bucket 而去遍历老的 bucket</span></span><br><span class="line">            oldbucket := bucket &amp; it.h.oldbucketmask()</span><br><span class="line">            b = (*bmap)(add(h.oldbuckets, oldbucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">            <span class="keyword">if</span> !evacuated(b) &#123;</span><br><span class="line">                checkBucket = bucket</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                b = (*bmap)(add(it.buckets, bucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">                checkBucket = noCheck</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            b = (*bmap)(add(it.buckets, bucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">            checkBucket = noCheck</span><br><span class="line">        &#125;</span><br><span class="line">        bucket++</span><br><span class="line">        <span class="keyword">if</span> bucket == bucketShift(it.B) &#123;</span><br><span class="line">            bucket = <span class="number">0</span></span><br><span class="line">            it.wrapped = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ; i &lt; bucketCnt; i++ &#123;</span><br><span class="line">        offi := (i + it.offset) &amp; (bucketCnt - <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 当前 cell 是空的，继续下一个 cell</span></span><br><span class="line">        <span class="keyword">if</span> isEmpty(b.tophash[offi]) || b.tophash[offi] == evacuatedEmpty &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        k := add(unsafe.Pointer(b), dataOffset+<span class="keyword">uintptr</span>(offi)*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">        <span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">            k = *((*unsafe.Pointer)(k))</span><br><span class="line">        &#125;</span><br><span class="line">        e := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+<span class="keyword">uintptr</span>(offi)*<span class="keyword">uintptr</span>(t.elemsize))</span><br><span class="line">        <span class="keyword">if</span> checkBucket != noCheck &amp;&amp; !h.sameSizeGrow() &#123;</span><br><span class="line">        <span class="comment">// 正好遇上扩容但是扩容还没完成，如果我们当前遍历的 bucket 对应的老 bucket还没有进行迁移，那么需要去遍历未搬迁的老的 bucket，但是！并不是遍历对应的全部的老的 bucket，而是只遍历 分流后会落在当前 bucket 的那部分键值对</span></span><br><span class="line">            <span class="keyword">if</span> t.reflexivekey() || t.key.equal(k, k) &#123;</span><br><span class="line">                <span class="comment">// 对于老 bucket 中不会分流到这个 bucket 的键值对，直接跳过</span></span><br><span class="line">                hash := t.hasher(k, <span class="keyword">uintptr</span>(h.hash0))</span><br><span class="line">                <span class="keyword">if</span> hash&amp;bucketMask(it.B) != checkBucket &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 处理 math.NaN 情况，还是一样，看最低位来决定是不是落在当前这个 bucket</span></span><br><span class="line">                <span class="keyword">if</span> checkBucket&gt;&gt;(it.B<span class="number">-1</span>) != <span class="keyword">uintptr</span>(b.tophash[offi]&amp;<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b.tophash[offi] != evacuatedX &amp;&amp; b.tophash[offi] != evacuatedY) || !(t.reflexivekey() || t.key.equal(k, k)) &#123;</span><br><span class="line">            <span class="comment">// 对于 math.NaN 情况，我们只能通过遍历找到，对它的增删改查都是不可能的(这也是比较幸运的一件事，最起码能访问到，否则那真就成了“幽灵”了——占用空间又无可奈何，而且还能同一个 key 无限制地添加)</span></span><br><span class="line">            it.key = k</span><br><span class="line">            <span class="keyword">if</span> t.indirectelem() &#123;</span><br><span class="line">                e = *((*unsafe.Pointer)(e))</span><br><span class="line">            &#125;</span><br><span class="line">            it.elem = e</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 开始迭代的时候，已经完成了扩容。此时 math.NaN 已经被放置到了别的 bucket 中，这种情况下只需要处置已经被 更新、删除或者删除后重新插入的情况。需要注意的是那些在 equal() 函数中判断为真的但是实际上他们的 key 不相同的情况，比如 +0.0 vs -0.0</span></span><br><span class="line">            rk, re := mapaccessK(t, h, k)</span><br><span class="line">            <span class="keyword">if</span> rk == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span> <span class="comment">// key 已经被删除</span></span><br><span class="line">            &#125;</span><br><span class="line">            it.key = rk</span><br><span class="line">            it.elem = re</span><br><span class="line">        &#125;</span><br><span class="line">        it.bucket = bucket</span><br><span class="line">        <span class="keyword">if</span> it.bptr != b &#123; <span class="comment">// avoid unnecessary write barrier; see issue 14921</span></span><br><span class="line">            it.bptr = b</span><br><span class="line">        &#125;</span><br><span class="line">        it.i = i + <span class="number">1</span></span><br><span class="line">        it.checkBucket = checkBucket</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    b = b.overflow(t)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">goto</span> next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MjM5MDUwNTQwMQ==&amp;mid=2257483772&amp;idx=1&amp;sn=a6462bc41ec70edf5d60df37a6d4e966&amp;scene=19#wechat_redirect">码农桃花源 深度解密 Go 语言之 map</a> 中 <strong>map 遍历</strong> 一节，作者举了一个非常通俗易懂的例子，非常推荐，建议去看一下加深理解。</p>
<h2 id="四-总结"><a class="markdownIt-Anchor" href="#四-总结"></a> 四、总结</h2>
<p>这是我第一次非常深入地看源码，也领会到了<strong>一切疑难杂症都会在源码面前原形毕露</strong>。<code>map</code> 操作的核心，就在于如何在各种情况下定位到具体的 <code>key</code>，搞清楚了这一点，其他问题看源码会更清晰。</p>
<p>Go 语言中，哈希表的实现采用的哈希查找表，使用拉链法解决哈希冲突。有<strong>空间换时间</strong>的思想体现(不同的 key 落到不同的 bucket，即定位<code>bucket</code>的过程)，也有 <strong>时间换空间</strong> 思想的体现(在一个 <code>bucket</code> 中，采用遍历的方式寻找 <code>key</code> 而不是再使用哈希)，同时渐进式扩容和等量扩容的思想也值得我们学习。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Jemmy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://blog.hujm.net/2020/09/18/golang-map-xiang-jie/">http://blog.hujm.net/2020/09/18/golang-map-xiang-jie/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.hujm.net" target="_blank">Jemmy's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Golang/">Golang</a><a class="post-meta__tags" href="/tags/map/">map</a><a class="post-meta__tags" href="/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/">哈希表</a></div><div class="post_share"><div class="social-share" data-image="https://pic.downk.cc/item/5f61dc63160a154a6777224d.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/09/19/leetcode-liang-shu-zhi-he-wen-ti/"><img class="prev-cover" src="https://pic.downk.cc/item/5f65a612160a154a6789ec2f.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">LeetCode-两数之和问题</div></div></a></div><div class="next-post pull-right"><a href="/2020/09/18/golang-gpm-diao-du-yuan-li/"><img class="next-cover" src="https://pic.downk.cc/item/5f5f38b3160a154a67e1771f.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Golang-GPM调度原理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/09/18/golang-gpm-diao-du-yuan-li/" title="Golang-GPM调度原理"><img class="cover" src="https://pic.downk.cc/item/5f5f38b3160a154a67e1771f.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-18</div><div class="title">Golang-GPM调度原理</div></div></a></div><div><a href="/2020/09/17/golang-unsafe-bao-xiang-jie/" title="Golang-unsafe包详解"><img class="cover" src="https://pic.downk.cc/item/5f5f5567160a154a67e8ec80.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-17</div><div class="title">Golang-unsafe包详解</div></div></a></div><div><a href="/2020/09/15/golang-guan-yu-han-shu-diao-yong/" title="Golang-关于函数调用"><img class="cover" src="https://pic.downk.cc/item/5f5f333b160a154a67dff3a1.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-15</div><div class="title">Golang-关于函数调用</div></div></a></div><div><a href="/2020/09/16/golang-shu-zu-qie-pian-he-zi-fu-chuan/" title="Golang-数组,切片和字符串"><img class="cover" src="https://pic.downk.cc/item/5f5fa4a5160a154a67fdbc36.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-16</div><div class="title">Golang-数组,切片和字符串</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Jemmy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'LjkR3NaCog7bTVOnJNMmJjcM-gzGzoHsz',
      appKey: 'UQMdKbH71EeHJppAbtDwb5Rg',
      placeholder: '欢迎评论~',
      avatar: 'monsterid',
      meta: 'nick,mail'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>