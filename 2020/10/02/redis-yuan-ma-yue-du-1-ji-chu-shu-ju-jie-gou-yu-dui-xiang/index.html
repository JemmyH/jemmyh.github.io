<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Redis源码阅读--1.基础数据结构与对象 | Jemmy's Blog</title><meta name="description" content="首先明确，Redis 是一个使用 C 语言编写的键值对存储系统。Redis 是众所周知的 “快”，一方面，它是一个内存数据库，所有的操作都是在内存中完成的，内存的访问速度本身就很快；另一方面，得益于它底层的数据结构。Redis 的常见类型可在这个网页找到：Redis 命令参考简体中文版，其使用到的底层数据结构有如下六种：简单动态字符串、双向链表、压缩列表、哈希表、跳表和 整数数组。本篇文章，将具体"><meta name="keywords" content="Redis,基础数据结构"><meta name="author" content="Jemmy"><meta name="copyright" content="Jemmy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://blog.hujm.net/2020/10/02/redis-yuan-ma-yue-du-1-ji-chu-shu-ju-jie-gou-yu-dui-xiang/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Redis源码阅读--1.基础数据结构与对象"><meta property="og:url" content="http://blog.hujm.net/2020/10/02/redis-yuan-ma-yue-du-1-ji-chu-shu-ju-jie-gou-yu-dui-xiang/"><meta property="og:site_name" content="Jemmy's Blog"><meta property="og:description" content="首先明确，Redis 是一个使用 C 语言编写的键值对存储系统。Redis 是众所周知的 “快”，一方面，它是一个内存数据库，所有的操作都是在内存中完成的，内存的访问速度本身就很快；另一方面，得益于它底层的数据结构。Redis 的常见类型可在这个网页找到：Redis 命令参考简体中文版，其使用到的底层数据结构有如下六种：简单动态字符串、双向链表、压缩列表、哈希表、跳表和 整数数组。本篇文章，将具体"><meta property="og:image" content="https://pic.downk.cc/item/5f76adca160a154a674bc4da.png"><meta property="article:published_time" content="2020-10-02T04:31:41.000Z"><meta property="article:modified_time" content="2020-10-04T21:29:18.943Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.2.0',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
    },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-10-05 05:29:18'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 5.2.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://avatars1.githubusercontent.com/u/38834787?s=460&amp;u=86d024163fa24335179b43e01806edb2baba6ddc&amp;v=4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">14</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">22</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">11</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text"> 一、底层数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text"> 1. 简单动态字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text"> 1.1 数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-api"><span class="toc-text"> 1.2 API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-%E6%80%BB%E7%BB%93"><span class="toc-text"> 1.3 总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%8C%E7%AB%AF%E9%93%BE%E8%A1%A8"><span class="toc-text"> 2. 双端链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#21-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text"> 2.1 数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-api"><span class="toc-text"> 2.2 API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23-%E6%80%BB%E7%BB%93"><span class="toc-text"> 2.3 总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AD%97%E5%85%B8"><span class="toc-text"> 3. 字典</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#31-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text"> 3.1 数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32-%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F"><span class="toc-text"> 3.2 哈希冲突的解决方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#34-rehash-%E7%BB%86%E8%8A%82"><span class="toc-text"> 3.4 rehash 细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#35-api"><span class="toc-text"> 3.5 API</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%B7%B3%E8%A1%A8"><span class="toc-text"> 4. 跳表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88"><span class="toc-text"> 5. 整数集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#51-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text"> 5.1 数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#52-api"><span class="toc-text"> 5.2 API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#53-%E6%80%BB%E7%BB%93"><span class="toc-text"> 5.3 总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8"><span class="toc-text"> 6. 压缩列表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#61-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text"> 6.1 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#prevlen"><span class="toc-text"> prevlen</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#encoding"><span class="toc-text"> encoding</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#entry-data"><span class="toc-text"> entry-data</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#62-api"><span class="toc-text"> 6.2 API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#63-%E6%80%BB%E7%BB%93"><span class="toc-text"> 6.3 总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%B4%A7%E5%87%91%E5%88%97%E8%A1%A8"><span class="toc-text"> 7. 紧凑列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-redis-%E5%AF%B9%E8%B1%A1%E5%AF%B9%E5%BA%94%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text"> 二、 Redis 对象对应的数据结构</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://pic.downk.cc/item/5f76adca160a154a674bc4da.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Jemmy's Blog</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Redis源码阅读--1.基础数据结构与对象</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-10-02T04:31:41.000Z" title="发表于 2020-10-02 12:31:41">2020-10-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-10-04T21:29:18.943Z" title="更新于 2020-10-05 05:29:18">2020-10-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/">技术博客</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/">技术细节</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/Redis/">Redis</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>58分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>首先明确，<code>Redis</code> 是一个<strong>使用 C 语言编写的键值对存储系统</strong>。<code>Redis</code> 是众所周知的 “<strong>快</strong>”，一方面，它是一个内存数据库，所有的操作都是在<strong>内存</strong>中完成的，内存的访问速度本身就很快；另一方面，得益于它<strong>底层的数据结构</strong>。<code>Redis</code> 的常见类型可在这个网页找到：<a target="_blank" rel="noopener" href="https://redis.readthedocs.io/en/2.4/index.html">Redis 命令参考简体中文版</a>，其使用到的底层数据结构有如下六种：<strong>简单动态字符串</strong>、<strong>双向链表</strong>、<strong>压缩列表</strong>、<strong>哈希表</strong>、<strong>跳表</strong>和 <strong>整数数组</strong>。本篇文章，将具体了解这些底层数据结构的实现。</p>
<blockquote>
<p>本文所涉及源码位于：<a target="_blank" rel="noopener" href="https://github.com/redis/redis">https://github.com/redis/redis</a>，所选版本为 <strong>6.0.8</strong>。</p>
<p>绘图工具为 <a href="draw.io">draw.io</a></p>
<p>涉及到内存操作的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>; <span class="comment">// 调用zmalloc函数，申请size大小的空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zcalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>; <span class="comment">// 调用系统函数calloc申请内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zrealloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span>; <span class="comment">// 原内存重新调整为size空间的大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zfree</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;  <span class="comment">// 调用zfree释放内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">zstrdup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>; <span class="comment">// 字符串复制方法</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_used_memory</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 获取当前以及占用的内存空间大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zmalloc_enable_thread_safeness</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 是否设置线程安全模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zmalloc_set_oom_handler</span><span class="params">(<span class="keyword">void</span> (*oom_handler)(<span class="keyword">size_t</span>))</span></span>; <span class="comment">// 可自定义设置内存溢出的处理方法</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">zmalloc_get_fragmentation_ratio</span><span class="params">(<span class="keyword">size_t</span> rss)</span></span>; <span class="comment">// 获取所给内存和已使用内存的大小之比</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_rss</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 获取RSS信息(Resident Set Size)</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_private_dirty</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 获得实际内存大小</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_smap_bytes_by_field</span><span class="params">(<span class="keyword">char</span> *field)</span></span>; <span class="comment">// 获取/proc/self/smaps字段的字节数</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_memory_size</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 获取物理内存大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zlibc_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>; <span class="comment">// 原始系统free释放方法</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="一-底层数据结构"><a class="markdownIt-Anchor" href="#一-底层数据结构"></a> 一、底层数据结构</h2>
<h3 id="1-简单动态字符串"><a class="markdownIt-Anchor" href="#1-简单动态字符串"></a> 1. 简单动态字符串</h3>
<blockquote>
<p>源码文件：<a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/unstable/src/sds.h">sds.h</a></p>
</blockquote>
<h4 id="11-数据结构"><a class="markdownIt-Anchor" href="#11-数据结构"></a> 1.1 数据结构</h4>
<p><strong>SDS（Simple Dynamic Strings, 简单动态字符串）是 Redis 的一种基本数据结构，主要是用于存储字符串和整数。</strong> 在 <code>Redis 3.2</code> 版本以前，<code>SDS</code> 的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录 buf 数组中已使用字节的数量，等于 SDS 所保存字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录 buf 数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>比如，字符串 <code>Redis6.0</code> 的结构如下：</p>
<p><img src="https://pic.downk.cc/item/5f768cb7160a154a67445538.png" alt="带有未使用空间的SDS" /></p>
<p><code>SDS</code> 遵循 <strong><code>C</code> 字符串以空字符结尾</strong>的惯例， 但保存空字符的 <code>1</code> 字节空间不计算在 SDS 的 <code>len</code> 属性里面， 并且为空字符分配额外的 <code>1</code> 字节空间， 以及添加空字符到字符串末尾等操作都是由 <code>SDS</code> 函数自动完成的， 所以这个空字符对于 <code>SDS</code> 的使用者来说是完全透明的——这样做的好处是，<code>SDS</code> 可以直接使用 <code>C</code> 库中的有关字符串的函数。</p>
<p>但是在 <code>Redis 3.2</code> 以后，为了提高效率以及更加节省内存，<code>Redis</code> 将 <code>SDS</code> 划分成一下五种类型：</p>
<ul>
<li><code>sdshdr5</code></li>
<li><code>sdshdr8</code></li>
<li><code>sdshdr16</code></li>
<li><code>sdshdr32</code></li>
<li><code>sdshdr64</code></li>
</ul>
<p>先看 <code>sdshdr5</code>，增加了一个 <code>flags</code> 字段来标识类型，用一个字节(8 位)来存储：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 前 3 位表示类型, 后 5 为表示长度 */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于 <code>sdshdr5</code> ，因为其可存储长度最大为 <code>2^5 - 1 = 31</code>，当字符串长度超过 31 时，仅靠 <code>flag</code> 的后 5 为表示长度是不够的，这时需要使用其他的四个结构来保存：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len;                <span class="comment">// 已使用长度 1字节</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc;              <span class="comment">// 总长度 1字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags;        <span class="comment">// 前 3 位表示存储类型，后 5 位 预留</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len;               <span class="comment">// 已使用长度 2字节</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc;             <span class="comment">// 总长度 2字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags;        <span class="comment">// 前 3 位表示存储类型，后 5 位 预留</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len;               <span class="comment">// 已使用长度 4字节</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc;             <span class="comment">// 总长度 4字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags;        <span class="comment">// 前 3 位表示存储类型，后 5 位 预留</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len;               <span class="comment">// 已使用长度 8字节</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc;             <span class="comment">// 总长度 8字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags;        <span class="comment">// 前 3 位表示存储类型，后 5 位 预留</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>C/C++ 中 <code>__packed</code> 的作用：</p>
<p>假设有以下结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">   <span class="keyword">char</span> a;      <span class="comment">// 1 字节</span></span><br><span class="line">   <span class="keyword">int</span> b;       <span class="comment">// 4 字节</span></span><br><span class="line">   <span class="keyword">char</span> c[<span class="number">2</span>];   <span class="comment">// 2 字节</span></span><br><span class="line">   <span class="keyword">double</span> d;    <span class="comment">// 8 字节</span></span><br><span class="line">&#125;Struct_A;</span><br></pre></td></tr></table></figure>
<p>在计算机内存中，<strong>结构体变量的存储通常是按字长对齐的</strong>，比如在 8 位机上，就按照 1 字节(8 位)对齐，上述结构体占用 <code>1+4+2+8=15​</code> 字节的内存；在 16 位机上，按照 2 字节对齐，则该结构体占用 <code>2+4+2+8=16​</code> 字节。也就是说，在更高位的机器中，如果按照默认的机器字长做内存对齐的标准，那总会有一些空间是浪费的，比如上面 16 位时，为了对齐，使用了 2 字节来存储一个<code>char</code>类型的变量。为什么要对齐？这是因为对内存操作按照整字存取会有更高的效率，是 “以空间换时间” 的思想体现。当然，在空间更优先的情况下，也可以不使用默认的机器字长做内存对齐，这个时候，使用 <code>__packed___</code>关键字，可以强制使编译器将结构体成员按照 1 字节进行内存对齐，可以得到非对齐的紧凑型结构体。</p>
</blockquote>
<h4 id="12-api"><a class="markdownIt-Anchor" href="#12-api"></a> 1.2 API</h4>
<ul>
<li><strong>创建 SDS</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a new sds string starting from a null terminated C string. */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> initlen = (init == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">strlen</span>(init);  <span class="comment">// 拿到要创建的字符串的长度</span></span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(init, initlen);  <span class="comment">// 传入字符串、字符串长度，调用 sdsnewlen 动态分配内存</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh;</span><br><span class="line">    sds s;</span><br><span class="line">    <span class="keyword">char</span> type = sdsReqType(initlen);  <span class="comment">// 根据字符串长度得到合适的类型</span></span><br><span class="line">    <span class="comment">// 一般情况下，创建一个空字符串的目的都是为了后面的append操作，因此，空字符串的情况下，直接创建SDS_TYPE_8，减少后面的扩容操作</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5 &amp;&amp; initlen == <span class="number">0</span>) type = SDS_TYPE_8;</span><br><span class="line">    <span class="comment">// 计算类型对应的结构体头部长度(len alloc flags的长度)</span></span><br><span class="line">    <span class="keyword">int</span> hdrlen = sdsHdrSize(type);</span><br><span class="line">    <span class="comment">// 指向flag的指针</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请内存，内存大小为 结构体头部长度+字符串长度(buf)+1，这里+1是因为要考虑 &#x27;\0&#x27; 字符</span></span><br><span class="line">    sh = s_malloc(hdrlen+initlen+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (init==SDS_NOINIT)</span><br><span class="line">        init = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!init)</span><br><span class="line">        <span class="built_in">memset</span>(sh, <span class="number">0</span>, hdrlen+initlen+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 将s指向buf</span></span><br><span class="line">    s = (<span class="keyword">char</span>*)sh+hdrlen;</span><br><span class="line">    <span class="comment">// 将 s-1 指向flag</span></span><br><span class="line">    fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s)<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 对sds结构体变量进行赋值</span></span><br><span class="line">    <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(s, init, initlen);</span><br><span class="line">    <span class="comment">// 在s的最后添加&#x27;\0&#x27;</span></span><br><span class="line">    s[initlen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="comment">// 返回指向 buf 数组的指针s</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，创建 <code>SDS</code> 时返回给上层的是指向 <code>buf</code> 数组的指针 s，而不是结构体的指针，那如何找到结构体中的其他元素呢？上面提到了 <code>__packed__</code> 关键字，使用 1 字节进行内存对齐，那么知道了 <code>buf</code> 的地址，将其减去对应类型的长度(偏移量)，就能得到结构体中其他类型的地址。</p>
<ul>
<li><strong>清空 SDS</strong></li>
</ul>
<p>清空一个 <code>SDS</code> 有两个途径：</p>
<p>第一种是直接调用 <code>s_free()</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Free an sds string. No operation is performed if &#x27;s&#x27; is NULL. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    s_free((<span class="keyword">char</span>*)s-sdsHdrSize(s[<span class="number">-1</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种方式是 <strong>重置 len 为 0</strong> 的方式，这种情况下 <code>buf</code> 所占用的空间并没有被清除掉，新的数据会直接覆盖 <code>buf</code> 中的原有数据而无需再申请新的内存空间：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Modify an sds string in-place to make it empty (zero length).</span></span><br><span class="line"><span class="comment"> * However all the existing buffer is not discarded but set as free space</span></span><br><span class="line"><span class="comment"> * so that next append operations will not require allocations up to the</span></span><br><span class="line"><span class="comment"> * number of bytes previously available. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsclear</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    sdssetlen(s, <span class="number">0</span>);</span><br><span class="line">    s[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>拼接 SDS</strong></li>
</ul>
<p>拼接使用的是 <code>sds sdscatsds(sds s, sds t)</code>，但最终调用的还是 <code>sdscatlen</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 t 拼接到 s 后面。调用此方法之后，sds底层的buf可能经过了扩容迁移了原来的位置，注意更新原来变量中对应的指针</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatsds</span><span class="params">(sds s, <span class="keyword">const</span> sds t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s, t, sdslen(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);  <span class="comment">// 计算当前s的长度</span></span><br><span class="line"></span><br><span class="line">    s = sdsMakeRoomFor(s,len);  <span class="comment">// 空间不够的话扩容，确保s的剩余空间足够放得下t</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 扩容失败</span></span><br><span class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);   <span class="comment">// 拼接</span></span><br><span class="line">    sdssetlen(s, curlen+len);   <span class="comment">// 更新s的属性len</span></span><br><span class="line">    s[curlen+len] = <span class="string">&#x27;\0&#x27;</span>;       <span class="comment">// 给s最后加上 &#x27;\0&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们详细看一下扩容规则，在函数 <code>sdsMakeRoomFor</code> 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将sds s的 buf 的可用空间扩大，使得调用此函数之后的s能够再多存储 addlen 长度的字符串。</span></span><br><span class="line"><span class="comment">// 注意：此方法并未改变 sds 的len属性，仅仅改变的是 sds 的 buf 数组的空间。</span></span><br><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh, *newsh;</span><br><span class="line">    <span class="keyword">size_t</span> avail = sdsavail(s);  <span class="comment">// 当前的可用空间长度：s.alloc - s.len</span></span><br><span class="line">    <span class="keyword">size_t</span> len, newlen;</span><br><span class="line">    <span class="keyword">char</span> type, oldtype = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK;</span><br><span class="line">    <span class="keyword">int</span> hdrlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 情况1：剩余长度大于所需要长度，没必要扩容，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (avail &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    len = sdslen(s);     	<span class="comment">// 当前字符串长度</span></span><br><span class="line">    sh = (<span class="keyword">char</span>*)s-sdsHdrSize(oldtype);</span><br><span class="line">    newlen = (len+addlen);    <span class="comment">// 新字符串长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 情况2：扩容</span></span><br><span class="line">    <span class="comment">// 情况2.1： 如果 新长度 &lt; 1MB，则按 新长度的2倍 扩容</span></span><br><span class="line">    <span class="comment">//    		否则，就按 新长度+1MB 扩容</span></span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算新长度的类型</span></span><br><span class="line">    type = sdsReqType(newlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还是为了后续使用减少扩容次数的原因，将 sdshdr5 变为 sdshdr8</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8;</span><br><span class="line"></span><br><span class="line">    hdrlen = sdsHdrSize(type);</span><br><span class="line">    <span class="keyword">if</span> (oldtype==type) &#123;</span><br><span class="line">        <span class="comment">// 如果新长度对应的类型没变，则直接调用 s_realloc 扩大动态数组即可</span></span><br><span class="line">        newsh = s_realloc(sh, hdrlen+newlen+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Since the header size changes, need to move the string forward,</span></span><br><span class="line"><span class="comment">         * and can&#x27;t use realloc */</span></span><br><span class="line">        <span class="comment">// 类型发生了改变，意味着sds结构体头部的三个属性的类型也要跟着变化，此时直接重新申请一块内存</span></span><br><span class="line">        newsh = s_malloc(hdrlen+newlen+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 原s的数据拷贝到新的内存上</span></span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)newsh+hdrlen, s, len+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 释放掉原来的s的空间，并将其更新为刚才新申请的</span></span><br><span class="line">        s_free(sh);</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</span><br><span class="line">        <span class="comment">// 更新 flag</span></span><br><span class="line">        s[<span class="number">-1</span>] = type;</span><br><span class="line">        <span class="comment">// 更新 len</span></span><br><span class="line">        sdssetlen(s, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新 alloc</span></span><br><span class="line">    sdssetalloc(s, newlen);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中注释已经很清楚了，这里再总结一下扩容策略：如果 <code>剩余长度 avail</code> &gt;= <code>新增长度 addlen</code> ，则无需扩容；否则，如果 <code>avail + addlen &lt; 1MB</code>，按照 <code>2 * (avail + addlen)</code>扩容，否则按照 <code>avail + addlen + 1MB</code> 扩容。</p>
<h4 id="13-总结"><a class="markdownIt-Anchor" href="#13-总结"></a> 1.3 总结</h4>
<ul>
<li>创建 <code>SDS</code> 时返回的是指向 <code>buf</code> 数组的指针，而不是 <code>SDS</code> 类型的对象，这样的好处是兼容了已有的 C 语言中的相关函数；</li>
<li>读取内容时，先通过类对应类型计算偏移量，再通过 <code>len</code> 属性来限制读取的长度，杜绝了缓冲区溢出，二进制安全；</li>
<li>根据字符串的长度，定义了五种不同的类型，节省了空间；</li>
<li>进行字符串拼接时，会通过 <code>sdsMakeRoomFor</code> 函数来决定是否有底层 <code>buf</code> 数组的扩容操作。</li>
</ul>
<h3 id="2-双端链表"><a class="markdownIt-Anchor" href="#2-双端链表"></a> 2. 双端链表</h3>
<blockquote>
<p>源码文件：<a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/unstable/src/adlist.h">adlist.h</a></p>
</blockquote>
<h4 id="21-数据结构"><a class="markdownIt-Anchor" href="#21-数据结构"></a> 2.1 数据结构</h4>
<p>当我们使用 <code>lpush</code> 或者 <code>rpush</code> 的时候，其实底层对应的数据结构就是一个双端链表。</p>
<p>首先我们来了解结点 <code>listNode</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span>  <span class="comment">// 头指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span>  <span class="comment">// 尾指针</span></span><br><span class="line">    <span class="keyword">void</span> *value;    		<span class="comment">// 具体的值，因为值的类型不确定，此处使用万能指针</span></span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>
<p>虽然使用多个 <code>listNode</code>就已经足够表示一个双端链表，但是为了更方便，<code>Redis</code> 还有如下结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct list &#123;</span><br><span class="line">    listNode *head;  &#x2F;&#x2F; 头指针</span><br><span class="line">    listNode *tail;  &#x2F;&#x2F; 尾指针</span><br><span class="line">    void *(*dup)(void *ptr);  &#x2F;&#x2F; 拷贝结点函数</span><br><span class="line">    void (*free)(void *ptr);  &#x2F;&#x2F; 释放结点值函数</span><br><span class="line">    int (*match)(void *ptr, void *key); &#x2F;&#x2F; 判断两个结点是否相等的函数</span><br><span class="line">    unsigned long len;  &#x2F;&#x2F; 链表长度</span><br><span class="line">&#125; list;</span><br></pre></td></tr></table></figure>
<p>他们的关系可用如下图表示：</p>
<p><img src="https://pic.downk.cc/item/5f769152160a154a6745655b.png" alt="Redis双端链表" /></p>
<h4 id="22-api"><a class="markdownIt-Anchor" href="#22-api"></a> 2.2 API</h4>
<ul>
<li><strong>创建 <code>list</code> 对象</strong></li>
</ul>
<p>创建的是一个 <code>list</code> 对象，首先会尝试申请分配空间，失败返回 <code>NULL</code> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建的只是一个 list 对象，这个对象可以被 AlFreeList() 释放掉，但是仅仅释放的是这个 list 对象，其上面的 listNode 对象还需要另外手动释放</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listCreate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请分配内存，失败返回 NULL</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">list</span> = zmalloc(<span class="keyword">sizeof</span>(*<span class="built_in">list</span>))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 给其他属性赋值</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;dup = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">free</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;match = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 最终返回 list 对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>添加元素 <code>listNode</code> 到 <code>list</code></strong></li>
</ul>
<p>给一个带头的双向链表添加元素，有三种添加方法：<strong>头插入</strong> 、 <strong>尾插入</strong> 和 指定位置，分别对应的操作为 <code>lpush</code> 、<code>rpush</code> 和 <code>linsert</code>。对于 <code>lpush</code> 和 <code>rpush</code> 的实现如下，本质上就是对双端链表的基础操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeHead</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line">	<span class="comment">// 申请分配内存，失败返回 NULL</span></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 listNode 插入到 list 的元素中</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果之前 list 没有元素，那么 list 的 head 和 tail 均指向当前的 listNode</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 链表的头插入</span></span><br><span class="line">        node-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">        node-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head-&gt;prev = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新 len</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是传进来的 list ，失败返回的是 NULL</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾插入，过程和头插入类似</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;prev = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">list</span>-&gt;tail-&gt;next = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>关于 <code>linsert</code> ，其用法如下：</p>
<blockquote>
<p><strong><code>LINSERT key BEFORE|AFTER pivot value</code></strong></p>
<p>将值<code>value</code>插入到列表<code>key</code>当中，位于值<code>pivot</code>之前或之后。</p>
<p>当<code>pivot</code>不存在于列表<code>key</code>时，不执行任何操作。</p>
<p>当<code>key</code>不存在时，<code>key</code>被视为空列表，不执行任何操作。</p>
<p>如果<code>key</code>不是列表类型，返回一个错误。</p>
</blockquote>
<p>在 <code>Redis</code> 底层，对应的方法为 <code>listInsertNode</code>，当然，为了找到 <code>old_node</code>，前面还需要遍历 <code>list</code>，这个操作的时间复杂度是 <code>O(n)</code>，我们这里只关注如何插入元素：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 list 的 old_node 的前或后(after&lt;0,在前面增加；after&gt;0，在后面增加)新增值为 value 的新listNode</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listInsertNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *old_node, <span class="keyword">void</span> *value, <span class="keyword">int</span> after)</span> </span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为新增的 listNode 申请内存，失败返回 NULL</span></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (after) &#123;</span><br><span class="line">        <span class="comment">// after&gt;0，在后面插入</span></span><br><span class="line">        node-&gt;prev = old_node;</span><br><span class="line">        node-&gt;next = old_node-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;tail == old_node) &#123;</span><br><span class="line">            <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// after&lt;0，在前面插入</span></span><br><span class="line">        node-&gt;next = old_node;</span><br><span class="line">        node-&gt;prev = old_node-&gt;prev;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;head == old_node) &#123;</span><br><span class="line">            <span class="built_in">list</span>-&gt;head = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node-&gt;next-&gt;prev = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新 len</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line">    <span class="comment">// 成功 返回传进来的 list</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>删除元素</strong></li>
</ul>
<p>删除元素的情况有以下几种：清空整个 <code>list</code> ，删除某个 <code>listNode</code>。</p>
<p>我们先看清空整个 <code>list</code> ，它只是释放掉了这个 <code>list</code> 上连的所有的 <code>listNode</code> ，而 <code>list</code> 对象并没有被销毁：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Remove all the elements from the list without destroying the list itself. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listEmpty</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    listNode *current, *next;</span><br><span class="line"></span><br><span class="line">    current = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    len = <span class="built_in">list</span>-&gt;len;</span><br><span class="line">    <span class="comment">// 遍历整个链表，逐个释放空间，直到为空</span></span><br><span class="line">    <span class="keyword">while</span>(len--) &#123;</span><br><span class="line">        next = current-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(current-&gt;value);</span><br><span class="line">        zfree(current);</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而下面这个 <code>listRelease</code> 方法，会释放所有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Free the whole list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function can&#x27;t fail. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRelease</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listEmpty(<span class="built_in">list</span>);    <span class="comment">// 先清空所有的 listNode</span></span><br><span class="line">    zfree(<span class="built_in">list</span>);		<span class="comment">// 再释放 list</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后看删除某个具体的 <code>listNode</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listDelNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 是否是 list 中的第一个元素</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;prev)</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;head = node-&gt;next;</span><br><span class="line">    <span class="comment">// 是否是 list 中的最后一个元素</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next)</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;tail = node-&gt;prev;</span><br><span class="line">    <span class="comment">// 释放当前节点的值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(node-&gt;value);</span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    zfree(node);</span><br><span class="line">    <span class="comment">// 更新 len</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;len--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="23-总结"><a class="markdownIt-Anchor" href="#23-总结"></a> 2.3 总结</h4>
<ul>
<li>
<p><code>Redis</code> 基于双端链表，可以提供各种功能：列表键、发布订阅功能、监视器等；</p>
</li>
<li>
<p>因为链表表头节点的前置节点和表尾节点的后置节点都指向 <code>NULL</code> ， 所以 <code>Redis</code> 的链表实现是无环链表；</p>
</li>
<li>
<p>仔细看过源代码后会发现，这是一个典型的双端链表，其底层实现与我在《数据结构》中遇到的如出一辙，这也从侧面说明了熟悉基本的数据结构的重要性。</p>
</li>
</ul>
<h3 id="3-字典"><a class="markdownIt-Anchor" href="#3-字典"></a> 3. 字典</h3>
<p>字典，由一个个键值对构成，首先想一下，一个字典应该提供什么样的功能？键值对用来存储数据，之后还要能插入数据、修改数据、删除数据、遍历(读取)数据，字典最大的特点就是上面这些所有的操作都可以在 <code>O(1)</code> 的时间复杂度里完成。</p>
<p>比如在 <code>redis-cli</code> 中，我输入如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; <span class="built_in">set</span> name Jemmy</span><br></pre></td></tr></table></figure>
<p>这条命令在 <code>redis</code> 的内存中生成了一个键值对(<code>key-value</code>)，其中 <code>key</code> 是 <code>name</code>，<code>value</code> 是 <code>Jemmy</code>的字符串对象，</p>
<p><code>Redis</code> 的字典采用 <strong>哈希表</strong> 来实现。一个哈希表，你可以简单把它想成一个数组，数组中的每个元素称为一个桶，这也就对应上我们经常所说，一个哈希表由多个桶组成，每个桶中保存了键值对的数据(<strong>哈希桶中保存的值其实并不是值本身，而是一个指向实际值的指针</strong>)。</p>
<p>提到哈希，首先要关注的是哈希算法以及解决哈希冲突的方式。哈希算法的具体实现我们暂时不关心，只需要知道 <code>Redis</code> 使用的是 <a target="_blank" rel="noopener" href="https://github.com/aappleby/smhasher">MurmurHash2</a>，“<strong>这个算法的优点在于：即使输入的键是有规律的，算法仍能够给出一个很好的随机分布性，计算速度也很快</strong>”；对于解决哈希冲突的方法，最常见的是 <strong>开放地址法</strong> 和 <strong>拉链法</strong>。二者实现原理在 <strong><a target="_blank" rel="noopener" href="https://jemmyh.github.io/2020/09/18/golang-map-xiang-jie/">Golang-map 详解</a></strong> 中已经说过，这里不再细讲，目前只需要知道，<strong><code>Redis</code> 采用拉链法解决哈希冲突</strong>。</p>
<p>在 <code>Redis</code> 中，有以下几个概念：哈希表、哈希表结点和字典，他们的关系大致可以描述为：字典是一个全局的字典，一个字典中包含两个哈希表，一个正在使用，另一个用作扩容用；哈希表中包含多个哈希表结点。接下来我们详细看下每个结构的具体实现：</p>
<blockquote>
<p>源码文件：<a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/unstable/src/dict.h">dict.h</a></p>
</blockquote>
<h4 id="31-数据结构"><a class="markdownIt-Anchor" href="#31-数据结构"></a> 3.1 数据结构</h4>
<ul>
<li><strong>哈希表结点</strong></li>
</ul>
<p>哈希表节点使用 <code>dictEntry</code> 结构表示， 每个 <code>dictEntry</code> 结构都保存着一个键值对：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// key</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// value，可以是指针 uint64_t int64_t double中的某一个</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向另一个哈希表结点的指针，连接哈希值相同的键值对，用来解决哈希冲突</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>哈希表</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;          <span class="comment">// dictEntry数组，dictEntry代表一个键值对</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;         <span class="comment">// 哈希表大小(容量)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;     <span class="comment">// 值总是等于 size - 1 ， 这个属性和哈希值一起决定一个键应该被放到 table 数组的哪个索引上面。</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;         <span class="comment">// 哈希表已有结点的数量</span></span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>
<p>下图可以表示 <strong>哈希表 <code>dictht</code></strong> 和 <strong>哈希表结点 <code>dictEntry</code></strong> 之间的关系：</p>
<p><img src="https://pic.downk.cc/item/5f7723fd160a154a67697c61.png" alt="有一个键值对的哈希表" /></p>
<ul>
<li><strong>字典</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;  <span class="comment">// 类型对应的特定函数</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;  <span class="comment">// 私有数据</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];    <span class="comment">// 两个哈希表，一个正常使用，另一个用于扩容</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx;  <span class="comment">// rehash 索引值，扩容时使用，正常时为-1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">// 正在运行的迭代器的数量</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>type</code> 是一个指向 <code>dictType</code> 结构体的指针，而每一个 <code>dictType</code> 结构体保存了 <strong>一组用于操作特定类型键值对的函数</strong>，不同的类型有不同的操作函数，<code>privdata</code> 保存了需要传递给特定类型函数的可选参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="comment">// 计算哈希值的函数</span></span><br><span class="line">    <span class="keyword">uint64_t</span> (*hashFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// 复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// 复制值的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="comment">// 对比键是否相同的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="comment">// 销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// 销毁值的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure>
<p><code>ht</code> 属性是一个包含两个项的数组， 数组中的每个项都是一个 <code>dictht</code> 哈希表， 一般情况下， 字典只使用 <code>ht[0]</code> 哈希表， <code>ht[1]</code> 哈希表只会在对 <code>ht[0]</code> 哈希表进行 rehash 时使用。</p>
<p>除了 <code>ht[1]</code> 之外， 另一个和 rehash 有关的属性就是 <code>rehashidx</code> ： 它记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 <code>-1</code> 。</p>
<p>下图展示了一个普通状态(没有进行 <code>rehash</code> )的字典：</p>
<p><img src="https://pic.downk.cc/item/5f772abc160a154a676b8909.png" alt="未扩容的字典示例" /></p>
<h4 id="32-哈希冲突的解决方式"><a class="markdownIt-Anchor" href="#32-哈希冲突的解决方式"></a> 3.2 哈希冲突的解决方式</h4>
<p>当两个以上的键经过哈希函数计算之后，落在了哈希表数组的同一个索引上面，我们就称这些键发生了 <strong>哈希冲突(hash collision)</strong>。</p>
<p>Redis 的哈希表使用 <strong>链接法</strong>来解决键冲突： 每个哈希表节点(<code>dictEntry</code>)都有一个 <code>next</code> 指针， 多个哈希表节点可以用 <code>next</code> 指针构成一个单向链表， 被分配到同一个索引上的多个节点可以用这个单向链表连接起来， 这就解决了键冲突的问题。写入时，因为没有直接指向链的最后一个元素的指针，因此为了更少的时间复杂度， <code>Redis</code> 采用的是在链表头部插入；读取时，先定位到链头，之后逐个比较值是否与所求相同，直到遍历完整个链。</p>
<p>比如上图中，在 <code>dictht.table</code> 的 3 号桶中已经存在一个键值对 <code>k1-v1</code>，此时又新加入一个键值对 <code>k2-v2</code>，经过哈希计算后正好也落在 3 号桶中，经过插入后结果如下：</p>
<p><img src="https://pic.downk.cc/item/5f773530160a154a676eef06.png" alt="哈希冲突示例" /></p>
<h4 id="34-rehash-细节"><a class="markdownIt-Anchor" href="#34-rehash-细节"></a> 3.4 rehash 细节</h4>
<p>当哈希表的键值对数量太多或者太少时，需要根据实际情况对哈希表的大小进行扩大或者缩小，这个过程通过 <code>rehash(重新散列)</code> 来完成。 而判断是否进行 <code>rehash</code> ，是在向哈希表插入一个键值对的时候，接下来我们通过分析源代码的方式，详细了解 <code>rehash</code> 的细节。</p>
<p>首先，添加一个新键值对，用到的是 <code>dictAdd</code> 方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add an element to the target hash table */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictAdd</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictEntry *entry = dictAddRaw(d,key,<span class="literal">NULL</span>);  <span class="comment">// 将键值对封装成dictEntry</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!entry) <span class="keyword">return</span> DICT_ERR;                <span class="comment">// 如果创建dictEntry，返回失败</span></span><br><span class="line">    dictSetVal(d, entry, val);                  <span class="comment">// 键不存在，则设置dictEntry结点的值</span></span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们接着看 <code>dictAddRaw</code>，这一步主要将键值对封装成一个 <code>dictEntry</code> 并返回 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 key 插入哈希表中</span></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictAddRaw</span><span class="params">(dict *d, <span class="keyword">void</span> *key, dictEntry **existing)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    dictEntry *entry;</span><br><span class="line">    dictht *ht;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果哈希表正在rehash，则向前 rehash一步(渐进式rehash的体现)</span></span><br><span class="line">    <span class="comment">// 是否正在进行 rehash，是通过 dict.rehashidx == -1 来判断的</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用_dictKeyIndex() 检查键是否存在，如果存在则返回NULL</span></span><br><span class="line">    <span class="keyword">if</span> ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前正在使用的ht，如果正在 rehash，使用 ht[1]，否则使用 ht[0]</span></span><br><span class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 为新增的节点分配内存</span></span><br><span class="line">    entry = zmalloc(<span class="keyword">sizeof</span>(*entry));</span><br><span class="line">    <span class="comment">// 将结点插入链表头部</span></span><br><span class="line">    entry-&gt;next = ht-&gt;table[index];</span><br><span class="line">    ht-&gt;table[index] = entry;</span><br><span class="line">    <span class="comment">// 更新结点数量</span></span><br><span class="line">    ht-&gt;used++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新节点的键，使用的是 type 属性中的 keyDup 函数</span></span><br><span class="line">    dictSetKey(d, entry, key);</span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再看 <code>_dictKeyIndex</code> 这个方法，作用是计算某个 <code>key</code> 应该存储在哪个空的 <code>bucket</code> ，即需要返回这个 <code>key</code> 应该存储在 <code>dictEntry</code> 数组的 <code>index</code>，如果已经存在，返回 -1。需要注意的是，当哈希表正在 <code>rehash</code> 时，返回的 <code>index</code> 应该是要搬迁的 <code>ht</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传进来的 existing 是 NULL, hash是通过 type 中的哈希函数计算的</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> _dictKeyIndex(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">uint64_t</span> hash, dictEntry **existing)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> idx, table;</span><br><span class="line">    dictEntry *he;</span><br><span class="line">    <span class="keyword">if</span> (existing)</span><br><span class="line">        *existing = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否需要扩展哈希表，如果需要则进行扩展</span></span><br><span class="line">    <span class="keyword">if</span> (_dictExpandIfNeeded(d) == DICT_ERR)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++)</span><br><span class="line">    &#123;</span><br><span class="line">        idx = hash &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        <span class="comment">/* Search if this slot does not already contain the given key */</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        <span class="keyword">while</span> (he)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (key == he-&gt;key || dictCompareKeys(d, key, he-&gt;key))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (existing)</span><br><span class="line">                    *existing = he;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们关注 <strong>检查是否需要 <code>rehash</code>，需要则启动</strong> 的 <code>_dictExpandIfNeeded</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictExpandIfNeeded(dict *d)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果正在 rehash，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d))</span><br><span class="line">        <span class="keyword">return</span> DICT_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the hash table is empty expand it to the initial size. */</span></span><br><span class="line">    <span class="comment">// 如果哈希表中是空的，则将其收缩为初始化大小 DICT_HT_INITIAL_SIZE=4</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 (ht[0].used/ht[0].size)&gt;=1前提下，如果 系统允许扩容 或者 ht[0].used/t[0].size&gt;5 时，容量扩展为原来的2倍</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used &gt;= d-&gt;ht[<span class="number">0</span>].size &amp;&amp;</span><br><span class="line">        (dict_can_resize ||</span><br><span class="line">         d-&gt;ht[<span class="number">0</span>].used / d-&gt;ht[<span class="number">0</span>].size &gt; dict_force_resize_ratio))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dictExpand(d, d-&gt;ht[<span class="number">0</span>].used * <span class="number">2</span>);  <span class="comment">// 扩容至原来容量的2倍</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仔细看看 <code>dictExpand</code> 是如何扩展哈希表容量的，这个函数中，判断是否需要扩容，如果需要，则新申请一个 <code>dictht</code> ，赋值给 <code>ht[0]</code>，然后将字典的状态设置为 <strong>正在 <code>rehash</code>(rehashidx &gt; -1)</strong>，需要注意的是，这个方法中并没有实际进行键值对的搬迁：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩容 或者 新建一个 dictht</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictExpand</span><span class="params">(dict *d, <span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* the size is invalid if it is smaller than the number of</span></span><br><span class="line"><span class="comment">     * elements already inside the hash table */</span></span><br><span class="line">    <span class="comment">// 如果正在 reahsh 或者 传进来的size不合适(size比当前已有的容量小，正常情况下这是不可能的)，直接返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d) || d-&gt;ht[<span class="number">0</span>].used &gt; size)</span><br><span class="line">        <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    dictht n; <span class="comment">// 新哈希表</span></span><br><span class="line">    <span class="comment">// 计算 扩展或缩放新哈希表容量 的大小，必须是2的倍数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> realsize = _dictNextPower(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果计算扩容后的新哈希表的容量，和原来的相同，就没必要扩容，直接返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (realsize == d-&gt;ht[<span class="number">0</span>].size)</span><br><span class="line">        <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为新哈希表申请内存，并将所有的指针初始化为NULL</span></span><br><span class="line">    n.size = realsize;</span><br><span class="line">    n.sizemask = realsize - <span class="number">1</span>;</span><br><span class="line">    n.table = zcalloc(realsize * <span class="keyword">sizeof</span>(dictEntry *));</span><br><span class="line">    n.used = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Is this the first initialization? If so it&#x27;s not really a rehashing</span></span><br><span class="line"><span class="comment">     * we just set the first hash table so that it can accept keys. */</span></span><br><span class="line">    <span class="comment">// 如果原来的哈希表是空的，意味着这是在新建一个哈希表，将新申请的 dictht 赋值给 ht[0]，直接返回创建成功</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].table == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = n;</span><br><span class="line">        <span class="keyword">return</span> DICT_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是新建哈希表，那就是需要实打实的扩容，此时将刚才新申请的 哈希表 赋值给 ht[1]，并将当前字典状态设置为&quot;正在rehash&quot;(rehashidx &gt; -1)</span></span><br><span class="line">    d-&gt;ht[<span class="number">1</span>] = n;</span><br><span class="line">    d-&gt;rehashidx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表的容量必须是 2的倍数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> _dictNextPower(<span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> i = DICT_HT_INITIAL_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= LONG_MAX)</span><br><span class="line">        <span class="keyword">return</span> LONG_MAX + <span class="number">1L</span>U;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        i *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>什么时候进行 <strong>桶</strong> 的搬迁呢？这里涉及到一个名词：<strong>渐进式扩容</strong>。我们知道，扩展或收缩哈希表需要将 <code>ht[0]</code> 里面的所有键值对 <code>rehash</code> 到 <code>ht[1]</code> 里面，如果哈希表中的键值对数量少，那么一次性转移过去不是问题；但是键值对的数量很大，几百万几千万甚至上亿，那么一次性搬完的计算量+单线程很有可能使 <code>redis</code> 服务停止一段时间。因此，为了避免 <code>rehash</code> 对服务造成影响，服务不是一次性 <code>rehash</code> 完成的，而是 <strong>分多次</strong>、<strong>渐进式</strong>地将 <code>ht[0]</code> 中的键值对搬迁到 <code>ht[1]</code> 中。</p>
<p>源码中真正执行搬迁的函数是 <code>_dictRehashStep</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _dictRehashStep 让 rehash 的动作向前走一步(搬迁一个桶)，前提是当前字典没有被遍历，即iterators==0，iterators表示当前正在遍历此字典的迭代器数目</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictRehashStep(dict *d)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;iterators == <span class="number">0</span>)</span><br><span class="line">        dictRehash(d, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看 <code>dictRehash</code> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dictRehash 向前 rehash n步。如果还没有搬迁完，返回 1，搬迁完成返回0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 当dictRehash时，rehashidx指向当前正在被搬迁的bucket，如果这个bucket中一个可搬迁的dictEntry都没有，说明就没有可搬迁的数据。</span></span><br><span class="line">    <span class="comment">// 这个时候会继续向后遍历 ht[0].table 数组，直到找到下一个存有数据的bucket位置，如果一直找不到，则最多向前走 empty_visits 步，本次搬迁任务结束。</span></span><br><span class="line">    <span class="keyword">int</span> empty_visits = n * <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 整个dict的 rehash 完成了，返回0</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外层大循环，确保本次最多向前走n步 以及 ht[0].table中还有值</span></span><br><span class="line">    <span class="keyword">while</span> (n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保 rehashidx 不会超过 ht[0].table 的长度，因为 rehashidx 指向当前正在被搬迁的bucket，其实就是 ht[0].table 数组的下标，这里保证数组下标访问不会越界</span></span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)d-&gt;rehashidx);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前的bucket搬迁完了，继续寻找下一个bucket，知道全部为空 或者 向前走的步数超过了限定值</span></span><br><span class="line">        <span class="keyword">while</span> (d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 终于找到了可搬迁的某个bucket中的 dictEntry</span></span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将这个 bucket 中的所有 dictEntry 包括链表上的，前部搬迁到新的 ht[1] 中</span></span><br><span class="line">        <span class="keyword">while</span> (de)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">// 获取当前键值对在新的哈希表中的桶的序号，这里进行取模的是 ht[1]的sizemask，所以 h 很大概率会与在 ht[0] 中的不一样</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            <span class="comment">// 更新 新桶与旧桶 中的属性</span></span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 搬迁完成，将原来的ht[0]中的bucket置空</span></span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// rehashidx 自增，表示又搬完了一个桶</span></span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否搬完了整张表</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 全部完成搬迁，则释放掉ht[0]的内存，将ht[1]的内容放到ht[0]中，重置ht[1]，并标志rehash完成(rehashidx=-1)</span></span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则后面的动作还要继续搬迁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那什么时候会进行渐进式<code>rehash</code>呢？在源码中搜索 <code>_dictRehashStep</code>：有以下几处出现了：</p>
<ol>
<li><code>dictAddRaw</code> ：向字典增加一个键值对时；</li>
<li><code>dictGenericDelete</code>：查找并移除某个键值对时；</li>
<li><code>dictFind</code> ：根据 <code>key</code> 查找对应的 <code>dictEntry</code> 时；</li>
<li><code>dictGetRandomKey</code>：返回一个随机的 <code>dictEntry</code> 时；</li>
<li><code>dictGetSomeKeys</code>：随机返回指定 <code>count</code> 个 <code>dictEntry</code> 时，会进行 <code>count</code> 次 <code>_dictRehashStep</code></li>
</ol>
<p>总结一下：</p>
<ol>
<li>为 <code>ht[1]</code> 分配空间， 让字典同时持有 <code>ht[0]</code> 和 <code>ht[1]</code> 两个哈希表。</li>
<li>在字典中维持一个索引计数器变量 <code>rehashidx</code> ， 并将它的值设置为 <code>0</code> ， 表示 rehash 工作正式开始。</li>
<li>在 <code>rehash</code> 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 <code>ht[0]</code> 哈希表在 <code>rehashidx</code> 索引上的所有键值对 rehash 到 <code>ht[1]</code> ， 当 <code>rehash</code> 工作完成之后， 程序将 <code>rehashidx</code> 属性的值增一。</li>
<li>随着字典操作的不断执行， 最终在某个时间点上， <code>ht[0]</code> 的所有键值对都会被 rehash 至 <code>ht[1]</code> ， 这时程序将 <code>rehashidx</code> 属性的值设为 <code>-1</code> ， 表示 <code>rehash</code> 操作已完成。</li>
</ol>
<p><strong>渐进式 <code>rehash</code> 的好处在于它采取分而治之的方式， 将 <code>rehash</code> 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 <code>rehash</code> 而带来的庞大计算量</strong>。</p>
<h4 id="35-api"><a class="markdownIt-Anchor" href="#35-api"></a> 3.5 API</h4>
<ul>
<li><strong>添加键值对 <code>dictAdd</code></strong></li>
</ul>
<p>在上面讲 <code>rehash</code> 时，使用的例子，就是 添加键值对，这里不再赘述。</p>
<ul>
<li><strong>删除键值对 <code>dictDelete</code></strong></li>
</ul>
<p>其底层调用的是 <code>dictGenericDelete</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到key对应的键值对，并移除它。此处dictDelete 调用时传入 nofree=0</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> dictEntry *<span class="title">dictGenericDelete</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">int</span> nofree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> h, idx;</span><br><span class="line">    dictEntry *he, *prevHe;</span><br><span class="line">    <span class="keyword">int</span> table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果字典中键值对数量为0，返回 未找到</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span> &amp;&amp; d-&gt;ht[<span class="number">1</span>].used == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前处于 rehash 阶段，则往前进行一步 rehash</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d))</span><br><span class="line">        _dictRehashStep(d);</span><br><span class="line"></span><br><span class="line">    h = dictHashKey(d, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取桶的索引</span></span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        <span class="comment">// 获取桶中的第一个 dictEntry</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        prevHe = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 遍历链表，找到之后将其从链表中删除</span></span><br><span class="line">        <span class="keyword">while</span> (he)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (key == he-&gt;key || dictCompareKeys(d, key, he-&gt;key))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (prevHe)</span><br><span class="line">                    prevHe-&gt;next = he-&gt;next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    d-&gt;ht[table].table[idx] = he-&gt;next;</span><br><span class="line">                <span class="keyword">if</span> (!nofree)</span><br><span class="line">                &#123;</span><br><span class="line">                    dictFreeKey(d, he);</span><br><span class="line">                    dictFreeVal(d, he);</span><br><span class="line">                    zfree(he);</span><br><span class="line">                &#125;</span><br><span class="line">                d-&gt;ht[table].used--;</span><br><span class="line">                <span class="keyword">return</span> he;</span><br><span class="line">            &#125;</span><br><span class="line">            prevHe = he;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有再 rehash，就没必要再去 ht[1] 中寻找了</span></span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 没找到，返回 NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>查找键值对 <code>dictFind</code></strong></li>
</ul>
<p>过程跟 <code>dictGenericDelete</code> 一模一样， <code>dictGenericDelete</code> 还多了一个删除操作。</p>
<h3 id="4-跳表"><a class="markdownIt-Anchor" href="#4-跳表"></a> 4. 跳表</h3>
<p>会有专门的一篇文章来讲。</p>
<h3 id="5-整数集合"><a class="markdownIt-Anchor" href="#5-整数集合"></a> 5. 整数集合</h3>
<p>当一个集合中只包含整数，并且元素的个数不是很多的话，redis 会用整数集合作为底层存储，它的一个优点就是可以节省很多内存，虽然字典结构的效率很高，但是它的实现结构相对复杂并且会分配较多的内存空间。当然，当整数集合中的 <strong>元素太多(redis.conf 中 <code>set-max-intset-entries=512</code>)</strong> 或者 <strong>添加别的类型的元素</strong>是，整个整数集合会被转化成 <strong>字典</strong>。</p>
<blockquote>
<p>源码文件：<a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/unstable/src/intset.h">intset.h</a></p>
</blockquote>
<h4 id="51-数据结构"><a class="markdownIt-Anchor" href="#51-数据结构"></a> 5.1 数据结构</h4>
<p><strong>整数集合（<code>intset</code>）</strong> 是 <code>Redis</code> 用于保存整数值的集合抽象数据结构， 它可以保存类型为 <code>int16_t</code> 、 <code>int32_t</code> 或者 <code>int64_t</code> 的整数值， 并且保证集合中不会出现重复元素。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集合中包含的元素数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>
<p><code>contents</code> 数组中的元素按照从小到大的顺序排列，并且保证没有重复值；<code>length</code> 表示整数集合中包含的元素数量，即 <code>contents</code> 数组的长度。虽然 <code>contents</code> 数组的类型是 <code>int8_t</code>，但实际上并不保存 <code>int8_t</code> 类型的值，而是会根据实际 <code>encoding</code> 的值做出判断，比如 <code>encoding = INTSET_ENC_INT16</code>，那么数组的底层类型均为 <code>int16_t</code> ，整个数组中的元素类型都是 <code>int16_t</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Note that these encodings are ordered, so:</span></span><br><span class="line"><span class="comment"> * INTSET_ENC_INT16 &lt; INTSET_ENC_INT32 &lt; INTSET_ENC_INT64. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))  <span class="comment">// int16 16位</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))  <span class="comment">// int32 32位</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))  <span class="comment">// int64 64位</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 v 对应的 encoding 值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> _intsetValueEncoding(<span class="keyword">int64_t</span> v) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v &lt; INT32_MIN || v &gt; INT32_MAX)</span><br><span class="line">        <span class="keyword">return</span> INTSET_ENC_INT64;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; INT16_MIN || v &gt; INT16_MAX)</span><br><span class="line">        <span class="keyword">return</span> INTSET_ENC_INT32;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> INTSET_ENC_INT16;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是一个使用 <code>INTSET_ENC_INT16</code> 编码的、长度为 6 的整数集合：</p>
<p><img src="https://pic.downk.cc/item/5f788aa8160a154a6719f5d2.png" alt="整数集合举例" /></p>
<h4 id="52-api"><a class="markdownIt-Anchor" href="#52-api"></a> 5.2 API</h4>
<ul>
<li><strong>初始化 <code>intset</code></strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个空的 intset</span></span><br><span class="line"><span class="function">intset *<span class="title">intsetNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为 intset 对象申请空间</span></span><br><span class="line">    intset *is = zmalloc(<span class="keyword">sizeof</span>(intset));</span><br><span class="line">    <span class="comment">// 默认使用 INTSET_ENC_INT16 作为存储大小</span></span><br><span class="line">    is-&gt;encoding = intrev32ifbe(INTSET_ENC_INT16);</span><br><span class="line">    <span class="comment">// 数组长度为0，因为没有初始化的操作</span></span><br><span class="line">    is-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一点需要注意，创建 <code>intset</code> 的时候并没有初始化 <code>contents</code> 数组，应为没必要。在常规情况下，访问数组是根据数组第一个元素地址加上类型大小作为偏移值读取，但是 <code>intset</code> 的数据类型依赖于 <code>encoding</code>，读取的时候通过 <code>memcpy</code> 按照 <code>encoding</code> 的值重新计算偏移量暴力读取的，属于 非常规操作数据，因此，刚开始没必要申请数组的空间，等添加一个元素时，动态扩容该元素的大小的内存即可。</p>
<ul>
<li><strong>添加元素</strong></li>
</ul>
<p>我们先看代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 intset 中添加一个整数</span></span><br><span class="line"><span class="function">intset *<span class="title">intsetAdd</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">uint8_t</span> *success)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> valenc = _intsetValueEncoding(value);  <span class="comment">// 根据要插入的 value 的类型 获取对应的 encoding</span></span><br><span class="line">    <span class="keyword">uint32_t</span> pos;</span><br><span class="line">    <span class="keyword">if</span> (success) *success = <span class="number">1</span>;  <span class="comment">// success = NULL</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (valenc &gt; intrev32ifbe(is-&gt;encoding)) &#123;</span><br><span class="line">        <span class="comment">// 插入元素的 encoding 值大于 intset 当前的，升级</span></span><br><span class="line">        <span class="keyword">return</span> intsetUpgradeAndAdd(is,value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 插入元素的 encoding 值小于等于当前 intset 的，则找到这个 value 应该插入的位置，赋值给 pos，已经存在的话直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (intsetSearch(is,value,&amp;pos)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (success) *success = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> is;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态扩容</span></span><br><span class="line">        is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 将 pos 位置后面的元素整体向后挪一位，给 pos 腾位置</span></span><br><span class="line">        <span class="keyword">if</span> (pos &lt; intrev32ifbe(is-&gt;length)) intsetMoveTail(is,pos,pos+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 pos 位置设置为 value</span></span><br><span class="line">    _intsetSet(is,pos,value);</span><br><span class="line">    <span class="comment">// 更新 length</span></span><br><span class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态扩容，即将原来数组的容量 (is.length*encoding) 调整为 ((is.length+1)*encoding)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> intset *<span class="title">intsetResize</span><span class="params">(intset *is, <span class="keyword">uint32_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> size = len*intrev32ifbe(is-&gt;encoding);</span><br><span class="line">    is = zrealloc(is,<span class="keyword">sizeof</span>(intset)+size);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴力迁移pos位置之后的数据，为pos位置挪出位置</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">intsetMoveTail</span><span class="params">(intset *is, <span class="keyword">uint32_t</span> from, <span class="keyword">uint32_t</span> to)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// from = pos, to = pos+1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// src 表示 pos 相对于数组头部的迁移量</span></span><br><span class="line">    <span class="comment">// dst 表示 pos下一个元素相对于数组头部的偏移量</span></span><br><span class="line">    <span class="keyword">void</span> *src, *dst;</span><br><span class="line">    <span class="comment">// pos位置 距离数组末尾的元素个数，bytes*类型大小 即是pos后面的所有元素的总长度</span></span><br><span class="line">    <span class="keyword">uint32_t</span> bytes = intrev32ifbe(is-&gt;length)-from;</span><br><span class="line">    <span class="comment">// encoding</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding = intrev32ifbe(is-&gt;encoding);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (encoding == INTSET_ENC_INT64) &#123;</span><br><span class="line">        src = (<span class="keyword">int64_t</span>*)is-&gt;contents+from;</span><br><span class="line">        dst = (<span class="keyword">int64_t</span>*)is-&gt;contents+to;</span><br><span class="line">        bytes *= <span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == INTSET_ENC_INT32) &#123;</span><br><span class="line">        src = (<span class="keyword">int32_t</span>*)is-&gt;contents+from;</span><br><span class="line">        dst = (<span class="keyword">int32_t</span>*)is-&gt;contents+to;</span><br><span class="line">        bytes *= <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        src = (<span class="keyword">int16_t</span>*)is-&gt;contents+from;</span><br><span class="line">        dst = (<span class="keyword">int16_t</span>*)is-&gt;contents+to;</span><br><span class="line">        bytes *= <span class="keyword">sizeof</span>(<span class="keyword">int16_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从 src 复制 bytes 个字符到 dst</span></span><br><span class="line">    memmove(dst,src,bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个过程可以简单总结为：先判断当前插入值的 <code>encoding</code> 是否超过了 <code>intset</code> 的，如果超过了，进行升级，<strong>升级</strong> 操作我们待会儿再看。没超过的话，需要找到当前元素应该插入的位置 <code>pos</code> ，<strong>查找</strong> 操作我们还是待会儿再看。之后是动态扩容，动态扩容的过程有：先将数组容量增加，之后将 <code>pos</code> 后面的元素整体移一位，最后将 <code>value</code> 值写入 <code>pos</code> 处。特别需要注意的是，<strong>将 <code>pos</code> 后面的元素整体后移一位</strong> 这一步，没有逐个移动元素，而是计算好 <code>src</code> 和 <code>dst</code>，直接调用 <code>memmove</code> 将 <code>src</code> 处的 <code>bytes</code> 个字符复制到 <code>dst</code> 处，这正是利用了 <code>intset</code> 数组非常规读取数组的特点。下面通过一个例子看一下插入的过程：</p>
<p><img src="https://pic.downk.cc/item/5f789ebf160a154a671f936b.png" alt="intset插入元素" /></p>
<ul>
<li><strong>升级</strong></li>
</ul>
<p>当插入的元素的类型比集合中现有所有元素的类型都要长时，需要先将数组整个升级之后，才能继续插入元素。<strong>升级</strong> 指的是 将数组类型变成和插入值类型相同的过程。</p>
<p>升级过程大致可分为三个步骤：</p>
<ol>
<li>根据新元素类型，扩展底层数组的大小，并为新元素分配空间；</li>
<li>将底层数组的所有元素都转化成与新元素相同，并将转换后的元素放在合适的位置上，并且在防止的过程中，需要维持底层数组中数组顺序不变；</li>
<li>将新元素添加到新数组中</li>
</ol>
<p>下面我们直接看代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> intset *<span class="title">intsetUpgradeAndAdd</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> curenc = intrev32ifbe(is-&gt;encoding);  <span class="comment">// 当前 encoding</span></span><br><span class="line">    <span class="keyword">uint8_t</span> newenc = _intsetValueEncoding(value); <span class="comment">// 插入元素的 encoding</span></span><br><span class="line">    <span class="keyword">int</span> length = intrev32ifbe(is-&gt;length);</span><br><span class="line">    <span class="comment">// 插入到 数组最左边 还是 数组最右边。为什么会是最值？因为要升级，所以插入值肯定超出了现有 encoding 对应类型的最值，要么是负数越界，要么是正数越界</span></span><br><span class="line">    <span class="keyword">int</span> prepend = value &lt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先，设置 intset 的 encoding 为插入元素的 encoding(更大的那个)</span></span><br><span class="line">    is-&gt;encoding = intrev32ifbe(newenc);</span><br><span class="line">    <span class="comment">// 根据新元素类型 扩展数组大小</span></span><br><span class="line">    is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从数组最后一个元素开始遍历，将其放入合适的位置。prepend 的作用就是确保我们能给待插入值留下最左边的位置 或 最右边的位置</span></span><br><span class="line">    <span class="keyword">while</span>(length--)</span><br><span class="line">        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在数组头部或者数组尾部插入 value</span></span><br><span class="line">    <span class="keyword">if</span> (prepend)</span><br><span class="line">        _intsetSet(is,<span class="number">0</span>,value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _intsetSet(is,intrev32ifbe(is-&gt;length),value);</span><br><span class="line">    <span class="comment">// 最后更新 length</span></span><br><span class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过一个例子说明升级的过程：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjcm49s2sfj30nn0tmk4v.jpg" alt="整数集合升级" /></p>
<p>注意：整数集合没有降级操作！一旦对数组进行了升级， 编码就会一直保持升级后的状态。</p>
<ul>
<li><strong>查找</strong></li>
</ul>
<p>在 <code>intset</code> 中查找 <code>value</code> 是否存在，如果存在，返回 1，同时将 <code>pos</code> 值设置为数组的索引值；如果不存在，返回 0，同时将 <code>pos</code> 设置成应该存放的位置的索引值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint8_t</span> <span class="title">intsetSearch</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">uint32_t</span> *pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>, max = intrev32ifbe(is-&gt;length)<span class="number">-1</span>, mid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int64_t</span> cur = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 intset 中没有元素时，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (intrev32ifbe(is-&gt;length) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 大于当前数组中最大值 或 小于最小值，也是直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (value &gt; _intsetGet(is,max)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos) *pos = intrev32ifbe(is-&gt;length);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; _intsetGet(is,<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos) *pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为数组有序，所以采用二分法查找位置是一个非常正确的选择</span></span><br><span class="line">    <span class="keyword">while</span>(max &gt;= min) &#123;</span><br><span class="line">        mid = ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)min + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)max) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        cur = _intsetGet(is,mid);</span><br><span class="line">        <span class="keyword">if</span> (value &gt; cur) &#123;</span><br><span class="line">            min = mid+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; cur) &#123;</span><br><span class="line">            max = mid<span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value == cur) &#123;</span><br><span class="line">        <span class="comment">// value 已经存在</span></span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = mid;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// value 不存在</span></span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = min;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="53-总结"><a class="markdownIt-Anchor" href="#53-总结"></a> 5.3 总结</h4>
<ul>
<li>整数集合的底层实现为数组， 这个数组以有序、无重复的方式保存集合元素， 在有需要时， 程序会根据新添加元素的类型， 改变这个数组的类型。</li>
<li>升级操作为整数集合带来了操作上的灵活性， 并且尽可能地节约了内存。</li>
<li>整数集合只支持升级操作， 不支持降级操作。</li>
<li>整数集合中的元素不能太对，当超过配置值后，会被转化成字典。</li>
</ul>
<h3 id="6-压缩列表"><a class="markdownIt-Anchor" href="#6-压缩列表"></a> 6. 压缩列表</h3>
<p><strong>压缩列表</strong> 是 <code>Redis</code> 自己实现的一个数据存储结构，有点类似数组，通过一片连续的空间存储数据，只不过数组的每个元素大小都相同，压缩列表允许每个元素有自己的大小。其核心思想，就是在一个连续的内存上，模拟出一个链表的结构。</p>
<p>在源代码中有这么一段描述：</p>
<blockquote>
<p>The ziplist is a specially encoded dually linked list that is designed to be very memory efficient. It stores both strings and integer values, where integers are encoded as actual integers instead of a series of characters. It allows push and pop operations on either side of the list in O(1) time. However, because every operation requires a reallocation of the memory used by the ziplist, the actual complexity is related to the amount of memory used by the ziplist.</p>
</blockquote>
<p>大致意思是：<code>ziplist</code> 是一个<strong>经过特殊编码的双向链表</strong>，它的设计目标就是为了<strong>提高存储效率</strong>。<code>ziplist</code> 可以用于存储字符串或整数，其中整数是按真正的二进制表示进行编码的，而不是编码成字符串序列。它能以 <code>O(1)</code> 的时间复杂度在表的两端提供 <code>push</code> 和 <code>pop</code> 操作。但由于每次操作都需要重新分配 <code>ziplist</code> 使用的内存，所以实际的复杂度与 <code>ziplist</code> 使用的内存量有关。</p>
<blockquote>
<p>源码文件：<a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/unstable/src/ziplist.h">ziplist.h</a></p>
</blockquote>
<h4 id="61-数据结构"><a class="markdownIt-Anchor" href="#61-数据结构"></a> 6.1 数据结构</h4>
<p><code>ziplist</code> 并没有实际的 <code>struct</code> 表示，但在 <code>ziplist.c</code> 中有如下描述：</p>
<blockquote>
<p>The general layout of the ziplist is as follows:</p>
<p><strong>&lt;zlbytes&gt; &lt;zltail&gt; &lt;zllen&gt; &lt;entry&gt; &lt;entry&gt; … &lt;entry&gt; &lt;zlend&gt;</strong></p>
<ul>
<li><code>zlbytes</code>：本身占用 4 字节，整个压缩列表占用的总字节数(包括他自己)</li>
<li><code>zltail</code>：本身占用 4 字节，起始位置到最后一个结点的偏移量，用来快速定位最后一个元素，在反向输出压缩列表时会有用</li>
<li><code>zllen</code>：本身占用 2 字节，压缩列表包含的元素个数</li>
<li><code>entry</code>：元素内容。用数组存储，内存上紧挨着</li>
<li><code>zlend</code>：本身占用 1 字节，压缩列表结束的标志位，一般为常量 <code>0xFF</code></li>
</ul>
</blockquote>
<p>接下来看 <code>entry</code> 这个结构：</p>
<blockquote>
<p><strong>&lt;prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;</strong></p>
<ul>
<li><code>prevlen</code>：1 字节或者 5 字节，表示前一个 <code>entry</code> 长度，在反向遍历的时候会有用</li>
<li><code>encoding</code>：1、2 或 5 字节，表示当前 <code>entry</code> 的编码方式，表示当前 <code>entry</code> 的类型，<code>integer</code> 或 <code>string</code></li>
<li><code>entry-data</code>：实际所需的字节数，结点真正的值，可以是 <code>integer</code> 或 <code>string</code>。它的类型和长度由 <code>encoding</code> 来决定</li>
</ul>
</blockquote>
<p>接下来我们详细关注这三个参数：</p>
<h5 id="prevlen"><a class="markdownIt-Anchor" href="#prevlen"></a> <code>prevlen</code></h5>
<p>以字节为单位，记录前一个 <code>entry</code> 的长度。<code>prevlen</code> 的长度可以是 <strong>1 字节</strong> 或者 <strong>5 字节</strong>：</p>
<ul>
<li>当前一个结点的长度小于 254 字节时，<code>prevlen</code> 的长度为 <strong>1 字节</strong>，前一个 <code>entry</code> 的长度就保存在这一个字节中；</li>
<li>当前一个结点的长度大于等于 254 字节时，<code>prevlen</code> 的长度为 <strong>5 字节</strong>，其中第一个字节会被设置成 <code>0xFE</code>(十进制的 <code>254</code>)，表示这是一个 <strong>5 字节长</strong> 的 <code>prevlen</code>，后面的四个字节则保存前一个 <code>entry</code> 的长度。</li>
</ul>
<p><code>prevlen</code> 的作用是：在反向遍历压缩数组时，可以通过当前元素的指针，减去 <code>prevlen</code> ，就能得到前一个元素的地址。</p>
<p><img src="https://pic.downk.cc/item/5f78e315160a154a672db33d.png" alt="" /></p>
<h5 id="encoding"><a class="markdownIt-Anchor" href="#encoding"></a> <code>encoding</code></h5>
<p>节点的 <code>encoding</code> 属性记录了节点的 <code>entry-data</code> 属性所保存 <strong>数据的类型</strong> 以及 <strong>长度</strong>：</p>
<ul>
<li>一字节、两字节或者五字节长， 值的最高位为 <code>00</code> 、 <code>01</code> 或者 <code>10</code> 的是<strong>字节数组编码</strong>： 这种编码表示节点的 <code>content</code> 属性保存着 <strong>字符串(字节数组)</strong>， 数组的长度由编码除去最高两位之后的其他位记录：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">编码</th>
<th style="text-align:center">编码长度</th>
<th style="text-align:center">content 中保存的值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">00bbbbbb</td>
<td style="text-align:center"><strong>1 字节</strong></td>
<td style="text-align:center">长度小于等于 63 字节的字节数组(6 位分辨位，2^6 = 64，除去全 0 的)</td>
</tr>
<tr>
<td style="text-align:left">01bbbbbb | xxxxxxxx</td>
<td style="text-align:center"><strong>2 字节</strong></td>
<td style="text-align:center">长度小于等于 16383 字节的字节数组(14 位分辨位，2^14 = 16384，除去全 0 的)</td>
</tr>
<tr>
<td style="text-align:left">10000000 | xxxx…xxxx(32 位)</td>
<td style="text-align:center"><strong>5 字节</strong></td>
<td style="text-align:center">长度小于等于 4294967295 字节的字节数组(32 位分辨位，2^32 = 4294967296)</td>
</tr>
</tbody>
</table>
<ul>
<li>一字节长， 值的最高位以 <code>11</code> 开头的是<strong>整数编码</strong>： 这种编码表示节点的 <code>entry-data</code> 属性保存着<strong>整数</strong>值， 整数值的类型和长度由编码除去最高两位之后的其他位记录:</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">编码</th>
<th style="text-align:center">编码长度</th>
<th style="text-align:center">entry-data 中保存的值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">11000000</td>
<td style="text-align:center">1 字节</td>
<td style="text-align:center">int16_t 类型整数</td>
</tr>
<tr>
<td style="text-align:left">11010000</td>
<td style="text-align:center">1 字节</td>
<td style="text-align:center">int32_t 类型整数</td>
</tr>
<tr>
<td style="text-align:left">11100000</td>
<td style="text-align:center">1 字节</td>
<td style="text-align:center">int64_t 类型整数</td>
</tr>
<tr>
<td style="text-align:left">11110000</td>
<td style="text-align:center">1 字节</td>
<td style="text-align:center">24 位有符号整数</td>
</tr>
<tr>
<td style="text-align:left">11111110</td>
<td style="text-align:center">1 字节</td>
<td style="text-align:center">8 位有符号整数</td>
</tr>
<tr>
<td style="text-align:left">1111xxxx</td>
<td style="text-align:center">1 字节</td>
<td style="text-align:center">使用这一编码的节点没有相应的 <code>entry-data</code> 属性， 因为编码本身的 <code>xxxx</code> 四个位已经保存了一个介于 <code>0</code> 和 <code>12</code> 之间的值， 所以它无须 <code>entry-data</code> 属性。</td>
</tr>
</tbody>
</table>
<h5 id="entry-data"><a class="markdownIt-Anchor" href="#entry-data"></a> <code>entry-data</code></h5>
<p>节点的 <code>entry-data</code> 属性负责保存节点的值， 节点值可以是一个字节数组或者整数， 值的类型和长度由节点的 <code>encoding</code> 属性决定。</p>
<p><img src="https://pic.downk.cc/item/5f78e80c160a154a672e5400.png" alt="" /></p>
<p><img src="https://pic.downk.cc/item/5f796b73160a154a674807ff.png" alt="压缩列表-示例" /></p>
<h4 id="62-api"><a class="markdownIt-Anchor" href="#62-api"></a> 6.2 API</h4>
<ul>
<li><strong>创建<code>ziplist</code></strong></li>
</ul>
<p>返回一个只包含 <code>&lt;zlbytes&gt;&lt;zltail&gt;&lt;zllen&gt;&lt;zlend&gt;</code> 的 <code>ziplist</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bytes = ZIPLIST_HEADER_SIZE+ZIPLIST_END_SIZE;  <span class="comment">// 头部的 4+4+2 和 尾部的1 总共 11 字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = zmalloc(bytes);  <span class="comment">// 这里的ziplist类型是一个 char 数组，而不是某个具体的结构体</span></span><br><span class="line">    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);  <span class="comment">// 设置 zlbytes 为 初始分配的值，即 bytes</span></span><br><span class="line">    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);  <span class="comment">// 设置 zltail 为 header 结束的地方</span></span><br><span class="line">    ZIPLIST_LENGTH(zl) = <span class="number">0</span>;  <span class="comment">// 设置 zllen 为 0</span></span><br><span class="line">    zl[bytes<span class="number">-1</span>] = ZIP_END;  <span class="comment">// 最后一个字节存储常量 255 ，表示 ziplist 结束</span></span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>插入<code>ziplistInsert</code></strong></li>
</ul>
<p>这个函数的作用是 <strong>在 <code>ziplist</code> 的任意数据项前面插入一个新的数据项</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistInsert</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __ziplistInsert(zl,p,s,slen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 p 处 插入 s，s 的长度为 slen；插入后s占据p的位置，p及其后面的数据整体后移。其中 p 指向 ziplist 中某一个 entry 的起始位置，或者 zlend(当向尾部插入时)</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistInsert(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen) &#123;</span><br><span class="line">	<span class="comment">// reqlen 表示 将 s 变成一个 entry 所需要的总字节数，即 prevlen,encoding,entry-data 的总长度</span></span><br><span class="line">    <span class="keyword">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevlensize, prevlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> offset;</span><br><span class="line">    <span class="keyword">int</span> nextdiff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value = <span class="number">123456789</span>; <span class="comment">// 随便使用一个一眼就能看出来的值表示当前变量未被逻辑初始化，避免 warning</span></span><br><span class="line">    zlentry tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        <span class="comment">// 如果不是插入尾部，则根据p获取 p所在的 entry 的前一个 entry 的 prevlen，需要保存 prevlen的字节数保存在 prevlensize(1字节或者5字节，前面有介绍)</span></span><br><span class="line">        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// p 指向的是 尾部标志</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *ptail = ZIPLIST_ENTRY_TAIL(zl);</span><br><span class="line">        <span class="keyword">if</span> (ptail[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">            <span class="comment">// 获取 ziplist 最后一个 entry 的长度，保存在 prevlen 中</span></span><br><span class="line">            prevlen = zipRawEntryLength(ptail);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试能否转化成整数</span></span><br><span class="line">    <span class="keyword">if</span> (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;</span><br><span class="line">        <span class="comment">// 可以转化成 int，则 reqlen 即为存储此 int 所需的字节数，即 entry-data 的长度</span></span><br><span class="line">        reqlen = zipIntSize(encoding);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 无法转换成 int，那就是字节数组，reqlen 就是要存入的字符串的长度，即 entry-data 的长度</span></span><br><span class="line">        reqlen = slen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reqlen</span></span><br><span class="line">    reqlen += zipStorePrevEntryLength(<span class="literal">NULL</span>,prevlen);  <span class="comment">// 再加上 prevlen 的长度</span></span><br><span class="line">    reqlen += zipStoreEntryEncoding(<span class="literal">NULL</span>,encoding,slen);  <span class="comment">// 再加上 encoding 的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当不是向尾部插入时，我们必须确保下一个 entry 的 prevlen 等于当前 entry 的长度</span></span><br><span class="line">    <span class="keyword">int</span> forcelarge = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 【1】nextdiff 存储的是p的prevlen的变化值(新元素长度reqlen - p之前entry的prelen)，具体解释看代码后面【1】处的解释</span></span><br><span class="line">    nextdiff = (p[<span class="number">0</span>] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nextdiff == <span class="number">-4</span> &amp;&amp; reqlen &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        nextdiff = <span class="number">0</span>;</span><br><span class="line">        forcelarge = <span class="number">1</span>;  <span class="comment">// 这种情况下意味着，本来可以用 1 字节的，却使用了 5 个字节</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Store offset because a realloc may change the address of zl. */</span></span><br><span class="line">    <span class="comment">// 存储 p 相对于 ziplist 的偏移量，因为 resize 可能改变 ziplist 的起始地址</span></span><br><span class="line">    offset = p-zl;</span><br><span class="line">    <span class="comment">// 到这一步已经能确定 ziplist 需要的总的容量了，调用 resize 调整 ziplist 的大小</span></span><br><span class="line">    zl = ziplistResize(zl,curlen+reqlen+nextdiff);</span><br><span class="line">    <span class="comment">// 重新定位 p</span></span><br><span class="line">    p = zl+offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 p 以及其后面的数据移动为 s 挪地方，别忘了更新 zltail 的值</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在p前面腾出reqlen字节给新entry使用（将p move到p+reqlen，考虑了prelen缩减或增加）</span></span><br><span class="line">        memmove(p+reqlen,p-nextdiff,curlen-offset<span class="number">-1</span>+nextdiff);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新 s 的后一个 entry（p+reqlen即p的新地址）的prevlen；</span></span><br><span class="line">        <span class="keyword">if</span> (forcelarge)</span><br><span class="line">            <span class="comment">// 【2】强制使用 5 字节存储，避免连锁更新时的大量重新分配空间操作，不进行缩容</span></span><br><span class="line">            zipStorePrevEntryLengthLarge(p+reqlen,reqlen);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 计算 reqlen 进而判断使用 1 字节 还是 5 字节</span></span><br><span class="line">            zipStorePrevEntryLength(p+reqlen,reqlen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新 zltail</span></span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 更新zltail</span></span><br><span class="line">        zipEntry(p+reqlen, &amp;tail);</span><br><span class="line">        <span class="keyword">if</span> (p[reqlen+tail.headersize+tail.len] != ZIP_END) &#123;</span><br><span class="line">            ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是在尾部插入，则直接修改 zltail 为 s</span></span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 nexydiff 不等于0，整个 s 后面的 ziplist 的 prevlen 都可能发生变化，这里尝试进行维护</span></span><br><span class="line">    <span class="keyword">if</span> (nextdiff != <span class="number">0</span>) &#123;</span><br><span class="line">        offset = p-zl;</span><br><span class="line">        zl = __ziplistCascadeUpdate(zl,p+reqlen);</span><br><span class="line">        p = zl+offset;  <span class="comment">// 改变的只是 p 后面的，前面的没变，因此 s 插入的位置没变</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存入 s 这个 entry</span></span><br><span class="line">    p += zipStorePrevEntryLength(p,prevlen);</span><br><span class="line">    p += zipStoreEntryEncoding(p,encoding,slen);</span><br><span class="line">    <span class="keyword">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(p,s,slen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zipSaveInteger(p,value,encoding);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ziplist 的长度加 1</span></span><br><span class="line">    ZIPLIST_INCR_LENGTH(zl,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 ziplist 的长度变成 len</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistResize</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    zl = zrealloc(zl,len);</span><br><span class="line">    ZIPLIST_BYTES(zl) = intrev32ifbe(len);</span><br><span class="line">    zl[len<span class="number">-1</span>] = ZIP_END;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释【1】：这种情况发生在 <strong>插入的位置不是尾部</strong> 的情况，我们假设 <code>p</code> 的前一个元素为 <code>p0</code>，此时 <code>p</code> 的 <code>prevlen</code> 存储的是 <code>p0</code> 的长度。但是由于要将 <code>s</code> 插入到 <code>p</code> 之前，那么 <code>p</code> 的 <code>prevlen</code> 的值就应该变成 <code>s</code> 的长度，这样 <code>p</code> 本身的长度也就发生了变化，有可能变大也有可能变小。这个变化了多少的值就是 <code>nextdiff</code>，如果变大了，<code>nextdiff</code> 是正数，否则是负数。如果是负数，只有一种情况，那就是 <code>p0</code> 的长度大于 254，用 5 个字节存；而 <code>s</code> 的长度小于 254，用 1 个字节存就够了。</p>
<p>解释【2】：关于 <code>forcelarge</code>，这是一个已经被修改后的 <a target="_blank" rel="noopener" href="https://github.com/redis/redis/commit/8327b813#diff-b109b27001207a835769c556a54ff1b3">bug</a>，大致意思是，这种操作发生在 <strong>连锁更新</strong>(90 行) 的时候，为了防止大量的重新分配空间的动作，如果一个 <code>entry</code> 的长度只需要 1 个字节就能够保存,但是连锁更新时如果原先已经为 <code>prevlen</code> 分配了 5 个字节,则不会进行缩容操作。关于为何，可以参考这篇文章：<a target="_blank" rel="noopener" href="https://erpeng.github.io/2019/04/15/Redis%E7%9A%84%E4%B8%80%E4%B8%AA%E5%8E%86%E5%8F%B2bug%E5%8F%8A%E5%85%B6%E5%90%8E%E7%BB%AD%E6%94%B9%E8%BF%9B/">Redis 的一个历史 bug 及其后续改进</a>，作者对这个 <code>bug</code> 进行了复现，以及提到了 <code>Redis</code> 对此作出的更新(提出了更优化的结构 <code>listpack</code>)。</p>
<p>我们接着说 <strong>连锁更新</strong>。回忆一个 <code>entry</code> 的结构，其中 <code>prevlen</code> 表示前一个 <code>entry</code> 的长度：如果前一个结点长度小于 254，则 <code>prevlen</code> 占用 1 字节，否则占用 5 字节。现在， 考虑这样一种情况： 在一个压缩列表中， 有多个连续的、长度介于 <code>250</code> 字节到 <code>253</code> 字节之间的节点 <code>e1</code> 至 <code>eN</code> 。因为 <code>e1</code> 至 <code>eN</code> 的所有节点的长度都小于 <code>254</code> 字节， 所以记录这些节点的长度只需要 <code>1</code> 字节长的 <code>prevlen</code> 属性， 换句话说， <code>e1</code> 至 <code>eN</code> 的所有节点的 <code>prevlen</code> 属性都是 <code>1</code> 字节长的。此时，如果我们在 <code>e1</code> 前面插入一个长度大于 254 的元素 <code>m</code>，因为 <code>e1</code> 的 <code>prevlen</code> 仅为 1 字节，无法保存大于 254 的数，因此，我们还要对 <code>ziplist</code> 进行空间重分配操作，使得 <code>e1</code> 能够保存 <code>m</code> 的长度，即将 <code>ziplist</code> 的大小再增加 4 字节，让 <code>e1</code> 的 <code>prevlen</code> 大小由 1 字节变为 5 字节，这种操作我们称为 <code>m</code> 对 <code>e1</code> 发生了 <strong>扩展</strong>。回到刚才的情况，现在麻烦来了，<code>e1</code> 大小发生了变化，肯定超过了原来的 254，此时 <code>e1</code> 需要对 <code>e2</code> 进行扩展，又到后面，<code>e2</code> 需要对 <code>e3</code> 进行扩展……程序需要不断地对压缩列表执行空间重分配操作， 直到 <code>eN</code> 为止。</p>
<p><code>Redis</code> 将这种在特殊情况下产生的连续多次空间扩展操作称之为 <strong>“连锁更新”（<code>cascade update</code>）</strong>。我们看看 <strong>连锁更新</strong> 的具体实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p 指向第一个不需要更新的 entry</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistCascadeUpdate(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), rawlen, rawlensize;</span><br><span class="line">    <span class="keyword">size_t</span> offset, noffset, extra;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *np;</span><br><span class="line">    zlentry cur, next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 p 是 ziplist 的”尾巴“时停止更新</span></span><br><span class="line">    <span class="keyword">while</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        zipEntry(p, &amp;cur);  <span class="comment">// 【1】将 entry 解码称为一个易于操作的 entry 结构体，细节见代码后解释</span></span><br><span class="line">        rawlen = cur.headersize + cur.len; <span class="comment">// 当前节点的长度</span></span><br><span class="line">        rawlensize = zipStorePrevEntryLength(<span class="literal">NULL</span>,rawlen);  <span class="comment">// 存储当前节点所需要的 prevlen 大小</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有下一个节点，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (p[rawlen] == ZIP_END) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 p 的下一个节点</span></span><br><span class="line">        zipEntry(p+rawlen, &amp;next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果下一个节点的 prevlen 等于当前节点的 长度，则没必要更新，直接退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (next.prevrawlen == rawlen) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下一个节点的 prevlen 小于当前节点的长度(当前节点长度为 5 字节，next 的 prevlen 为1 字节)</span></span><br><span class="line">        <span class="keyword">if</span> (next.prevrawlensize &lt; rawlensize) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ziplist的地址可能发生改变，先记录 p 相对于zl起始位置的偏移量</span></span><br><span class="line">            offset = p-zl;</span><br><span class="line">            <span class="comment">// 额外需要申请的空间 5 - 1 = 4</span></span><br><span class="line">            extra = rawlensize-next.prevrawlensize;</span><br><span class="line">            <span class="comment">// 改变 ziplist 的容量</span></span><br><span class="line">            zl = ziplistResize(zl,curlen+extra);</span><br><span class="line">            <span class="comment">// 重新计算 p 的位置</span></span><br><span class="line">            p = zl+offset;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Current pointer and offset for next element. */</span></span><br><span class="line">            np = p+rawlen;  <span class="comment">// next 的新地址</span></span><br><span class="line">            noffset = np-zl;  <span class="comment">// next新地址相对于 ziplist 头部的偏移量</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新 zltail</span></span><br><span class="line">            <span class="keyword">if</span> ((zl+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))) != np) &#123;</span><br><span class="line">                ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                    intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+extra);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 扩展 next 的 prevlen，并将数据拷贝</span></span><br><span class="line">            memmove(np+rawlensize,</span><br><span class="line">                np+next.prevrawlensize,</span><br><span class="line">                curlen-noffset-next.prevrawlensize<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">// 在扩展后的 next 的 prevlen 中重新记录 p 的长度</span></span><br><span class="line">            zipStorePrevEntryLength(np,rawlen);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Advance the cursor */</span></span><br><span class="line">            <span class="comment">// 更新 p 为下一个 entry</span></span><br><span class="line">            p += rawlen;</span><br><span class="line">            <span class="comment">// 更新 p 的长度(需要加上扩展的 prevlen 的 extra 个字节)</span></span><br><span class="line">            curlen += extra;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这种情况下，next 的 prevlen 足够表示 当前 p 的长度</span></span><br><span class="line">            <span class="keyword">if</span> (next.prevrawlensize &gt; rawlensize) &#123;</span><br><span class="line">                <span class="comment">// next 的 prevlen &gt; p 的长度(next.prevlen = 5 结点，p的长度小于 5 个结点)，此时应该 缩容，但出于性能以及操作的方便性(减少后续连锁更新的可能性)，我们通常不进行缩容，这个时候，直接将 next 的 prevlen 设置为 5 个结点</span></span><br><span class="line">                zipStorePrevEntryLengthLarge(p+rawlen,rawlen);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 相等</span></span><br><span class="line">                zipStorePrevEntryLength(p+rawlen,rawlen);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// next 的长度并没有发生变化(没有缩容)，终止循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释【1】：“辅助结构体” <code>zlentry</code>，这个结构体与 <code>ziplist</code> 中的一个实际 <code>entry</code> 相对应，其作用是为了更加方便地操作一个 实际的 <code>entry</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zlentry</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevrawlensize; <span class="comment">// 存储 prevrawlen 所需要的字节数，同样也有 1字节 和 5字节之分</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevrawlen;     <span class="comment">// 对应 prevlen</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lensize;        <span class="comment">// 存储 len 所需要的字节数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;            <span class="comment">// 当前 entry 的长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> headersize;     <span class="comment">// ziplist头部大小: prevrawlensize + lensize</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding;      <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;            <span class="comment">// 指向某个实际 entry 的地址</span></span><br><span class="line">&#125; zlentry;</span><br></pre></td></tr></table></figure>
<p><strong>其他的一些操作，比如删除、查找，过程与插入类似，无非就是各个 entry 地址的计算，删除时还有可能涉及到连锁更新。</strong> 这里不再描述，想了解的可以根据上面的思路自己研究源代码。</p>
<h4 id="63-总结"><a class="markdownIt-Anchor" href="#63-总结"></a> 6.3 总结</h4>
<ul>
<li><code>ziplist</code>是 redis 为了节省内存，提升存储效率自定义的一种紧凑的数据结构，每一个 <code>entry</code> 都保存这上一个 <code>entry</code> 的长度，可以很方便地进行反向遍历；</li>
<li>添加和删除节点可能会引发连锁更新，极端情况下会更新整个<code>ziplist</code>，但是概率很小；</li>
<li>在 <code>Redis</code> 中，当元素个数较少时，哈希表(<code>hset</code> 等操作) 和 列表(<code>lpush</code> 等操作) 的底层结构都是 <code>ziplist</code>。</li>
</ul>
<h3 id="7-紧凑列表"><a class="markdownIt-Anchor" href="#7-紧凑列表"></a> 7. 紧凑列表</h3>
<blockquote>
<p>源码文件：<a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/unstable/src/listpack.h">listpack.h</a></p>
<p>实现文档：<a target="_blank" rel="noopener" href="https://gist.github.com/antirez/66ffab20190ece8a7485bd9accfbc175">Listpack specification</a></p>
</blockquote>
<p>紧凑列表是 压缩列表 的升级版，目的是在未来代替 <code>ziplist</code>。</p>
<p>有时间再完善。</p>
<h2 id="二-redis-对象对应的数据结构"><a class="markdownIt-Anchor" href="#二-redis-对象对应的数据结构"></a> 二、 <code>Redis</code> 对象对应的数据结构</h2>
<p>前面大致介绍了 <strong>简单动态字符串 <code>sds</code></strong>、<strong>双端链表 <code>adlist</code></strong>、<strong>字典 <code>dict</code></strong>、<strong>跳表 <code>skiplist</code></strong>、<strong>整数集合 <code>intset</code></strong> 和 <strong>压缩列表 <code>ziplist</code></strong> 等基础数据结构，同时我们知道 <code>Redis</code> 中有 <strong>字符串对象(string)</strong>、<strong>列表对象(list)</strong>、<strong>哈希对象(hash)</strong>、<strong>集合对象(set)</strong> 和 <strong>有序集合对象(zset)</strong> 等五种对象，他们都至少用了上面一种基础数据结构来实现。在 <code>Redis</code> 中，客户端的一条命令以及参数会被解释成一个 <code>robj</code> 结构体：</p>
<blockquote>
<p>源码文件： <a href="%5Bziplist.h%5D(https://github.com/redis/redis/blob/unstable/src/server.h)">server.h</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type : <span class="number">4</span>;       <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding : <span class="number">4</span>;	 <span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru : LRU_BITS; <span class="comment">// 对象最后被访问的时间，我们暂时不关注 LRU</span></span><br><span class="line">    <span class="keyword">int</span> refcount;			 <span class="comment">// 引用次数</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;				 <span class="comment">// 指向实现对象的数据结构</span></span><br><span class="line">&#125; robj;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Object types */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_STRING 0 <span class="comment">/* String object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_LIST 1   <span class="comment">/* List object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_SET 2    <span class="comment">/* Set object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ZSET 3   <span class="comment">/* Sorted set object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_HASH 4   <span class="comment">/* Hash object. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Objects encoding. Some kind of objects like Strings and Hashes can be</span></span><br><span class="line"><span class="comment"> * internally represented in multiple ways. The &#x27;encoding&#x27; field of the object</span></span><br><span class="line"><span class="comment"> * is set to one of this fields for this object. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_RAW 0        <span class="comment">// 简单动态字符串 sds</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INT 1        <span class="comment">// long 类型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_HT 2         <span class="comment">// 字典 dict</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPMAP 3     <span class="comment">// zipmap(弃用)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">// 双端链表 adlist</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPLIST 5    <span class="comment">// 压缩列表 ziplist</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INTSET 6     <span class="comment">// 整数集合 intset</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_SKIPLIST 7   <span class="comment">// 跳表 skiplist</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR 8     <span class="comment">// 采用embstr编码的sds</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_QUICKLIST 9  <span class="comment">// qunicklist，用于列表</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_STREAM 10    <span class="comment">// 紧凑列表 listpack</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_BITS 24</span></span><br></pre></td></tr></table></figure>
<p><code>obj</code> 的作用大致为：</p>
<ul>
<li>为多种数据类型提供一种统一的表示方式。</li>
<li>允许同一类型的数据采用不同的内部表示，从而在某些情况下尽量节省内存。</li>
<li>支持对象共享和引用计数。当对象被共享的时候，只占用一份内存拷贝，进一步节省内存。</li>
</ul>
<p>说到底， <code>robj</code> 所表示的就是 <strong>五种 <code>Object types</code></strong> 和 <strong>11 中 <code>Object encoding</code></strong> 之间的对应方式，起到一个桥梁作用。这种对应关系可用如下的图来表示：</p>
<p><img src="https://pic.downk.cc/item/5f7a3a91160a154a67813577.png" alt="Redis对象与数据结构对应关系" /></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Jemmy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://blog.hujm.net/2020/10/02/redis-yuan-ma-yue-du-1-ji-chu-shu-ju-jie-gou-yu-dui-xiang/">http://blog.hujm.net/2020/10/02/redis-yuan-ma-yue-du-1-ji-chu-shu-ju-jie-gou-yu-dui-xiang/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.hujm.net" target="_blank">Jemmy's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">基础数据结构</a></div><div class="post_share"><div class="social-share" data-image="https://pic.downk.cc/item/5f76adca160a154a674bc4da.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/10/05/tiao-biao/"><img class="prev-cover" src="https://pic.downk.cc/item/5f77e088160a154a67ede68f.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">跳表原理以及Golang实现</div></div></a></div><div class="next-post pull-right"><a href="/2020/09/29/mysql-guan-yu-suo-yin/"><img class="next-cover" src="https://pic.downk.cc/item/5f73fbb3160a154a67b4ff7e.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MySQL关于索引</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Jemmy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'LjkR3NaCog7bTVOnJNMmJjcM-gzGzoHsz',
      appKey: 'UQMdKbH71EeHJppAbtDwb5Rg',
      placeholder: '欢迎评论~',
      avatar: 'monsterid',
      meta: 'nick,mail'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>