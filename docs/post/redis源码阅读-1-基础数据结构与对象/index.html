<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Redis源码阅读--1.基础数据结构与对象 - Jemmy&#39;s blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="JemmyHu(hujm20151021@gmail.com)" /><meta name="description" content="首先明确，Redis 是一个使用 C 语言编写的键值对存储系统。Redis 是众所周知的 “快”，一方面，它是一个内存数据库，所有的操作都是在内存中完" /><meta name="keywords" content="Jemmy, blog" />






<meta name="generator" content="Hugo 0.76.5 with theme even" />


<link rel="canonical" href="http://localhost:1313/post/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-1-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.c7bc1becf36bcf6a9ebd25d2947e43a2eb745ddb0c9a32b43126fd7fa460c351.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Redis源码阅读--1.基础数据结构与对象" />
<meta property="og:description" content="首先明确，Redis 是一个使用 C 语言编写的键值对存储系统。Redis 是众所周知的 “快”，一方面，它是一个内存数据库，所有的操作都是在内存中完" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/post/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-1-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/" />
<meta property="article:published_time" content="2020-10-02T12:31:41+00:00" />
<meta property="article:modified_time" content="2020-10-02T12:31:41+00:00" />
<meta itemprop="name" content="Redis源码阅读--1.基础数据结构与对象">
<meta itemprop="description" content="首先明确，Redis 是一个使用 C 语言编写的键值对存储系统。Redis 是众所周知的 “快”，一方面，它是一个内存数据库，所有的操作都是在内存中完">
<meta itemprop="datePublished" content="2020-10-02T12:31:41+00:00" />
<meta itemprop="dateModified" content="2020-10-02T12:31:41+00:00" />
<meta itemprop="wordCount" content="18448">



<meta itemprop="keywords" content="Redis,基础数据结构," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Redis源码阅读--1.基础数据结构与对象"/>
<meta name="twitter:description" content="首先明确，Redis 是一个使用 C 语言编写的键值对存储系统。Redis 是众所周知的 “快”，一方面，它是一个内存数据库，所有的操作都是在内存中完"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Jemmy&#39;s blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">时间线</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Jemmy&#39;s blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">时间线</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Redis源码阅读--1.基础数据结构与对象</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-10-02 12:31 </span>
        <div class="post-category">
            <a href="/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"> 技术博客 </a>
            <a href="/categories/%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/"> 技术细节 </a>
            <a href="/categories/redis/"> Redis </a>
            </div>
          <span class="more-meta"> 约 18448 字 </span>
          <span class="more-meta"> 预计阅读 37 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#一底层数据结构">一、底层数据结构</a>
          <ul>
            <li><a href="#1-简单动态字符串">1. 简单动态字符串</a></li>
            <li><a href="#2-双端链表">2. 双端链表</a></li>
            <li><a href="#3-字典">3. 字典</a></li>
            <li><a href="#4-跳表">4. 跳表</a></li>
            <li><a href="#5-整数集合">5. 整数集合</a></li>
            <li><a href="#6-压缩列表">6. 压缩列表</a></li>
            <li><a href="#7-紧凑列表">7. 紧凑列表</a></li>
          </ul>
        </li>
        <li><a href="#二-redis-对象对应的数据结构">二、 <code>Redis</code> 对象对应的数据结构</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>首先明确，<code>Redis</code> 是一个<strong>使用 C 语言编写的键值对存储系统</strong>。<code>Redis</code> 是众所周知的 “<strong>快</strong>”，一方面，它是一个内存数据库，所有的操作都是在<strong>内存</strong>中完成的，内存的访问速度本身就很快；另一方面，得益于它<strong>底层的数据结构</strong>。<code>Redis</code> 的常见类型可在这个网页找到：<a href="https://redis.readthedocs.io/en/2.4/index.html">Redis 命令参考简体中文版</a>，其使用到的底层数据结构有如下六种：<strong>简单动态字符串</strong>、<strong>双向链表</strong>、<strong>压缩列表</strong>、<strong>哈希表</strong>、<strong>跳表</strong>和 <strong>整数数组</strong>。本篇文章，将具体了解这些底层数据结构的实现。</p>
<blockquote>
<p>本文所涉及源码位于：<a href="https://github.com/redis/redis">https://github.com/redis/redis</a>，所选版本为 <strong>6.0.8</strong>。</p>
<p>绘图工具为 <a href="draw.io">draw.io</a></p>
<p>涉及到内存操作的函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="o">*</span><span class="nf">zmalloc</span><span class="p">(</span><span class="n">size_t</span> <span class="n">size</span><span class="p">);</span> <span class="c1">// 调用zmalloc函数，申请size大小的空间
</span><span class="c1"></span><span class="kt">void</span> <span class="o">*</span><span class="nf">zcalloc</span><span class="p">(</span><span class="n">size_t</span> <span class="n">size</span><span class="p">);</span> <span class="c1">// 调用系统函数calloc申请内存空间
</span><span class="c1"></span><span class="kt">void</span> <span class="o">*</span><span class="nf">zrealloc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span><span class="p">);</span> <span class="c1">// 原内存重新调整为size空间的大小
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">zfree</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>  <span class="c1">// 调用zfree释放内存空间
</span><span class="c1"></span><span class="kt">char</span> <span class="o">*</span><span class="nf">zstrdup</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">);</span> <span class="c1">// 字符串复制方法
</span><span class="c1"></span><span class="n">size_t</span> <span class="nf">zmalloc_used_memory</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span> <span class="c1">// 获取当前以及占用的内存空间大小
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">zmalloc_enable_thread_safeness</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span> <span class="c1">// 是否设置线程安全模式
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">zmalloc_set_oom_handler</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">oom_handler</span><span class="p">)(</span><span class="n">size_t</span><span class="p">));</span> <span class="c1">// 可自定义设置内存溢出的处理方法
</span><span class="c1"></span><span class="kt">float</span> <span class="nf">zmalloc_get_fragmentation_ratio</span><span class="p">(</span><span class="n">size_t</span> <span class="n">rss</span><span class="p">);</span> <span class="c1">// 获取所给内存和已使用内存的大小之比
</span><span class="c1"></span><span class="n">size_t</span> <span class="nf">zmalloc_get_rss</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span> <span class="c1">// 获取RSS信息(Resident Set Size)
</span><span class="c1"></span><span class="n">size_t</span> <span class="nf">zmalloc_get_private_dirty</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span> <span class="c1">// 获得实际内存大小
</span><span class="c1"></span><span class="n">size_t</span> <span class="nf">zmalloc_get_smap_bytes_by_field</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">field</span><span class="p">);</span> <span class="c1">// 获取/proc/self/smaps字段的字节数
</span><span class="c1"></span><span class="n">size_t</span> <span class="nf">zmalloc_get_memory_size</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span> <span class="c1">// 获取物理内存大小
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">zlibc_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span> <span class="c1">// 原始系统free释放方法
</span></code></pre></td></tr></table>
</div>
</div></blockquote>
<h2 id="一底层数据结构">一、底层数据结构</h2>
<h3 id="1-简单动态字符串">1. 简单动态字符串</h3>
<blockquote>
<p>源码文件：<a href="https://github.com/redis/redis/blob/unstable/src/sds.h">sds.h</a></p>
</blockquote>
<h4 id="11-数据结构">1.1 数据结构</h4>
<p><strong>SDS（Simple Dynamic Strings, 简单动态字符串）是 Redis 的一种基本数据结构，主要是用于存储字符串和整数。</strong> 在 <code>Redis 3.2</code> 版本以前，<code>SDS</code> 的实现如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">sdshdr</span> <span class="p">{</span>
    <span class="c1">// 记录 buf 数组中已使用字节的数量，等于 SDS 所保存字符串的长度
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

    <span class="c1">// 记录 buf 数组中未使用字节的数量
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">free</span><span class="p">;</span>

    <span class="c1">// 字节数组，用于保存字符串
</span><span class="c1"></span>    <span class="kt">char</span> <span class="n">buf</span><span class="p">[];</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>比如，字符串 <code>Redis6.0</code> 的结构如下：</p>
<p><img src="https://pic.downk.cc/item/5f768cb7160a154a67445538.png" alt="带有未使用空间的SDS"></p>
<p><code>SDS</code> 遵循 <strong><code>C</code> 字符串以空字符结尾</strong>的惯例， 但保存空字符的 <code>1</code> 字节空间不计算在 SDS 的 <code>len</code> 属性里面， 并且为空字符分配额外的 <code>1</code> 字节空间， 以及添加空字符到字符串末尾等操作都是由 <code>SDS</code> 函数自动完成的， 所以这个空字符对于 <code>SDS</code> 的使用者来说是完全透明的——这样做的好处是，<code>SDS</code> 可以直接使用 <code>C</code> 库中的有关字符串的函数。</p>
<p>但是在 <code>Redis 3.2</code> 以后，为了提高效率以及更加节省内存，<code>Redis</code> 将 <code>SDS</code> 划分成一下五种类型：</p>
<ul>
<li><code>sdshdr5</code></li>
<li><code>sdshdr8</code></li>
<li><code>sdshdr16</code></li>
<li><code>sdshdr32</code></li>
<li><code>sdshdr64</code></li>
</ul>
<p>先看 <code>sdshdr5</code>，增加了一个 <code>flags</code> 字段来标识类型，用一个字节(8 位)来存储：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// Note: sdshdr5 is never used, we just access the flags byte directly.
</span><span class="c1"></span><span class="k">struct</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">sdshdr5</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">flags</span><span class="p">;</span> <span class="cm">/* 前 3 位表示类型, 后 5 为表示长度 */</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[];</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>对于 <code>sdshdr5</code> ，因为其可存储长度最大为 <code>2^5 - 1 = 31</code>，当字符串长度超过 31 时，仅靠 <code>flag</code> 的后 5 为表示长度是不够的，这时需要使用其他的四个结构来保存：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">sdshdr8</span> <span class="p">{</span>
    <span class="n">uint8_t</span> <span class="n">len</span><span class="p">;</span>                <span class="c1">// 已使用长度 1字节
</span><span class="c1"></span>    <span class="n">uint8_t</span> <span class="n">alloc</span><span class="p">;</span>              <span class="c1">// 总长度 1字节
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">flags</span><span class="p">;</span>        <span class="c1">// 前 3 位表示存储类型，后 5 位 预留
</span><span class="c1"></span>    <span class="kt">char</span> <span class="n">buf</span><span class="p">[];</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">sdshdr16</span> <span class="p">{</span>
    <span class="n">uint16_t</span> <span class="n">len</span><span class="p">;</span>               <span class="c1">// 已使用长度 2字节
</span><span class="c1"></span>    <span class="n">uint16_t</span> <span class="n">alloc</span><span class="p">;</span>             <span class="c1">// 总长度 2字节
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">flags</span><span class="p">;</span>        <span class="c1">// 前 3 位表示存储类型，后 5 位 预留
</span><span class="c1"></span>    <span class="kt">char</span> <span class="n">buf</span><span class="p">[];</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">sdshdr32</span> <span class="p">{</span>
    <span class="n">uint32_t</span> <span class="n">len</span><span class="p">;</span>               <span class="c1">// 已使用长度 4字节
</span><span class="c1"></span>    <span class="n">uint32_t</span> <span class="n">alloc</span><span class="p">;</span>             <span class="c1">// 总长度 4字节
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">flags</span><span class="p">;</span>        <span class="c1">// 前 3 位表示存储类型，后 5 位 预留
</span><span class="c1"></span>    <span class="kt">char</span> <span class="n">buf</span><span class="p">[];</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nf">__attribute__</span> <span class="p">((</span><span class="n">__packed__</span><span class="p">))</span> <span class="n">sdshdr64</span> <span class="p">{</span>
    <span class="n">uint64_t</span> <span class="n">len</span><span class="p">;</span>               <span class="c1">// 已使用长度 8字节
</span><span class="c1"></span>    <span class="n">uint64_t</span> <span class="n">alloc</span><span class="p">;</span>             <span class="c1">// 总长度 8字节
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">flags</span><span class="p">;</span>        <span class="c1">// 前 3 位表示存储类型，后 5 位 预留
</span><span class="c1"></span>    <span class="kt">char</span> <span class="n">buf</span><span class="p">[];</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>C/C++ 中 <code>__packed</code> 的作用：</p>
<p>假设有以下结构体：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="p">{</span>
   <span class="kt">char</span> <span class="n">a</span><span class="p">;</span>      <span class="c1">// 1 字节
</span><span class="c1"></span>   <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>       <span class="c1">// 4 字节
</span><span class="c1"></span>   <span class="kt">char</span> <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>   <span class="c1">// 2 字节
</span><span class="c1"></span>   <span class="kt">double</span> <span class="n">d</span><span class="p">;</span>    <span class="c1">// 8 字节
</span><span class="c1"></span><span class="p">}</span><span class="n">Struct_A</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>在计算机内存中，<strong>结构体变量的存储通常是按字长对齐的</strong>，比如在 8 位机上，就按照 1 字节(8 位)对齐，上述结构体占用 <code>1+4+2+8=15​</code> 字节的内存；在 16 位机上，按照 2 字节对齐，则该结构体占用 <code>2+4+2+8=16​</code> 字节。也就是说，在更高位的机器中，如果按照默认的机器字长做内存对齐的标准，那总会有一些空间是浪费的，比如上面 16 位时，为了对齐，使用了 2 字节来存储一个<code>char</code>类型的变量。为什么要对齐？这是因为对内存操作按照整字存取会有更高的效率，是 “以空间换时间” 的思想体现。当然，在空间更优先的情况下，也可以不使用默认的机器字长做内存对齐，这个时候，使用 <code>__packed___</code>关键字，可以强制使编译器将结构体成员按照 1 字节进行内存对齐，可以得到非对齐的紧凑型结构体。</p>
</blockquote>
<h4 id="12-api">1.2 API</h4>
<ul>
<li><strong>创建 SDS</strong></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* Create a new sds string starting from a null terminated C string. */</span>
<span class="n">sds</span> <span class="nf">sdsnew</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">init</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">size_t</span> <span class="n">initlen</span> <span class="o">=</span> <span class="p">(</span><span class="n">init</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">strlen</span><span class="p">(</span><span class="n">init</span><span class="p">);</span>  <span class="c1">// 拿到要创建的字符串的长度
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">sdsnewlen</span><span class="p">(</span><span class="n">init</span><span class="p">,</span> <span class="n">initlen</span><span class="p">);</span>  <span class="c1">// 传入字符串、字符串长度，调用 sdsnewlen 动态分配内存
</span><span class="c1"></span><span class="p">}</span>
<span class="n">sds</span> <span class="nf">sdsnewlen</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">init</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">initlen</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">sh</span><span class="p">;</span>
    <span class="n">sds</span> <span class="n">s</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">type</span> <span class="o">=</span> <span class="n">sdsReqType</span><span class="p">(</span><span class="n">initlen</span><span class="p">);</span>  <span class="c1">// 根据字符串长度得到合适的类型
</span><span class="c1"></span>    <span class="c1">// 一般情况下，创建一个空字符串的目的都是为了后面的append操作，因此，空字符串的情况下，直接创建SDS_TYPE_8，减少后面的扩容操作
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">SDS_TYPE_5</span> <span class="o">&amp;&amp;</span> <span class="n">initlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">type</span> <span class="o">=</span> <span class="n">SDS_TYPE_8</span><span class="p">;</span>
    <span class="c1">// 计算类型对应的结构体头部长度(len alloc flags的长度)
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">hdrlen</span> <span class="o">=</span> <span class="n">sdsHdrSize</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
    <span class="c1">// 指向flag的指针
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>

    <span class="c1">// 申请内存，内存大小为 结构体头部长度+字符串长度(buf)+1，这里+1是因为要考虑 &#39;\0&#39; 字符
</span><span class="c1"></span>    <span class="n">sh</span> <span class="o">=</span> <span class="n">s_malloc</span><span class="p">(</span><span class="n">hdrlen</span><span class="o">+</span><span class="n">initlen</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">init</span><span class="o">==</span><span class="n">SDS_NOINIT</span><span class="p">)</span>
        <span class="n">init</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">init</span><span class="p">)</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">sh</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hdrlen</span><span class="o">+</span><span class="n">initlen</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="c1">// 将s指向buf
</span><span class="c1"></span>    <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">sh</span><span class="o">+</span><span class="n">hdrlen</span><span class="p">;</span>
    <span class="c1">// 将 s-1 指向flag
</span><span class="c1"></span>    <span class="n">fp</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="c1">// 对sds结构体变量进行赋值
</span><span class="c1"></span>    <span class="k">switch</span><span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nl">SDS_TYPE_5</span><span class="p">:</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">fp</span> <span class="o">=</span> <span class="n">type</span> <span class="o">|</span> <span class="p">(</span><span class="n">initlen</span> <span class="o">&lt;&lt;</span> <span class="n">SDS_TYPE_BITS</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">case</span> <span class="nl">SDS_TYPE_8</span><span class="p">:</span> <span class="p">{</span>
            <span class="n">SDS_HDR_VAR</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="n">s</span><span class="p">);</span>
            <span class="n">sh</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">initlen</span><span class="p">;</span>
            <span class="n">sh</span><span class="o">-&gt;</span><span class="n">alloc</span> <span class="o">=</span> <span class="n">initlen</span><span class="p">;</span>
            <span class="o">*</span><span class="n">fp</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="p">...</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">initlen</span> <span class="o">&amp;&amp;</span> <span class="n">init</span><span class="p">)</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">init</span><span class="p">,</span> <span class="n">initlen</span><span class="p">);</span>
    <span class="c1">// 在s的最后添加&#39;\0&#39;
</span><span class="c1"></span>    <span class="n">s</span><span class="p">[</span><span class="n">initlen</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
    <span class="c1">// 返回指向 buf 数组的指针s
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>注意，创建 <code>SDS</code> 时返回给上层的是指向 <code>buf</code> 数组的指针 s，而不是结构体的指针，那如何找到结构体中的其他元素呢？上面提到了 <code>__packed__</code> 关键字，使用 1 字节进行内存对齐，那么知道了 <code>buf</code> 的地址，将其减去对应类型的长度(偏移量)，就能得到结构体中其他类型的地址。</p>
<ul>
<li><strong>清空 SDS</strong></li>
</ul>
<p>清空一个 <code>SDS</code> 有两个途径：</p>
<p>第一种是直接调用 <code>s_free()</code> 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* Free an sds string. No operation is performed if &#39;s&#39; is NULL. */</span>
<span class="kt">void</span> <span class="nf">sdsfree</span><span class="p">(</span><span class="n">sds</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="n">s_free</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">s</span><span class="o">-</span><span class="n">sdsHdrSize</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]));</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>另一种方式是 <strong>重置 len 为 0</strong> 的方式，这种情况下 <code>buf</code> 所占用的空间并没有被清除掉，新的数据会直接覆盖 <code>buf</code> 中的原有数据而无需再申请新的内存空间：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* Modify an sds string in-place to make it empty (zero length).
</span><span class="cm"> * However all the existing buffer is not discarded but set as free space
</span><span class="cm"> * so that next append operations will not require allocations up to the
</span><span class="cm"> * number of bytes previously available. */</span>
<span class="kt">void</span> <span class="nf">sdsclear</span><span class="p">(</span><span class="n">sds</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sdssetlen</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>拼接 SDS</strong></li>
</ul>
<p>拼接使用的是 <code>sds sdscatsds(sds s, sds t)</code>，但最终调用的还是 <code>sdscatlen</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 将 t 拼接到 s 后面。调用此方法之后，sds底层的buf可能经过了扩容迁移了原来的位置，注意更新原来变量中对应的指针
</span><span class="c1"></span><span class="n">sds</span> <span class="nf">sdscatsds</span><span class="p">(</span><span class="n">sds</span> <span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="n">sds</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">sdscatlen</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">sdslen</span><span class="p">(</span><span class="n">t</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">sds</span> <span class="nf">sdscatlen</span><span class="p">(</span><span class="n">sds</span> <span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">size_t</span> <span class="n">curlen</span> <span class="o">=</span> <span class="n">sdslen</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>  <span class="c1">// 计算当前s的长度
</span><span class="c1"></span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">sdsMakeRoomFor</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">len</span><span class="p">);</span>  <span class="c1">// 空间不够的话扩容，确保s的剩余空间足够放得下t
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// 扩容失败
</span><span class="c1"></span>    <span class="n">memcpy</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="n">curlen</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>   <span class="c1">// 拼接
</span><span class="c1"></span>    <span class="n">sdssetlen</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">curlen</span><span class="o">+</span><span class="n">len</span><span class="p">);</span>   <span class="c1">// 更新s的属性len
</span><span class="c1"></span>    <span class="n">s</span><span class="p">[</span><span class="n">curlen</span><span class="o">+</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>       <span class="c1">// 给s最后加上 &#39;\0&#39;
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>接下来我们详细看一下扩容规则，在函数 <code>sdsMakeRoomFor</code> 中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 将sds s的 buf 的可用空间扩大，使得调用此函数之后的s能够再多存储 addlen 长度的字符串。
</span><span class="c1">// 注意：此方法并未改变 sds 的len属性，仅仅改变的是 sds 的 buf 数组的空间。
</span><span class="c1"></span><span class="n">sds</span> <span class="nf">sdsMakeRoomFor</span><span class="p">(</span><span class="n">sds</span> <span class="n">s</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">addlen</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">sh</span><span class="p">,</span> <span class="o">*</span><span class="n">newsh</span><span class="p">;</span>
    <span class="n">size_t</span> <span class="n">avail</span> <span class="o">=</span> <span class="n">sdsavail</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>  <span class="c1">// 当前的可用空间长度：s.alloc - s.len
</span><span class="c1"></span>    <span class="n">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">newlen</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">type</span><span class="p">,</span> <span class="n">oldtype</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">SDS_TYPE_MASK</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">hdrlen</span><span class="p">;</span>

    <span class="c1">// 情况1：剩余长度大于所需要长度，没必要扩容，直接返回
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">avail</span> <span class="o">&gt;=</span> <span class="n">addlen</span><span class="p">)</span> <span class="k">return</span> <span class="n">s</span><span class="p">;</span>

    <span class="n">len</span> <span class="o">=</span> <span class="n">sdslen</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>     	<span class="c1">// 当前字符串长度
</span><span class="c1"></span>    <span class="n">sh</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">s</span><span class="o">-</span><span class="n">sdsHdrSize</span><span class="p">(</span><span class="n">oldtype</span><span class="p">);</span>
    <span class="n">newlen</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span><span class="o">+</span><span class="n">addlen</span><span class="p">);</span>    <span class="c1">// 新字符串长度
</span><span class="c1"></span>
    <span class="c1">// 情况2：扩容
</span><span class="c1"></span>    <span class="c1">// 情况2.1： 如果 新长度 &lt; 1MB，则按 新长度的2倍 扩容
</span><span class="c1"></span>    <span class="c1">//    		否则，就按 新长度+1MB 扩容
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">newlen</span> <span class="o">&lt;</span> <span class="n">SDS_MAX_PREALLOC</span><span class="p">)</span>
        <span class="n">newlen</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">newlen</span> <span class="o">+=</span> <span class="n">SDS_MAX_PREALLOC</span><span class="p">;</span>

    <span class="c1">// 计算新长度的类型
</span><span class="c1"></span>    <span class="n">type</span> <span class="o">=</span> <span class="n">sdsReqType</span><span class="p">(</span><span class="n">newlen</span><span class="p">);</span>

    <span class="c1">// 还是为了后续使用减少扩容次数的原因，将 sdshdr5 变为 sdshdr8
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">SDS_TYPE_5</span><span class="p">)</span> <span class="n">type</span> <span class="o">=</span> <span class="n">SDS_TYPE_8</span><span class="p">;</span>

    <span class="n">hdrlen</span> <span class="o">=</span> <span class="n">sdsHdrSize</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">oldtype</span><span class="o">==</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 如果新长度对应的类型没变，则直接调用 s_realloc 扩大动态数组即可
</span><span class="c1"></span>        <span class="n">newsh</span> <span class="o">=</span> <span class="n">s_realloc</span><span class="p">(</span><span class="n">sh</span><span class="p">,</span> <span class="n">hdrlen</span><span class="o">+</span><span class="n">newlen</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">newsh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">newsh</span><span class="o">+</span><span class="n">hdrlen</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* Since the header size changes, need to move the string forward,
</span><span class="cm">         * and can&#39;t use realloc */</span>
        <span class="c1">// 类型发生了改变，意味着sds结构体头部的三个属性的类型也要跟着变化，此时直接重新申请一块内存
</span><span class="c1"></span>        <span class="n">newsh</span> <span class="o">=</span> <span class="n">s_malloc</span><span class="p">(</span><span class="n">hdrlen</span><span class="o">+</span><span class="n">newlen</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">newsh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="c1">// 原s的数据拷贝到新的内存上
</span><span class="c1"></span>        <span class="n">memcpy</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">newsh</span><span class="o">+</span><span class="n">hdrlen</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">len</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="c1">// 释放掉原来的s的空间，并将其更新为刚才新申请的
</span><span class="c1"></span>        <span class="n">s_free</span><span class="p">(</span><span class="n">sh</span><span class="p">);</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">newsh</span><span class="o">+</span><span class="n">hdrlen</span><span class="p">;</span>
        <span class="c1">// 更新 flag
</span><span class="c1"></span>        <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
        <span class="c1">// 更新 len
</span><span class="c1"></span>        <span class="n">sdssetlen</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 更新 alloc
</span><span class="c1"></span>    <span class="n">sdssetalloc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">newlen</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>代码中注释已经很清楚了，这里再总结一下扩容策略：如果 <code>剩余长度 avail</code> &gt;= <code>新增长度 addlen</code> ，则无需扩容；否则，如果 <code>avail + addlen &lt; 1MB</code>，按照 <code>2 * (avail + addlen)</code>扩容，否则按照 <code>avail + addlen + 1MB</code> 扩容。</p>
<h4 id="13-总结">1.3 总结</h4>
<ul>
<li>创建 <code>SDS</code> 时返回的是指向 <code>buf</code> 数组的指针，而不是 <code>SDS</code> 类型的对象，这样的好处是兼容了已有的 C 语言中的相关函数；</li>
<li>读取内容时，先通过类对应类型计算偏移量，再通过 <code>len</code> 属性来限制读取的长度，杜绝了缓冲区溢出，二进制安全；</li>
<li>根据字符串的长度，定义了五种不同的类型，节省了空间；</li>
<li>进行字符串拼接时，会通过 <code>sdsMakeRoomFor</code> 函数来决定是否有底层 <code>buf</code> 数组的扩容操作。</li>
</ul>
<h3 id="2-双端链表">2. 双端链表</h3>
<blockquote>
<p>源码文件：<a href="https://github.com/redis/redis/blob/unstable/src/adlist.h">adlist.h</a></p>
</blockquote>
<h4 id="21-数据结构">2.1 数据结构</h4>
<p>当我们使用 <code>lpush</code> 或者 <code>rpush</code> 的时候，其实底层对应的数据结构就是一个双端链表。</p>
<p>首先我们来了解结点 <code>listNode</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">listNode</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">listNode</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>  <span class="c1">// 头指针
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">listNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>  <span class="c1">// 尾指针
</span><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>    		<span class="c1">// 具体的值，因为值的类型不确定，此处使用万能指针
</span><span class="c1"></span><span class="p">}</span> <span class="n">listNode</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>虽然使用多个 <code>listNode</code>就已经足够表示一个双端链表，但是为了更方便，<code>Redis</code> 还有如下结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">typedef struct list {
    listNode *head;  // 头指针
    listNode *tail;  // 尾指针
    void *(*dup)(void *ptr);  // 拷贝结点函数
    void (*free)(void *ptr);  // 释放结点值函数
    int (*match)(void *ptr, void *key); // 判断两个结点是否相等的函数
    unsigned long len;  // 链表长度
} list;
</code></pre></td></tr></table>
</div>
</div><p>他们的关系可用如下图表示：</p>
<p><img src="https://pic.downk.cc/item/5f769152160a154a6745655b.png" alt="Redis双端链表"></p>
<h4 id="22-api">2.2 API</h4>
<ul>
<li><strong>创建 <code>list</code> 对象</strong></li>
</ul>
<p>创建的是一个 <code>list</code> 对象，首先会尝试申请分配空间，失败返回 <code>NULL</code> ：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 创建的只是一个 list 对象，这个对象可以被 AlFreeList() 释放掉，但是仅仅释放的是这个 list 对象，其上面的 listNode 对象还需要另外手动释放
</span><span class="c1"></span><span class="n">list</span> <span class="o">*</span><span class="nf">listCreate</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">list</span> <span class="o">*</span><span class="n">list</span><span class="p">;</span>

    <span class="c1">// 申请分配内存，失败返回 NULL
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">((</span><span class="n">list</span> <span class="o">=</span> <span class="n">zmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">list</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="c1">// 给其他属性赋值
</span><span class="c1"></span>    <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">list</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">list</span><span class="o">-&gt;</span><span class="n">dup</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">list</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">list</span><span class="o">-&gt;</span><span class="n">match</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="c1">// 最终返回 list 对象
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">list</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>添加元素 <code>listNode</code> 到 <code>list</code></strong></li>
</ul>
<p>给一个带头的双向链表添加元素，有三种添加方法：<strong>头插入</strong> 、 <strong>尾插入</strong> 和 指定位置，分别对应的操作为 <code>lpush</code> 、<code>rpush</code> 和 <code>linsert</code>。对于 <code>lpush</code> 和 <code>rpush</code> 的实现如下，本质上就是对双端链表的基础操作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">list</span> <span class="o">*</span><span class="nf">listAddNodeHead</span><span class="p">(</span><span class="n">list</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">listNode</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="c1">// 申请分配内存，失败返回 NULL
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">((</span><span class="n">node</span> <span class="o">=</span> <span class="n">zmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>

    <span class="c1">// 将 listNode 插入到 list 的元素中
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 如果之前 list 没有元素，那么 list 的 head 和 tail 均指向当前的 listNode
</span><span class="c1"></span>        <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 链表的头插入
</span><span class="c1"></span>        <span class="n">node</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
        <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
        <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 更新 len
</span><span class="c1"></span>    <span class="n">list</span><span class="o">-&gt;</span><span class="n">len</span><span class="o">++</span><span class="p">;</span>

    <span class="c1">// 返回的是传进来的 list ，失败返回的是 NULL
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">list</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 尾插入，过程和头插入类似
</span><span class="c1"></span><span class="n">list</span> <span class="o">*</span><span class="nf">listAddNodeTail</span><span class="p">(</span><span class="n">list</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">listNode</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">node</span> <span class="o">=</span> <span class="n">zmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">;</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">list</span><span class="o">-&gt;</span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
        <span class="n">list</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">list</span><span class="o">-&gt;</span><span class="n">len</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">list</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>关于 <code>linsert</code> ，其用法如下：</p>
<blockquote>
<p><strong><code>LINSERT key BEFORE|AFTER pivot value</code></strong></p>
<p>将值<code>value</code>插入到列表<code>key</code>当中，位于值<code>pivot</code>之前或之后。</p>
<p>当<code>pivot</code>不存在于列表<code>key</code>时，不执行任何操作。</p>
<p>当<code>key</code>不存在时，<code>key</code>被视为空列表，不执行任何操作。</p>
<p>如果<code>key</code>不是列表类型，返回一个错误。</p>
</blockquote>
<p>在 <code>Redis</code> 底层，对应的方法为 <code>listInsertNode</code>，当然，为了找到 <code>old_node</code>，前面还需要遍历 <code>list</code>，这个操作的时间复杂度是 <code>O(n)</code>，我们这里只关注如何插入元素：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 在 list 的 old_node 的前或后(after&lt;0,在前面增加；after&gt;0，在后面增加)新增值为 value 的新listNode
</span><span class="c1"></span><span class="n">list</span> <span class="o">*</span><span class="nf">listInsertNode</span><span class="p">(</span><span class="n">list</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="n">listNode</span> <span class="o">*</span><span class="n">old_node</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">after</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">listNode</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

    <span class="c1">// 为新增的 listNode 申请内存，失败返回 NULL
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">((</span><span class="n">node</span> <span class="o">=</span> <span class="n">zmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">node</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">after</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// after&gt;0，在后面插入
</span><span class="c1"></span>        <span class="n">node</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">old_node</span><span class="p">;</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">old_node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">==</span> <span class="n">old_node</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">list</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// after&lt;0，在前面插入
</span><span class="c1"></span>        <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">old_node</span><span class="p">;</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">old_node</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">==</span> <span class="n">old_node</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 更新 len
</span><span class="c1"></span>    <span class="n">list</span><span class="o">-&gt;</span><span class="n">len</span><span class="o">++</span><span class="p">;</span>
    <span class="c1">// 成功 返回传进来的 list
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">list</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>删除元素</strong></li>
</ul>
<p>删除元素的情况有以下几种：清空整个 <code>list</code> ，删除某个 <code>listNode</code>。</p>
<p>我们先看清空整个 <code>list</code> ，它只是释放掉了这个 <code>list</code> 上连的所有的 <code>listNode</code> ，而 <code>list</code> 对象并没有被销毁：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* Remove all the elements from the list without destroying the list itself. */</span>
<span class="kt">void</span> <span class="nf">listEmpty</span><span class="p">(</span><span class="n">list</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">;</span>
    <span class="n">listNode</span> <span class="o">*</span><span class="n">current</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

    <span class="n">current</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">;</span>
    <span class="n">len</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
    <span class="c1">// 遍历整个链表，逐个释放空间，直到为空
</span><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">len</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">next</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">)</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
        <span class="n">zfree</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">list</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>而下面这个 <code>listRelease</code> 方法，会释放所有：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* Free the whole list.
</span><span class="cm"> *
</span><span class="cm"> * This function can&#39;t fail. */</span>
<span class="kt">void</span> <span class="nf">listRelease</span><span class="p">(</span><span class="n">list</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">listEmpty</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>    <span class="c1">// 先清空所有的 listNode
</span><span class="c1"></span>    <span class="n">zfree</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>		<span class="c1">// 再释放 list
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>然后看删除某个具体的 <code>listNode</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">listDelNode</span><span class="p">(</span><span class="n">list</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="n">listNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 是否是 list 中的第一个元素
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">)</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="c1">// 是否是 list 中的最后一个元素
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">list</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
    <span class="c1">// 释放当前节点的值
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">)</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
    <span class="c1">// 释放内存
</span><span class="c1"></span>    <span class="n">zfree</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="c1">// 更新 len
</span><span class="c1"></span>    <span class="n">list</span><span class="o">-&gt;</span><span class="n">len</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="23-总结">2.3 总结</h4>
<ul>
<li>
<p><code>Redis</code> 基于双端链表，可以提供各种功能：列表键、发布订阅功能、监视器等；</p>
</li>
<li>
<p>因为链表表头节点的前置节点和表尾节点的后置节点都指向 <code>NULL</code> ， 所以 <code>Redis</code> 的链表实现是无环链表；</p>
</li>
<li>
<p>仔细看过源代码后会发现，这是一个典型的双端链表，其底层实现与我在《数据结构》中遇到的如出一辙，这也从侧面说明了熟悉基本的数据结构的重要性。</p>
</li>
</ul>
<h3 id="3-字典">3. 字典</h3>
<p>字典，由一个个键值对构成，首先想一下，一个字典应该提供什么样的功能？键值对用来存储数据，之后还要能插入数据、修改数据、删除数据、遍历(读取)数据，字典最大的特点就是上面这些所有的操作都可以在 <code>O(1)</code> 的时间复杂度里完成。</p>
<p>比如在 <code>redis-cli</code> 中，我输入如下命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">redis&gt; <span class="nb">set</span> name Jemmy
</code></pre></td></tr></table>
</div>
</div><p>这条命令在 <code>redis</code> 的内存中生成了一个键值对(<code>key-value</code>)，其中 <code>key</code> 是 <code>name</code>，<code>value</code> 是 <code>Jemmy</code>的字符串对象，</p>
<p><code>Redis</code> 的字典采用 <strong>哈希表</strong> 来实现。一个哈希表，你可以简单把它想成一个数组，数组中的每个元素称为一个桶，这也就对应上我们经常所说，一个哈希表由多个桶组成，每个桶中保存了键值对的数据(<strong>哈希桶中保存的值其实并不是值本身，而是一个指向实际值的指针</strong>)。</p>
<p>提到哈希，首先要关注的是哈希算法以及解决哈希冲突的方式。哈希算法的具体实现我们暂时不关心，只需要知道 <code>Redis</code> 使用的是 <a href="https://github.com/aappleby/smhasher">MurmurHash2</a>，“<strong>这个算法的优点在于：即使输入的键是有规律的，算法仍能够给出一个很好的随机分布性，计算速度也很快</strong>”；对于解决哈希冲突的方法，最常见的是 <strong>开放地址法</strong> 和 <strong>拉链法</strong>。二者实现原理在 <strong><a href="https://jemmyh.github.io/2020/09/18/golang-map-xiang-jie/">Golang-map 详解</a></strong> 中已经说过，这里不再细讲，目前只需要知道，<strong><code>Redis</code> 采用拉链法解决哈希冲突</strong>。</p>
<p>在 <code>Redis</code> 中，有以下几个概念：哈希表、哈希表结点和字典，他们的关系大致可以描述为：字典是一个全局的字典，一个字典中包含两个哈希表，一个正在使用，另一个用作扩容用；哈希表中包含多个哈希表结点。接下来我们详细看下每个结构的具体实现：</p>
<blockquote>
<p>源码文件：<a href="https://github.com/redis/redis/blob/unstable/src/dict.h">dict.h</a></p>
</blockquote>
<h4 id="31-数据结构">3.1 数据结构</h4>
<ul>
<li><strong>哈希表结点</strong></li>
</ul>
<p>哈希表节点使用 <code>dictEntry</code> 结构表示， 每个 <code>dictEntry</code> 结构都保存着一个键值对：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">dictEntry</span> <span class="p">{</span>
    <span class="c1">// key
</span><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>

    <span class="c1">// value，可以是指针 uint64_t int64_t double中的某一个
</span><span class="c1"></span>    <span class="k">union</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">;</span>
        <span class="n">uint64_t</span> <span class="n">u64</span><span class="p">;</span>
        <span class="n">int64_t</span> <span class="n">s64</span><span class="p">;</span>
        <span class="kt">double</span> <span class="n">d</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">v</span><span class="p">;</span>

    <span class="c1">// 指向另一个哈希表结点的指针，连接哈希值相同的键值对，用来解决哈希冲突
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">dictEntry</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span> <span class="n">dictEntry</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>哈希表</strong></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">dictht</span> <span class="p">{</span>
    <span class="n">dictEntry</span> <span class="o">**</span><span class="n">table</span><span class="p">;</span>          <span class="c1">// dictEntry数组，dictEntry代表一个键值对
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">;</span>         <span class="c1">// 哈希表大小(容量)
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sizemask</span><span class="p">;</span>     <span class="c1">// 值总是等于 size - 1 ， 这个属性和哈希值一起决定一个键应该被放到 table 数组的哪个索引上面。
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">used</span><span class="p">;</span>         <span class="c1">// 哈希表已有结点的数量
</span><span class="c1"></span><span class="p">}</span> <span class="n">dictht</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>下图可以表示 <strong>哈希表 <code>dictht</code></strong> 和 <strong>哈希表结点 <code>dictEntry</code></strong> 之间的关系：</p>
<p><img src="https://pic.downk.cc/item/5f7723fd160a154a67697c61.png" alt="有一个键值对的哈希表"></p>
<ul>
<li><strong>字典</strong></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">dict</span> <span class="p">{</span>
    <span class="n">dictType</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span>  <span class="c1">// 类型对应的特定函数
</span><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">;</span>  <span class="c1">// 私有数据
</span><span class="c1"></span>    <span class="n">dictht</span> <span class="n">ht</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>    <span class="c1">// 两个哈希表，一个正常使用，另一个用于扩容
</span><span class="c1"></span>    <span class="kt">long</span> <span class="n">rehashidx</span><span class="p">;</span>  <span class="c1">// rehash 索引值，扩容时使用，正常时为-1
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iterators</span><span class="p">;</span> <span class="c1">// 正在运行的迭代器的数量
</span><span class="c1"></span><span class="p">}</span> <span class="n">dict</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>这里的 <code>type</code> 是一个指向 <code>dictType</code> 结构体的指针，而每一个 <code>dictType</code> 结构体保存了 <strong>一组用于操作特定类型键值对的函数</strong>，不同的类型有不同的操作函数，<code>privdata</code> 保存了需要传递给特定类型函数的可选参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">dictType</span> <span class="p">{</span>
    <span class="c1">// 计算哈希值的函数
</span><span class="c1"></span>    <span class="n">uint64_t</span> <span class="p">(</span><span class="o">*</span><span class="n">hashFunction</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
    <span class="c1">// 复制键的函数
</span><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">keyDup</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
    <span class="c1">// 复制值的函数
</span><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">valDup</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span>
    <span class="c1">// 对比键是否相同的函数
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">keyCompare</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key2</span><span class="p">);</span>
    <span class="c1">// 销毁键的函数
</span><span class="c1"></span>    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">keyDestructor</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
    <span class="c1">// 销毁值的函数
</span><span class="c1"></span>    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">valDestructor</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">privdata</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span>
<span class="p">}</span> <span class="n">dictType</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p><code>ht</code> 属性是一个包含两个项的数组， 数组中的每个项都是一个 <code>dictht</code> 哈希表， 一般情况下， 字典只使用 <code>ht[0]</code> 哈希表， <code>ht[1]</code> 哈希表只会在对 <code>ht[0]</code> 哈希表进行 rehash 时使用。</p>
<p>除了 <code>ht[1]</code> 之外， 另一个和 rehash 有关的属性就是 <code>rehashidx</code> ： 它记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 <code>-1</code> 。</p>
<p>下图展示了一个普通状态(没有进行 <code>rehash</code> )的字典：</p>
<p><img src="https://pic.downk.cc/item/5f772abc160a154a676b8909.png" alt="未扩容的字典示例"></p>
<h4 id="32-哈希冲突的解决方式">3.2 哈希冲突的解决方式</h4>
<p>当两个以上的键经过哈希函数计算之后，落在了哈希表数组的同一个索引上面，我们就称这些键发生了 <strong>哈希冲突(hash collision)</strong>。</p>
<p>Redis 的哈希表使用 <strong>链接法</strong>来解决键冲突： 每个哈希表节点(<code>dictEntry</code>)都有一个 <code>next</code> 指针， 多个哈希表节点可以用 <code>next</code> 指针构成一个单向链表， 被分配到同一个索引上的多个节点可以用这个单向链表连接起来， 这就解决了键冲突的问题。写入时，因为没有直接指向链的最后一个元素的指针，因此为了更少的时间复杂度， <code>Redis</code> 采用的是在链表头部插入；读取时，先定位到链头，之后逐个比较值是否与所求相同，直到遍历完整个链。</p>
<p>比如上图中，在 <code>dictht.table</code> 的 3 号桶中已经存在一个键值对 <code>k1-v1</code>，此时又新加入一个键值对 <code>k2-v2</code>，经过哈希计算后正好也落在 3 号桶中，经过插入后结果如下：</p>
<p><img src="https://pic.downk.cc/item/5f773530160a154a676eef06.png" alt="哈希冲突示例"></p>
<h4 id="34-rehash-细节">3.4 rehash 细节</h4>
<p>当哈希表的键值对数量太多或者太少时，需要根据实际情况对哈希表的大小进行扩大或者缩小，这个过程通过 <code>rehash(重新散列)</code> 来完成。 而判断是否进行 <code>rehash</code> ，是在向哈希表插入一个键值对的时候，接下来我们通过分析源代码的方式，详细了解 <code>rehash</code> 的细节。</p>
<p>首先，添加一个新键值对，用到的是 <code>dictAdd</code> 方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* Add an element to the target hash table */</span>
<span class="kt">int</span> <span class="nf">dictAdd</span><span class="p">(</span><span class="n">dict</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">dictEntry</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">dictAddRaw</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>  <span class="c1">// 将键值对封装成dictEntry
</span><span class="c1"></span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">)</span> <span class="k">return</span> <span class="n">DICT_ERR</span><span class="p">;</span>                <span class="c1">// 如果创建dictEntry，返回失败
</span><span class="c1"></span>    <span class="n">dictSetVal</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>                  <span class="c1">// 键不存在，则设置dictEntry结点的值
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">DICT_OK</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们接着看 <code>dictAddRaw</code>，这一步主要将键值对封装成一个 <code>dictEntry</code> 并返回 ：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 将 key 插入哈希表中
</span><span class="c1"></span><span class="n">dictEntry</span> <span class="o">*</span><span class="nf">dictAddRaw</span><span class="p">(</span><span class="n">dict</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="n">dictEntry</span> <span class="o">**</span><span class="n">existing</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">long</span> <span class="n">index</span><span class="p">;</span>
    <span class="n">dictEntry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
    <span class="n">dictht</span> <span class="o">*</span><span class="n">ht</span><span class="p">;</span>

    <span class="c1">// 如果哈希表正在rehash，则向前 rehash一步(渐进式rehash的体现)
</span><span class="c1"></span>    <span class="c1">// 是否正在进行 rehash，是通过 dict.rehashidx == -1 来判断的
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">dictIsRehashing</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="n">_dictRehashStep</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>

    <span class="c1">// 调用_dictKeyIndex() 检查键是否存在，如果存在则返回NULL
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">((</span><span class="n">index</span> <span class="o">=</span> <span class="n">_dictKeyIndex</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">dictHashKey</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">key</span><span class="p">),</span> <span class="n">existing</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="c1">// 获取当前正在使用的ht，如果正在 rehash，使用 ht[1]，否则使用 ht[0]
</span><span class="c1"></span>    <span class="n">ht</span> <span class="o">=</span> <span class="n">dictIsRehashing</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="c1">// 为新增的节点分配内存
</span><span class="c1"></span>    <span class="n">entry</span> <span class="o">=</span> <span class="n">zmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">));</span>
    <span class="c1">// 将结点插入链表头部
</span><span class="c1"></span>    <span class="n">entry</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">ht</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="n">ht</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>
    <span class="c1">// 更新结点数量
</span><span class="c1"></span>    <span class="n">ht</span><span class="o">-&gt;</span><span class="n">used</span><span class="o">++</span><span class="p">;</span>

    <span class="c1">// 设置新节点的键，使用的是 type 属性中的 keyDup 函数
</span><span class="c1"></span>    <span class="n">dictSetKey</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">entry</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们再看 <code>_dictKeyIndex</code> 这个方法，作用是计算某个 <code>key</code> 应该存储在哪个空的 <code>bucket</code> ，即需要返回这个 <code>key</code> 应该存储在 <code>dictEntry</code> 数组的 <code>index</code>，如果已经存在，返回 -1。需要注意的是，当哈希表正在 <code>rehash</code> 时，返回的 <code>index</code> 应该是要搬迁的 <code>ht</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 传进来的 existing 是 NULL, hash是通过 type 中的哈希函数计算的
</span><span class="c1"></span><span class="k">static</span> <span class="kt">long</span> <span class="nf">_dictKeyIndex</span><span class="p">(</span><span class="n">dict</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="n">uint64_t</span> <span class="n">hash</span><span class="p">,</span> <span class="n">dictEntry</span> <span class="o">**</span><span class="n">existing</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">idx</span><span class="p">,</span> <span class="n">table</span><span class="p">;</span>
    <span class="n">dictEntry</span> <span class="o">*</span><span class="n">he</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">existing</span><span class="p">)</span>
        <span class="o">*</span><span class="n">existing</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="c1">// 检查是否需要扩展哈希表，如果需要则进行扩展
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">_dictExpandIfNeeded</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">==</span> <span class="n">DICT_ERR</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">table</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">table</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">table</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">hash</span> <span class="o">&amp;</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="n">table</span><span class="p">].</span><span class="n">sizemask</span><span class="p">;</span>
        <span class="cm">/* Search if this slot does not already contain the given key */</span>
        <span class="n">he</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="n">table</span><span class="p">].</span><span class="n">table</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">he</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="n">he</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">||</span> <span class="n">dictCompareKeys</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">he</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">existing</span><span class="p">)</span>
                    <span class="o">*</span><span class="n">existing</span> <span class="o">=</span> <span class="n">he</span><span class="p">;</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">he</span> <span class="o">=</span> <span class="n">he</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dictIsRehashing</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">idx</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>最后，我们关注 <strong>检查是否需要 <code>rehash</code>，需要则启动</strong> 的 <code>_dictExpandIfNeeded</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">int</span> <span class="nf">_dictExpandIfNeeded</span><span class="p">(</span><span class="n">dict</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 如果正在 rehash，直接返回
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">dictIsRehashing</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">DICT_OK</span><span class="p">;</span>

    <span class="cm">/* If the hash table is empty expand it to the initial size. */</span>
    <span class="c1">// 如果哈希表中是空的，则将其收缩为初始化大小 DICT_HT_INITIAL_SIZE=4
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dictExpand</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">DICT_HT_INITIAL_SIZE</span><span class="p">);</span>

    <span class="c1">// 在 (ht[0].used/ht[0].size)&gt;=1前提下，如果 系统允许扩容 或者 ht[0].used/t[0].size&gt;5 时，容量扩展为原来的2倍
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">used</span> <span class="o">&gt;=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">&amp;&amp;</span>
        <span class="p">(</span><span class="n">dict_can_resize</span> <span class="o">||</span>
         <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">used</span> <span class="o">/</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">dict_force_resize_ratio</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">dictExpand</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">used</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>  <span class="c1">// 扩容至原来容量的2倍
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="n">DICT_OK</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>仔细看看 <code>dictExpand</code> 是如何扩展哈希表容量的，这个函数中，判断是否需要扩容，如果需要，则新申请一个 <code>dictht</code> ，赋值给 <code>ht[0]</code>，然后将字典的状态设置为 <strong>正在 <code>rehash</code>(rehashidx &gt; -1)</strong>，需要注意的是，这个方法中并没有实际进行键值对的搬迁：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 扩容 或者 新建一个 dictht
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">dictExpand</span><span class="p">(</span><span class="n">dict</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* the size is invalid if it is smaller than the number of
</span><span class="cm">     * elements already inside the hash table */</span>
    <span class="c1">// 如果正在 reahsh 或者 传进来的size不合适(size比当前已有的容量小，正常情况下这是不可能的)，直接返回错误
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">dictIsRehashing</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">||</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">used</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">DICT_ERR</span><span class="p">;</span>

    <span class="n">dictht</span> <span class="n">n</span><span class="p">;</span> <span class="c1">// 新哈希表
</span><span class="c1"></span>    <span class="c1">// 计算 扩展或缩放新哈希表容量 的大小，必须是2的倍数
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">realsize</span> <span class="o">=</span> <span class="n">_dictNextPower</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

    <span class="c1">// 如果计算扩容后的新哈希表的容量，和原来的相同，就没必要扩容，直接返回错误
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">realsize</span> <span class="o">==</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">DICT_ERR</span><span class="p">;</span>

    <span class="c1">// 为新哈希表申请内存，并将所有的指针初始化为NULL
</span><span class="c1"></span>    <span class="n">n</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">realsize</span><span class="p">;</span>
    <span class="n">n</span><span class="p">.</span><span class="n">sizemask</span> <span class="o">=</span> <span class="n">realsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">n</span><span class="p">.</span><span class="n">table</span> <span class="o">=</span> <span class="n">zcalloc</span><span class="p">(</span><span class="n">realsize</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dictEntry</span> <span class="o">*</span><span class="p">));</span>
    <span class="n">n</span><span class="p">.</span><span class="n">used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* Is this the first initialization? If so it&#39;s not really a rehashing
</span><span class="cm">     * we just set the first hash table so that it can accept keys. */</span>
    <span class="c1">// 如果原来的哈希表是空的，意味着这是在新建一个哈希表，将新申请的 dictht 赋值给 ht[0]，直接返回创建成功
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">table</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">DICT_OK</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 如果不是新建哈希表，那就是需要实打实的扩容，此时将刚才新申请的 哈希表 赋值给 ht[1]，并将当前字典状态设置为&#34;正在rehash&#34;(rehashidx &gt; -1)
</span><span class="c1"></span>    <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">DICT_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 哈希表的容量必须是 2的倍数
</span><span class="c1"></span><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">_dictNextPower</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="n">DICT_HT_INITIAL_SIZE</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">LONG_MAX</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">LONG_MAX</span> <span class="o">+</span> <span class="mi">1LU</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">i</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>什么时候进行 <strong>桶</strong> 的搬迁呢？这里涉及到一个名词：<strong>渐进式扩容</strong>。我们知道，扩展或收缩哈希表需要将 <code>ht[0]</code> 里面的所有键值对 <code>rehash</code> 到 <code>ht[1]</code> 里面，如果哈希表中的键值对数量少，那么一次性转移过去不是问题；但是键值对的数量很大，几百万几千万甚至上亿，那么一次性搬完的计算量+单线程很有可能使 <code>redis</code> 服务停止一段时间。因此，为了避免 <code>rehash</code> 对服务造成影响，服务不是一次性 <code>rehash</code> 完成的，而是 <strong>分多次</strong>、<strong>渐进式</strong>地将 <code>ht[0]</code> 中的键值对搬迁到 <code>ht[1]</code> 中。</p>
<p>源码中真正执行搬迁的函数是 <code>_dictRehashStep</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// _dictRehashStep 让 rehash 的动作向前走一步(搬迁一个桶)，前提是当前字典没有被遍历，即iterators==0，iterators表示当前正在遍历此字典的迭代器数目
</span><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">_dictRehashStep</span><span class="p">(</span><span class="n">dict</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">iterators</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">dictRehash</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>再看 <code>dictRehash</code> ：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// dictRehash 向前 rehash n步。如果还没有搬迁完，返回 1，搬迁完成返回0
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">dictRehash</span><span class="p">(</span><span class="n">dict</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 当dictRehash时，rehashidx指向当前正在被搬迁的bucket，如果这个bucket中一个可搬迁的dictEntry都没有，说明就没有可搬迁的数据。
</span><span class="c1"></span>    <span class="c1">// 这个时候会继续向后遍历 ht[0].table 数组，直到找到下一个存有数据的bucket位置，如果一直找不到，则最多向前走 empty_visits 步，本次搬迁任务结束。
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">empty_visits</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span>
    <span class="c1">// 整个dict的 rehash 完成了，返回0
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dictIsRehashing</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// 外层大循环，确保本次最多向前走n步 以及 ht[0].table中还有值
</span><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="o">--</span> <span class="o">&amp;&amp;</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">used</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">dictEntry</span> <span class="o">*</span><span class="n">de</span><span class="p">,</span> <span class="o">*</span><span class="n">nextde</span><span class="p">;</span>

        <span class="c1">// 确保 rehashidx 不会超过 ht[0].table 的长度，因为 rehashidx 指向当前正在被搬迁的bucket，其实就是 ht[0].table 数组的下标，这里保证数组下标访问不会越界
</span><span class="c1"></span>        <span class="n">assert</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span><span class="p">);</span>

        <span class="c1">// 当前的bucket搬迁完了，继续寻找下一个bucket，知道全部为空 或者 向前走的步数超过了限定值
</span><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">table</span><span class="p">[</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span><span class="o">++</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">empty_visits</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 终于找到了可搬迁的某个bucket中的 dictEntry
</span><span class="c1"></span>        <span class="n">de</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">table</span><span class="p">[</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span><span class="p">];</span>

        <span class="c1">// 将这个 bucket 中的所有 dictEntry 包括链表上的，前部搬迁到新的 ht[1] 中
</span><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="n">de</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">uint64_t</span> <span class="n">h</span><span class="p">;</span>

            <span class="n">nextde</span> <span class="o">=</span> <span class="n">de</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="c1">// 获取当前键值对在新的哈希表中的桶的序号，这里进行取模的是 ht[1]的sizemask，所以 h 很大概率会与在 ht[0] 中的不一样
</span><span class="c1"></span>            <span class="n">h</span> <span class="o">=</span> <span class="n">dictHashKey</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">de</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">sizemask</span><span class="p">;</span>
            <span class="c1">// 更新 新桶与旧桶 中的属性
</span><span class="c1"></span>            <span class="n">de</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">table</span><span class="p">[</span><span class="n">h</span><span class="p">];</span>
            <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">table</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">de</span><span class="p">;</span>
            <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">used</span><span class="o">--</span><span class="p">;</span>
            <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">used</span><span class="o">++</span><span class="p">;</span>
            <span class="n">de</span> <span class="o">=</span> <span class="n">nextde</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 搬迁完成，将原来的ht[0]中的bucket置空
</span><span class="c1"></span>        <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">table</span><span class="p">[</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="c1">// rehashidx 自增，表示又搬完了一个桶
</span><span class="c1"></span>        <span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 检查是否搬完了整张表
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">used</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 全部完成搬迁，则释放掉ht[0]的内存，将ht[1]的内容放到ht[0]中，重置ht[1]，并标志rehash完成(rehashidx=-1)
</span><span class="c1"></span>        <span class="n">zfree</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">table</span><span class="p">);</span>
        <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">_dictReset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="n">d</span><span class="o">-&gt;</span><span class="n">rehashidx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 否则后面的动作还要继续搬迁
</span><span class="c1"></span>    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>那什么时候会进行渐进式<code>rehash</code>呢？在源码中搜索 <code>_dictRehashStep</code>：有以下几处出现了：</p>
<ol>
<li><code>dictAddRaw</code> ：向字典增加一个键值对时；</li>
<li><code>dictGenericDelete</code>：查找并移除某个键值对时；</li>
<li><code>dictFind</code> ：根据 <code>key</code> 查找对应的 <code>dictEntry</code> 时；</li>
<li><code>dictGetRandomKey</code>：返回一个随机的 <code>dictEntry</code> 时；</li>
<li><code>dictGetSomeKeys</code>：随机返回指定 <code>count</code> 个 <code>dictEntry</code> 时，会进行 <code>count</code> 次 <code>_dictRehashStep</code></li>
</ol>
<p>总结一下：</p>
<ol>
<li>为 <code>ht[1]</code> 分配空间， 让字典同时持有 <code>ht[0]</code> 和 <code>ht[1]</code> 两个哈希表。</li>
<li>在字典中维持一个索引计数器变量 <code>rehashidx</code> ， 并将它的值设置为 <code>0</code> ， 表示 rehash 工作正式开始。</li>
<li>在 <code>rehash</code> 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 <code>ht[0]</code> 哈希表在 <code>rehashidx</code> 索引上的所有键值对 rehash 到 <code>ht[1]</code> ， 当 <code>rehash</code> 工作完成之后， 程序将 <code>rehashidx</code> 属性的值增一。</li>
<li>随着字典操作的不断执行， 最终在某个时间点上， <code>ht[0]</code> 的所有键值对都会被 rehash 至 <code>ht[1]</code> ， 这时程序将 <code>rehashidx</code> 属性的值设为 <code>-1</code> ， 表示 <code>rehash</code> 操作已完成。</li>
</ol>
<p><strong>渐进式 <code>rehash</code> 的好处在于它采取分而治之的方式， 将 <code>rehash</code> 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 <code>rehash</code> 而带来的庞大计算量</strong>。</p>
<h4 id="35-api">3.5 API</h4>
<ul>
<li><strong>添加键值对 <code>dictAdd</code></strong></li>
</ul>
<p>在上面讲 <code>rehash</code> 时，使用的例子，就是 添加键值对，这里不再赘述。</p>
<ul>
<li><strong>删除键值对 <code>dictDelete</code></strong></li>
</ul>
<p>其底层调用的是 <code>dictGenericDelete</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 找到key对应的键值对，并移除它。此处dictDelete 调用时传入 nofree=0
</span><span class="c1"></span><span class="k">static</span> <span class="n">dictEntry</span> <span class="o">*</span><span class="nf">dictGenericDelete</span><span class="p">(</span><span class="n">dict</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nofree</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">uint64_t</span> <span class="n">h</span><span class="p">,</span> <span class="n">idx</span><span class="p">;</span>
    <span class="n">dictEntry</span> <span class="o">*</span><span class="n">he</span><span class="p">,</span> <span class="o">*</span><span class="n">prevHe</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">table</span><span class="p">;</span>

    <span class="c1">// 如果字典中键值对数量为0，返回 未找到
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">used</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">used</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="c1">// 如果当前处于 rehash 阶段，则往前进行一步 rehash
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">dictIsRehashing</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
        <span class="n">_dictRehashStep</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>

    <span class="n">h</span> <span class="o">=</span> <span class="n">dictHashKey</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">table</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">table</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">table</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 获取桶的索引
</span><span class="c1"></span>        <span class="n">idx</span> <span class="o">=</span> <span class="n">h</span> <span class="o">&amp;</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="n">table</span><span class="p">].</span><span class="n">sizemask</span><span class="p">;</span>
        <span class="c1">// 获取桶中的第一个 dictEntry
</span><span class="c1"></span>        <span class="n">he</span> <span class="o">=</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="n">table</span><span class="p">].</span><span class="n">table</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
        <span class="n">prevHe</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="c1">// 遍历链表，找到之后将其从链表中删除
</span><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="n">he</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="n">he</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">||</span> <span class="n">dictCompareKeys</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">he</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">prevHe</span><span class="p">)</span>
                    <span class="n">prevHe</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">he</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                <span class="k">else</span>
                    <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="n">table</span><span class="p">].</span><span class="n">table</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">he</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nofree</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">dictFreeKey</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">he</span><span class="p">);</span>
                    <span class="n">dictFreeVal</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">he</span><span class="p">);</span>
                    <span class="n">zfree</span><span class="p">(</span><span class="n">he</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="n">d</span><span class="o">-&gt;</span><span class="n">ht</span><span class="p">[</span><span class="n">table</span><span class="p">].</span><span class="n">used</span><span class="o">--</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">he</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">prevHe</span> <span class="o">=</span> <span class="n">he</span><span class="p">;</span>
            <span class="n">he</span> <span class="o">=</span> <span class="n">he</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 如果没有再 rehash，就没必要再去 ht[1] 中寻找了
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dictIsRehashing</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// 没找到，返回 NULL
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>查找键值对 <code>dictFind</code></strong></li>
</ul>
<p>过程跟 <code>dictGenericDelete</code> 一模一样， <code>dictGenericDelete</code> 还多了一个删除操作。</p>
<h3 id="4-跳表">4. 跳表</h3>
<p>会有专门的一篇文章来讲。看这里：<a href="https://jemmyh.github.io/2020/10/05/tiao-biao/">跳表原理以及 Golang 实现</a></p>
<h3 id="5-整数集合">5. 整数集合</h3>
<p>当一个集合中只包含整数，并且元素的个数不是很多的话，redis 会用整数集合作为底层存储，它的一个优点就是可以节省很多内存，虽然字典结构的效率很高，但是它的实现结构相对复杂并且会分配较多的内存空间。当然，当整数集合中的 <strong>元素太多(redis.conf 中 <code>set-max-intset-entries=512</code>)</strong> 或者 <strong>添加别的类型的元素</strong>是，整个整数集合会被转化成 <strong>字典</strong>。</p>
<blockquote>
<p>源码文件：<a href="https://github.com/redis/redis/blob/unstable/src/intset.h">intset.h</a></p>
</blockquote>
<h4 id="51-数据结构">5.1 数据结构</h4>
<p><strong>整数集合（<code>intset</code>）</strong> 是 <code>Redis</code> 用于保存整数值的集合抽象数据结构， 它可以保存类型为 <code>int16_t</code> 、 <code>int32_t</code> 或者 <code>int64_t</code> 的整数值， 并且保证集合中不会出现重复元素。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">intset</span> <span class="p">{</span>
    <span class="c1">// 编码方式
</span><span class="c1"></span>    <span class="n">uint32_t</span> <span class="n">encoding</span><span class="p">;</span>

    <span class="c1">// 集合中包含的元素数量
</span><span class="c1"></span>    <span class="n">uint32_t</span> <span class="n">length</span><span class="p">;</span>

    <span class="c1">// 保存元素的数组
</span><span class="c1"></span>    <span class="n">int8_t</span> <span class="n">contents</span><span class="p">[];</span>
<span class="p">}</span> <span class="n">intset</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p><code>contents</code> 数组中的元素按照从小到大的顺序排列，并且保证没有重复值；<code>length</code> 表示整数集合中包含的元素数量，即 <code>contents</code> 数组的长度。虽然 <code>contents</code> 数组的类型是 <code>int8_t</code>，但实际上并不保存 <code>int8_t</code> 类型的值，而是会根据实际 <code>encoding</code> 的值做出判断，比如 <code>encoding = INTSET_ENC_INT16</code>，那么数组的底层类型均为 <code>int16_t</code> ，整个数组中的元素类型都是 <code>int16_t</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cm">/* Note that these encodings are ordered, so:
</span><span class="cm"> * INTSET_ENC_INT16 &lt; INTSET_ENC_INT32 &lt; INTSET_ENC_INT64. */</span>
<span class="cp">#define INTSET_ENC_INT16 (sizeof(int16_t))  </span><span class="c1">// int16 16位
</span><span class="c1"></span><span class="cp">#define INTSET_ENC_INT32 (sizeof(int32_t))  </span><span class="c1">// int32 32位
</span><span class="c1"></span><span class="cp">#define INTSET_ENC_INT64 (sizeof(int64_t))  </span><span class="c1">// int64 64位
</span><span class="c1"></span>
<span class="c1">// 返回 v 对应的 encoding 值
</span><span class="c1"></span><span class="k">static</span> <span class="n">uint8_t</span> <span class="nf">_intsetValueEncoding</span><span class="p">(</span><span class="n">int64_t</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">&lt;</span> <span class="n">INT32_MIN</span> <span class="o">||</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="n">INT32_MAX</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">INTSET_ENC_INT64</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">&lt;</span> <span class="n">INT16_MIN</span> <span class="o">||</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="n">INT16_MAX</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">INTSET_ENC_INT32</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">INTSET_ENC_INT16</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>下面是一个使用 <code>INTSET_ENC_INT16</code> 编码的、长度为 6 的整数集合：</p>
<p><img src="https://pic.downk.cc/item/5f788aa8160a154a6719f5d2.png" alt="整数集合举例"></p>
<h4 id="52-api">5.2 API</h4>
<ul>
<li><strong>初始化 <code>intset</code></strong></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 创建一个空的 intset
</span><span class="c1"></span><span class="n">intset</span> <span class="o">*</span><span class="nf">intsetNew</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 为 intset 对象申请空间
</span><span class="c1"></span>    <span class="n">intset</span> <span class="o">*</span><span class="n">is</span> <span class="o">=</span> <span class="n">zmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">intset</span><span class="p">));</span>
    <span class="c1">// 默认使用 INTSET_ENC_INT16 作为存储大小
</span><span class="c1"></span>    <span class="n">is</span><span class="o">-&gt;</span><span class="n">encoding</span> <span class="o">=</span> <span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">INTSET_ENC_INT16</span><span class="p">);</span>
    <span class="c1">// 数组长度为0，因为没有初始化的操作
</span><span class="c1"></span>    <span class="n">is</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">is</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这里有一点需要注意，创建 <code>intset</code> 的时候并没有初始化 <code>contents</code> 数组，应为没必要。在常规情况下，访问数组是根据数组第一个元素地址加上类型大小作为偏移值读取，但是 <code>intset</code> 的数据类型依赖于 <code>encoding</code>，读取的时候通过 <code>memcpy</code> 按照 <code>encoding</code> 的值重新计算偏移量暴力读取的，属于 非常规操作数据，因此，刚开始没必要申请数组的空间，等添加一个元素时，动态扩容该元素的大小的内存即可。</p>
<ul>
<li><strong>添加元素</strong></li>
</ul>
<p>我们先看代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 在 intset 中添加一个整数
</span><span class="c1"></span><span class="n">intset</span> <span class="o">*</span><span class="nf">intsetAdd</span><span class="p">(</span><span class="n">intset</span> <span class="o">*</span><span class="n">is</span><span class="p">,</span> <span class="n">int64_t</span> <span class="n">value</span><span class="p">,</span> <span class="n">uint8_t</span> <span class="o">*</span><span class="n">success</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uint8_t</span> <span class="n">valenc</span> <span class="o">=</span> <span class="n">_intsetValueEncoding</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>  <span class="c1">// 根据要插入的 value 的类型 获取对应的 encoding
</span><span class="c1"></span>    <span class="n">uint32_t</span> <span class="n">pos</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">success</span><span class="p">)</span> <span class="o">*</span><span class="n">success</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// success = NULL
</span><span class="c1"></span>
    <span class="k">if</span> <span class="p">(</span><span class="n">valenc</span> <span class="o">&gt;</span> <span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">encoding</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// 插入元素的 encoding 值大于 intset 当前的，升级
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">intsetUpgradeAndAdd</span><span class="p">(</span><span class="n">is</span><span class="p">,</span><span class="n">value</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 插入元素的 encoding 值小于等于当前 intset 的，则找到这个 value 应该插入的位置，赋值给 pos，已经存在的话直接返回
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">intsetSearch</span><span class="p">(</span><span class="n">is</span><span class="p">,</span><span class="n">value</span><span class="p">,</span><span class="o">&amp;</span><span class="n">pos</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">success</span><span class="p">)</span> <span class="o">*</span><span class="n">success</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">is</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 动态扩容
</span><span class="c1"></span>        <span class="n">is</span> <span class="o">=</span> <span class="n">intsetResize</span><span class="p">(</span><span class="n">is</span><span class="p">,</span><span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="c1">// 将 pos 位置后面的元素整体向后挪一位，给 pos 腾位置
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">))</span> <span class="n">intsetMoveTail</span><span class="p">(</span><span class="n">is</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span><span class="n">pos</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 将 pos 位置设置为 value
</span><span class="c1"></span>    <span class="n">_intsetSet</span><span class="p">(</span><span class="n">is</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span><span class="n">value</span><span class="p">);</span>
    <span class="c1">// 更新 length
</span><span class="c1"></span>    <span class="n">is</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">is</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 动态扩容，即将原来数组的容量 (is.length*encoding) 调整为 ((is.length+1)*encoding)
</span><span class="c1"></span><span class="k">static</span> <span class="n">intset</span> <span class="o">*</span><span class="nf">intsetResize</span><span class="p">(</span><span class="n">intset</span> <span class="o">*</span><span class="n">is</span><span class="p">,</span> <span class="n">uint32_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uint32_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">len</span><span class="o">*</span><span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">encoding</span><span class="p">);</span>
    <span class="n">is</span> <span class="o">=</span> <span class="n">zrealloc</span><span class="p">(</span><span class="n">is</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">intset</span><span class="p">)</span><span class="o">+</span><span class="n">size</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">is</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 暴力迁移pos位置之后的数据，为pos位置挪出位置
</span><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">intsetMoveTail</span><span class="p">(</span><span class="n">intset</span> <span class="o">*</span><span class="n">is</span><span class="p">,</span> <span class="n">uint32_t</span> <span class="n">from</span><span class="p">,</span> <span class="n">uint32_t</span> <span class="n">to</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// from = pos, to = pos+1
</span><span class="c1"></span>
    <span class="c1">// src 表示 pos 相对于数组头部的迁移量
</span><span class="c1"></span>    <span class="c1">// dst 表示 pos下一个元素相对于数组头部的偏移量
</span><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="o">*</span><span class="n">dst</span><span class="p">;</span>
    <span class="c1">// pos位置 距离数组末尾的元素个数，bytes*类型大小 即是pos后面的所有元素的总长度
</span><span class="c1"></span>    <span class="n">uint32_t</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span><span class="o">-</span><span class="n">from</span><span class="p">;</span>
    <span class="c1">// encoding
</span><span class="c1"></span>    <span class="n">uint32_t</span> <span class="n">encoding</span> <span class="o">=</span> <span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">encoding</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">encoding</span> <span class="o">==</span> <span class="n">INTSET_ENC_INT64</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">src</span> <span class="o">=</span> <span class="p">(</span><span class="n">int64_t</span><span class="o">*</span><span class="p">)</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">contents</span><span class="o">+</span><span class="n">from</span><span class="p">;</span>
        <span class="n">dst</span> <span class="o">=</span> <span class="p">(</span><span class="n">int64_t</span><span class="o">*</span><span class="p">)</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">contents</span><span class="o">+</span><span class="n">to</span><span class="p">;</span>
        <span class="n">bytes</span> <span class="o">*=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">int64_t</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">encoding</span> <span class="o">==</span> <span class="n">INTSET_ENC_INT32</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">src</span> <span class="o">=</span> <span class="p">(</span><span class="n">int32_t</span><span class="o">*</span><span class="p">)</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">contents</span><span class="o">+</span><span class="n">from</span><span class="p">;</span>
        <span class="n">dst</span> <span class="o">=</span> <span class="p">(</span><span class="n">int32_t</span><span class="o">*</span><span class="p">)</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">contents</span><span class="o">+</span><span class="n">to</span><span class="p">;</span>
        <span class="n">bytes</span> <span class="o">*=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">int32_t</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">src</span> <span class="o">=</span> <span class="p">(</span><span class="n">int16_t</span><span class="o">*</span><span class="p">)</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">contents</span><span class="o">+</span><span class="n">from</span><span class="p">;</span>
        <span class="n">dst</span> <span class="o">=</span> <span class="p">(</span><span class="n">int16_t</span><span class="o">*</span><span class="p">)</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">contents</span><span class="o">+</span><span class="n">to</span><span class="p">;</span>
        <span class="n">bytes</span> <span class="o">*=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">int16_t</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 从 src 复制 bytes 个字符到 dst
</span><span class="c1"></span>    <span class="n">memmove</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span><span class="n">src</span><span class="p">,</span><span class="n">bytes</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>整个过程可以简单总结为：先判断当前插入值的 <code>encoding</code> 是否超过了 <code>intset</code> 的，如果超过了，进行升级，<strong>升级</strong> 操作我们待会儿再看。没超过的话，需要找到当前元素应该插入的位置 <code>pos</code> ，<strong>查找</strong> 操作我们还是待会儿再看。之后是动态扩容，动态扩容的过程有：先将数组容量增加，之后将 <code>pos</code> 后面的元素整体移一位，最后将 <code>value</code> 值写入 <code>pos</code> 处。特别需要注意的是，<strong>将 <code>pos</code> 后面的元素整体后移一位</strong> 这一步，没有逐个移动元素，而是计算好 <code>src</code> 和 <code>dst</code>，直接调用 <code>memmove</code> 将 <code>src</code> 处的 <code>bytes</code> 个字符复制到 <code>dst</code> 处，这正是利用了 <code>intset</code> 数组非常规读取数组的特点。下面通过一个例子看一下插入的过程：</p>
<p><img src="https://pic.downk.cc/item/5f789ebf160a154a671f936b.png" alt="intset插入元素"></p>
<ul>
<li><strong>升级</strong></li>
</ul>
<p>当插入的元素的类型比集合中现有所有元素的类型都要长时，需要先将数组整个升级之后，才能继续插入元素。<strong>升级</strong> 指的是 将数组类型变成和插入值类型相同的过程。</p>
<p>升级过程大致可分为三个步骤：</p>
<ol>
<li>根据新元素类型，扩展底层数组的大小，并为新元素分配空间；</li>
<li>将底层数组的所有元素都转化成与新元素相同，并将转换后的元素放在合适的位置上，并且在防止的过程中，需要维持底层数组中数组顺序不变；</li>
<li>将新元素添加到新数组中</li>
</ol>
<p>下面我们直接看代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="n">intset</span> <span class="o">*</span><span class="nf">intsetUpgradeAndAdd</span><span class="p">(</span><span class="n">intset</span> <span class="o">*</span><span class="n">is</span><span class="p">,</span> <span class="n">int64_t</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uint8_t</span> <span class="n">curenc</span> <span class="o">=</span> <span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">encoding</span><span class="p">);</span>  <span class="c1">// 当前 encoding
</span><span class="c1"></span>    <span class="n">uint8_t</span> <span class="n">newenc</span> <span class="o">=</span> <span class="n">_intsetValueEncoding</span><span class="p">(</span><span class="n">value</span><span class="p">);</span> <span class="c1">// 插入元素的 encoding
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
    <span class="c1">// 插入到 数组最左边 还是 数组最右边。为什么会是最值？因为要升级，所以插入值肯定超出了现有 encoding 对应类型的最值，要么是负数越界，要么是正数越界
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">prepend</span> <span class="o">=</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// 首先，设置 intset 的 encoding 为插入元素的 encoding(更大的那个)
</span><span class="c1"></span>    <span class="n">is</span><span class="o">-&gt;</span><span class="n">encoding</span> <span class="o">=</span> <span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">newenc</span><span class="p">);</span>
    <span class="c1">// 根据新元素类型 扩展数组大小
</span><span class="c1"></span>    <span class="n">is</span> <span class="o">=</span> <span class="n">intsetResize</span><span class="p">(</span><span class="n">is</span><span class="p">,</span><span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

    <span class="c1">// 从数组最后一个元素开始遍历，将其放入合适的位置。prepend 的作用就是确保我们能给待插入值留下最左边的位置 或 最右边的位置
</span><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">length</span><span class="o">--</span><span class="p">)</span>
        <span class="n">_intsetSet</span><span class="p">(</span><span class="n">is</span><span class="p">,</span><span class="n">length</span><span class="o">+</span><span class="n">prepend</span><span class="p">,</span><span class="n">_intsetGetEncoded</span><span class="p">(</span><span class="n">is</span><span class="p">,</span><span class="n">length</span><span class="p">,</span><span class="n">curenc</span><span class="p">));</span>

    <span class="c1">// 在数组头部或者数组尾部插入 value
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">prepend</span><span class="p">)</span>
        <span class="n">_intsetSet</span><span class="p">(</span><span class="n">is</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">value</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">_intsetSet</span><span class="p">(</span><span class="n">is</span><span class="p">,</span><span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">),</span><span class="n">value</span><span class="p">);</span>
    <span class="c1">// 最后更新 length
</span><span class="c1"></span>    <span class="n">is</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">is</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>通过一个例子说明升级的过程：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjcm49s2sfj30nn0tmk4v.jpg" alt="整数集合升级"></p>
<p>注意：整数集合没有降级操作！一旦对数组进行了升级， 编码就会一直保持升级后的状态。</p>
<ul>
<li><strong>查找</strong></li>
</ul>
<p>在 <code>intset</code> 中查找 <code>value</code> 是否存在，如果存在，返回 1，同时将 <code>pos</code> 值设置为数组的索引值；如果不存在，返回 0，同时将 <code>pos</code> 设置成应该存放的位置的索引值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="n">uint8_t</span> <span class="nf">intsetSearch</span><span class="p">(</span><span class="n">intset</span> <span class="o">*</span><span class="n">is</span><span class="p">,</span> <span class="n">int64_t</span> <span class="n">value</span><span class="p">,</span> <span class="n">uint32_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">max</span> <span class="o">=</span> <span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">int64_t</span> <span class="n">cur</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="c1">// 当 intset 中没有元素时，直接返回
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 大于当前数组中最大值 或 小于最小值，也是直接返回
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">_intsetGet</span><span class="p">(</span><span class="n">is</span><span class="p">,</span><span class="n">max</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">is</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">_intsetGet</span><span class="p">(</span><span class="n">is</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 因为数组有序，所以采用二分法查找位置是一个非常正确的选择
</span><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">max</span> <span class="o">&gt;=</span> <span class="n">min</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">min</span> <span class="o">+</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">max</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">_intsetGet</span><span class="p">(</span><span class="n">is</span><span class="p">,</span><span class="n">mid</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">min</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">max</span> <span class="o">=</span> <span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// value 已经存在
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// value 不存在
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="n">min</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="53-总结">5.3 总结</h4>
<ul>
<li>整数集合的底层实现为数组， 这个数组以有序、无重复的方式保存集合元素， 在有需要时， 程序会根据新添加元素的类型， 改变这个数组的类型。</li>
<li>升级操作为整数集合带来了操作上的灵活性， 并且尽可能地节约了内存。</li>
<li>整数集合只支持升级操作， 不支持降级操作。</li>
<li>整数集合中的元素不能太对，当超过配置值后，会被转化成字典。</li>
</ul>
<h3 id="6-压缩列表">6. 压缩列表</h3>
<p><strong>压缩列表</strong> 是 <code>Redis</code> 自己实现的一个数据存储结构，有点类似数组，通过一片连续的空间存储数据，只不过数组的每个元素大小都相同，压缩列表允许每个元素有自己的大小。其核心思想，就是在一个连续的内存上，模拟出一个链表的结构。</p>
<p>在源代码中有这么一段描述：</p>
<blockquote>
<p>The ziplist is a specially encoded dually linked list that is designed to be very memory efficient. It stores both strings and integer values, where integers are encoded as actual integers instead of a series of characters. It allows push and pop operations on either side of the list in O(1) time. However, because every operation requires a reallocation of the memory used by the ziplist, the actual complexity is related to the amount of memory used by the ziplist.</p>
</blockquote>
<p>大致意思是：<code>ziplist</code> 是一个<strong>经过特殊编码的双向链表</strong>，它的设计目标就是为了<strong>提高存储效率</strong>。<code>ziplist</code> 可以用于存储字符串或整数，其中整数是按真正的二进制表示进行编码的，而不是编码成字符串序列。它能以 <code>O(1)</code> 的时间复杂度在表的两端提供 <code>push</code> 和 <code>pop</code> 操作。但由于每次操作都需要重新分配 <code>ziplist</code> 使用的内存，所以实际的复杂度与 <code>ziplist</code> 使用的内存量有关。</p>
<blockquote>
<p>源码文件：<a href="https://github.com/redis/redis/blob/unstable/src/ziplist.h">ziplist.h</a></p>
</blockquote>
<h4 id="61-数据结构">6.1 数据结构</h4>
<p><code>ziplist</code> 并没有实际的 <code>struct</code> 表示，但在 <code>ziplist.c</code> 中有如下描述：</p>
<blockquote>
<p>The general layout of the ziplist is as follows:</p>
<p><strong>&lt;zlbytes&gt; &lt;zltail&gt; &lt;zllen&gt; &lt;entry&gt; &lt;entry&gt; &hellip; &lt;entry&gt; &lt;zlend&gt;</strong></p>
<ul>
<li><code>zlbytes</code>：本身占用 4 字节，整个压缩列表占用的总字节数(包括他自己)</li>
<li><code>zltail</code>：本身占用 4 字节，起始位置到最后一个结点的偏移量，用来快速定位最后一个元素，在反向输出压缩列表时会有用</li>
<li><code>zllen</code>：本身占用 2 字节，压缩列表包含的元素个数</li>
<li><code>entry</code>：元素内容。用数组存储，内存上紧挨着</li>
<li><code>zlend</code>：本身占用 1 字节，压缩列表结束的标志位，一般为常量 <code>0xFF</code></li>
</ul>
</blockquote>
<p>接下来看 <code>entry</code> 这个结构：</p>
<blockquote>
<p><strong>&lt;prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;</strong></p>
<ul>
<li><code>prevlen</code>：1 字节或者 5 字节，表示前一个 <code>entry</code> 长度，在反向遍历的时候会有用</li>
<li><code>encoding</code>：1、2 或 5 字节，表示当前 <code>entry</code> 的编码方式，表示当前 <code>entry</code> 的类型，<code>integer</code> 或 <code>string</code></li>
<li><code>entry-data</code>：实际所需的字节数，结点真正的值，可以是 <code>integer</code> 或 <code>string</code>。它的类型和长度由 <code>encoding</code> 来决定</li>
</ul>
</blockquote>
<p>接下来我们详细关注这三个参数：</p>
<h5 id="prevlen"><code>prevlen</code></h5>
<p>以字节为单位，记录前一个 <code>entry</code> 的长度。<code>prevlen</code> 的长度可以是 <strong>1 字节</strong> 或者 <strong>5 字节</strong>：</p>
<ul>
<li>当前一个结点的长度小于 254 字节时，<code>prevlen</code> 的长度为 <strong>1 字节</strong>，前一个 <code>entry</code> 的长度就保存在这一个字节中；</li>
<li>当前一个结点的长度大于等于 254 字节时，<code>prevlen</code> 的长度为 <strong>5 字节</strong>，其中第一个字节会被设置成 <code>0xFE</code>(十进制的 <code>254</code>)，表示这是一个 <strong>5 字节长</strong> 的 <code>prevlen</code>，后面的四个字节则保存前一个 <code>entry</code> 的长度。</li>
</ul>
<p><code>prevlen</code> 的作用是：在反向遍历压缩数组时，可以通过当前元素的指针，减去 <code>prevlen</code> ，就能得到前一个元素的地址。</p>
<p><img src="https://pic.downk.cc/item/5f78e315160a154a672db33d.png" alt=""></p>
<h5 id="encoding"><code>encoding</code></h5>
<p>节点的 <code>encoding</code> 属性记录了节点的 <code>entry-data</code> 属性所保存 <strong>数据的类型</strong> 以及 <strong>长度</strong>：</p>
<ul>
<li>一字节、两字节或者五字节长， 值的最高位为 <code>00</code> 、 <code>01</code> 或者 <code>10</code> 的是<strong>字节数组编码</strong>： 这种编码表示节点的 <code>content</code> 属性保存着 <strong>字符串(字节数组)</strong>， 数组的长度由编码除去最高两位之后的其他位记录：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">编码</th>
<th style="text-align:center">编码长度</th>
<th style="text-align:center">content 中保存的值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">00bbbbbb</td>
<td style="text-align:center"><strong>1 字节</strong></td>
<td style="text-align:center">长度小于等于 63 字节的字节数组(6 位分辨位，2^6 = 64，除去全 0 的)</td>
</tr>
<tr>
<td style="text-align:left">01bbbbbb | xxxxxxxx</td>
<td style="text-align:center"><strong>2 字节</strong></td>
<td style="text-align:center">长度小于等于 16383 字节的字节数组(14 位分辨位，2^14 = 16384，除去全 0 的)</td>
</tr>
<tr>
<td style="text-align:left">10000000 | xxxx…xxxx(32 位)</td>
<td style="text-align:center"><strong>5 字节</strong></td>
<td style="text-align:center">长度小于等于 4294967295 字节的字节数组(32 位分辨位，2^32 = 4294967296)</td>
</tr>
</tbody>
</table>
<ul>
<li>一字节长， 值的最高位以 <code>11</code> 开头的是<strong>整数编码</strong>： 这种编码表示节点的 <code>entry-data</code> 属性保存着<strong>整数</strong>值， 整数值的类型和长度由编码除去最高两位之后的其他位记录:</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">编码</th>
<th style="text-align:center">编码长度</th>
<th style="text-align:center">entry-data 中保存的值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">11000000</td>
<td style="text-align:center">1 字节</td>
<td style="text-align:center">int16_t 类型整数</td>
</tr>
<tr>
<td style="text-align:left">11010000</td>
<td style="text-align:center">1 字节</td>
<td style="text-align:center">int32_t 类型整数</td>
</tr>
<tr>
<td style="text-align:left">11100000</td>
<td style="text-align:center">1 字节</td>
<td style="text-align:center">int64_t 类型整数</td>
</tr>
<tr>
<td style="text-align:left">11110000</td>
<td style="text-align:center">1 字节</td>
<td style="text-align:center">24 位有符号整数</td>
</tr>
<tr>
<td style="text-align:left">11111110</td>
<td style="text-align:center">1 字节</td>
<td style="text-align:center">8 位有符号整数</td>
</tr>
<tr>
<td style="text-align:left">1111xxxx</td>
<td style="text-align:center">1 字节</td>
<td style="text-align:center">使用这一编码的节点没有相应的 <code>entry-data</code> 属性， 因为编码本身的 <code>xxxx</code> 四个位已经保存了一个介于 <code>0</code> 和 <code>12</code> 之间的值， 所以它无须 <code>entry-data</code> 属性。</td>
</tr>
</tbody>
</table>
<h5 id="entry-data"><code>entry-data</code></h5>
<p>节点的 <code>entry-data</code> 属性负责保存节点的值， 节点值可以是一个字节数组或者整数， 值的类型和长度由节点的 <code>encoding</code> 属性决定。</p>
<p><img src="https://pic.downk.cc/item/5f78e80c160a154a672e5400.png" alt=""></p>
<p><img src="https://pic.downk.cc/item/5f796b73160a154a674807ff.png" alt="压缩列表-示例"></p>
<h4 id="62-api">6.2 API</h4>
<ul>
<li><strong>创建<code>ziplist</code></strong></li>
</ul>
<p>返回一个只包含 <code>&lt;zlbytes&gt;&lt;zltail&gt;&lt;zllen&gt;&lt;zlend&gt;</code> 的 <code>ziplist</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">ziplistNew</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">ZIPLIST_HEADER_SIZE</span><span class="o">+</span><span class="n">ZIPLIST_END_SIZE</span><span class="p">;</span>  <span class="c1">// 头部的 4+4+2 和 尾部的1 总共 11 字节
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">zl</span> <span class="o">=</span> <span class="n">zmalloc</span><span class="p">(</span><span class="n">bytes</span><span class="p">);</span>  <span class="c1">// 这里的ziplist类型是一个 char 数组，而不是某个具体的结构体
</span><span class="c1"></span>    <span class="n">ZIPLIST_BYTES</span><span class="p">(</span><span class="n">zl</span><span class="p">)</span> <span class="o">=</span> <span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">bytes</span><span class="p">);</span>  <span class="c1">// 设置 zlbytes 为 初始分配的值，即 bytes
</span><span class="c1"></span>    <span class="n">ZIPLIST_TAIL_OFFSET</span><span class="p">(</span><span class="n">zl</span><span class="p">)</span> <span class="o">=</span> <span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">ZIPLIST_HEADER_SIZE</span><span class="p">);</span>  <span class="c1">// 设置 zltail 为 header 结束的地方
</span><span class="c1"></span>    <span class="n">ZIPLIST_LENGTH</span><span class="p">(</span><span class="n">zl</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 设置 zllen 为 0
</span><span class="c1"></span>    <span class="n">zl</span><span class="p">[</span><span class="n">bytes</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ZIP_END</span><span class="p">;</span>  <span class="c1">// 最后一个字节存储常量 255 ，表示 ziplist 结束
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">zl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>插入<code>ziplistInsert</code></strong></li>
</ul>
<p>这个函数的作用是 <strong>在 <code>ziplist</code> 的任意数据项前面插入一个新的数据项</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">ziplistInsert</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">zl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slen</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">__ziplistInsert</span><span class="p">(</span><span class="n">zl</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">slen</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 在 p 处 插入 s，s 的长度为 slen；插入后s占据p的位置，p及其后面的数据整体后移。其中 p 指向 ziplist 中某一个 entry 的起始位置，或者 zlend(当向尾部插入时)
</span><span class="c1"></span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">__ziplistInsert</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">zl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slen</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// reqlen 表示 将 s 变成一个 entry 所需要的总字节数，即 prevlen,encoding,entry-data 的总长度
</span><span class="c1"></span>    <span class="n">size_t</span> <span class="n">curlen</span> <span class="o">=</span> <span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">ZIPLIST_BYTES</span><span class="p">(</span><span class="n">zl</span><span class="p">)),</span> <span class="n">reqlen</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">prevlensize</span><span class="p">,</span> <span class="n">prevlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">size_t</span> <span class="n">offset</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">nextdiff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">encoding</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">123456789</span><span class="p">;</span> <span class="c1">// 随便使用一个一眼就能看出来的值表示当前变量未被逻辑初始化，避免 warning
</span><span class="c1"></span>    <span class="n">zlentry</span> <span class="n">tail</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ZIP_END</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 如果不是插入尾部，则根据p获取 p所在的 entry 的前一个 entry 的 prevlen，需要保存 prevlen的字节数保存在 prevlensize(1字节或者5字节，前面有介绍)
</span><span class="c1"></span>        <span class="n">ZIP_DECODE_PREVLEN</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">prevlensize</span><span class="p">,</span> <span class="n">prevlen</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// p 指向的是 尾部标志
</span><span class="c1"></span>        <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ptail</span> <span class="o">=</span> <span class="n">ZIPLIST_ENTRY_TAIL</span><span class="p">(</span><span class="n">zl</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ptail</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ZIP_END</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 获取 ziplist 最后一个 entry 的长度，保存在 prevlen 中
</span><span class="c1"></span>            <span class="n">prevlen</span> <span class="o">=</span> <span class="n">zipRawEntryLength</span><span class="p">(</span><span class="n">ptail</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 尝试能否转化成整数
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">zipTryEncoding</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">slen</span><span class="p">,</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span><span class="o">&amp;</span><span class="n">encoding</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// 可以转化成 int，则 reqlen 即为存储此 int 所需的字节数，即 entry-data 的长度
</span><span class="c1"></span>        <span class="n">reqlen</span> <span class="o">=</span> <span class="n">zipIntSize</span><span class="p">(</span><span class="n">encoding</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 无法转换成 int，那就是字节数组，reqlen 就是要存入的字符串的长度，即 entry-data 的长度
</span><span class="c1"></span>        <span class="n">reqlen</span> <span class="o">=</span> <span class="n">slen</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// reqlen
</span><span class="c1"></span>    <span class="n">reqlen</span> <span class="o">+=</span> <span class="n">zipStorePrevEntryLength</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="n">prevlen</span><span class="p">);</span>  <span class="c1">// 再加上 prevlen 的长度
</span><span class="c1"></span>    <span class="n">reqlen</span> <span class="o">+=</span> <span class="n">zipStoreEntryEncoding</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="n">encoding</span><span class="p">,</span><span class="n">slen</span><span class="p">);</span>  <span class="c1">// 再加上 encoding 的长度
</span><span class="c1"></span>
    <span class="c1">// 当不是向尾部插入时，我们必须确保下一个 entry 的 prevlen 等于当前 entry 的长度
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">forcelarge</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// 【1】nextdiff 存储的是p的prevlen的变化值(新元素长度reqlen - p之前entry的prelen)，具体解释看代码后面【1】处的解释
</span><span class="c1"></span>    <span class="n">nextdiff</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ZIP_END</span><span class="p">)</span> <span class="o">?</span> <span class="n">zipPrevLenByteDiff</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">reqlen</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nextdiff</span> <span class="o">==</span> <span class="o">-</span><span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="n">reqlen</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">nextdiff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">forcelarge</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// 这种情况下意味着，本来可以用 1 字节的，却使用了 5 个字节
</span><span class="c1"></span>    <span class="p">}</span>

    <span class="cm">/* Store offset because a realloc may change the address of zl. */</span>
    <span class="c1">// 存储 p 相对于 ziplist 的偏移量，因为 resize 可能改变 ziplist 的起始地址
</span><span class="c1"></span>    <span class="n">offset</span> <span class="o">=</span> <span class="n">p</span><span class="o">-</span><span class="n">zl</span><span class="p">;</span>
    <span class="c1">// 到这一步已经能确定 ziplist 需要的总的容量了，调用 resize 调整 ziplist 的大小
</span><span class="c1"></span>    <span class="n">zl</span> <span class="o">=</span> <span class="n">ziplistResize</span><span class="p">(</span><span class="n">zl</span><span class="p">,</span><span class="n">curlen</span><span class="o">+</span><span class="n">reqlen</span><span class="o">+</span><span class="n">nextdiff</span><span class="p">);</span>
    <span class="c1">// 重新定位 p
</span><span class="c1"></span>    <span class="n">p</span> <span class="o">=</span> <span class="n">zl</span><span class="o">+</span><span class="n">offset</span><span class="p">;</span>

    <span class="c1">// 将 p 以及其后面的数据移动为 s 挪地方，别忘了更新 zltail 的值
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ZIP_END</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// 在p前面腾出reqlen字节给新entry使用（将p move到p+reqlen，考虑了prelen缩减或增加）
</span><span class="c1"></span>        <span class="n">memmove</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="n">reqlen</span><span class="p">,</span><span class="n">p</span><span class="o">-</span><span class="n">nextdiff</span><span class="p">,</span><span class="n">curlen</span><span class="o">-</span><span class="n">offset</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="n">nextdiff</span><span class="p">);</span>

        <span class="c1">// 更新 s 的后一个 entry（p+reqlen即p的新地址）的prevlen；
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">forcelarge</span><span class="p">)</span>
            <span class="c1">// 【2】强制使用 5 字节存储，避免连锁更新时的大量重新分配空间操作，不进行缩容
</span><span class="c1"></span>            <span class="n">zipStorePrevEntryLengthLarge</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="n">reqlen</span><span class="p">,</span><span class="n">reqlen</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="c1">// 计算 reqlen 进而判断使用 1 字节 还是 5 字节
</span><span class="c1"></span>            <span class="n">zipStorePrevEntryLength</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="n">reqlen</span><span class="p">,</span><span class="n">reqlen</span><span class="p">);</span>

        <span class="c1">// 更新 zltail
</span><span class="c1"></span>        <span class="n">ZIPLIST_TAIL_OFFSET</span><span class="p">(</span><span class="n">zl</span><span class="p">)</span> <span class="o">=</span>
            <span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">ZIPLIST_TAIL_OFFSET</span><span class="p">(</span><span class="n">zl</span><span class="p">))</span><span class="o">+</span><span class="n">reqlen</span><span class="p">);</span>

          <span class="c1">// 更新zltail
</span><span class="c1"></span>        <span class="n">zipEntry</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="n">reqlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tail</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">reqlen</span><span class="o">+</span><span class="n">tail</span><span class="p">.</span><span class="n">headersize</span><span class="o">+</span><span class="n">tail</span><span class="p">.</span><span class="n">len</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ZIP_END</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ZIPLIST_TAIL_OFFSET</span><span class="p">(</span><span class="n">zl</span><span class="p">)</span> <span class="o">=</span>
                <span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">ZIPLIST_TAIL_OFFSET</span><span class="p">(</span><span class="n">zl</span><span class="p">))</span><span class="o">+</span><span class="n">nextdiff</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 如果是在尾部插入，则直接修改 zltail 为 s
</span><span class="c1"></span>        <span class="n">ZIPLIST_TAIL_OFFSET</span><span class="p">(</span><span class="n">zl</span><span class="p">)</span> <span class="o">=</span> <span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="n">zl</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 如果 nexydiff 不等于0，整个 s 后面的 ziplist 的 prevlen 都可能发生变化，这里尝试进行维护
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">nextdiff</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">p</span><span class="o">-</span><span class="n">zl</span><span class="p">;</span>
        <span class="n">zl</span> <span class="o">=</span> <span class="n">__ziplistCascadeUpdate</span><span class="p">(</span><span class="n">zl</span><span class="p">,</span><span class="n">p</span><span class="o">+</span><span class="n">reqlen</span><span class="p">);</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">zl</span><span class="o">+</span><span class="n">offset</span><span class="p">;</span>  <span class="c1">// 改变的只是 p 后面的，前面的没变，因此 s 插入的位置没变
</span><span class="c1"></span>    <span class="p">}</span>

    <span class="c1">// 存入 s 这个 entry
</span><span class="c1"></span>    <span class="n">p</span> <span class="o">+=</span> <span class="n">zipStorePrevEntryLength</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">prevlen</span><span class="p">);</span>
    <span class="n">p</span> <span class="o">+=</span> <span class="n">zipStoreEntryEncoding</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">encoding</span><span class="p">,</span><span class="n">slen</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ZIP_IS_STR</span><span class="p">(</span><span class="n">encoding</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">slen</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">zipSaveInteger</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">value</span><span class="p">,</span><span class="n">encoding</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// ziplist 的长度加 1
</span><span class="c1"></span>    <span class="n">ZIPLIST_INCR_LENGTH</span><span class="p">(</span><span class="n">zl</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">zl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 将 ziplist 的长度变成 len
</span><span class="c1"></span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">ziplistResize</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">zl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">zl</span> <span class="o">=</span> <span class="n">zrealloc</span><span class="p">(</span><span class="n">zl</span><span class="p">,</span><span class="n">len</span><span class="p">);</span>
    <span class="n">ZIPLIST_BYTES</span><span class="p">(</span><span class="n">zl</span><span class="p">)</span> <span class="o">=</span> <span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
    <span class="n">zl</span><span class="p">[</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ZIP_END</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">zl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>解释【1】：这种情况发生在 <strong>插入的位置不是尾部</strong> 的情况，我们假设 <code>p</code> 的前一个元素为 <code>p0</code>，此时 <code>p</code> 的 <code>prevlen</code> 存储的是 <code>p0</code> 的长度。但是由于要将 <code>s</code> 插入到 <code>p</code> 之前，那么 <code>p</code> 的 <code>prevlen</code> 的值就应该变成 <code>s</code> 的长度，这样 <code>p</code> 本身的长度也就发生了变化，有可能变大也有可能变小。这个变化了多少的值就是 <code>nextdiff</code>，如果变大了，<code>nextdiff</code> 是正数，否则是负数。如果是负数，只有一种情况，那就是 <code>p0</code> 的长度大于 254，用 5 个字节存；而 <code>s</code> 的长度小于 254，用 1 个字节存就够了。</p>
<p>解释【2】：关于 <code>forcelarge</code>，这是一个已经被修改后的 <a href="https://github.com/redis/redis/commit/8327b813#diff-b109b27001207a835769c556a54ff1b3">bug</a>，大致意思是，这种操作发生在 <strong>连锁更新</strong>(90 行) 的时候，为了防止大量的重新分配空间的动作，如果一个 <code>entry</code> 的长度只需要 1 个字节就能够保存,但是连锁更新时如果原先已经为 <code>prevlen</code> 分配了 5 个字节,则不会进行缩容操作。关于为何，可以参考这篇文章：<a href="https://erpeng.github.io/2019/04/15/Redis%E7%9A%84%E4%B8%80%E4%B8%AA%E5%8E%86%E5%8F%B2bug%E5%8F%8A%E5%85%B6%E5%90%8E%E7%BB%AD%E6%94%B9%E8%BF%9B/">Redis 的一个历史 bug 及其后续改进</a>，作者对这个 <code>bug</code> 进行了复现，以及提到了 <code>Redis</code> 对此作出的更新(提出了更优化的结构 <code>listpack</code>)。</p>
<p>我们接着说 <strong>连锁更新</strong>。回忆一个 <code>entry</code> 的结构，其中 <code>prevlen</code> 表示前一个 <code>entry</code> 的长度：如果前一个结点长度小于 254，则 <code>prevlen</code> 占用 1 字节，否则占用 5 字节。现在， 考虑这样一种情况： 在一个压缩列表中， 有多个连续的、长度介于 <code>250</code> 字节到 <code>253</code> 字节之间的节点 <code>e1</code> 至 <code>eN</code> 。因为 <code>e1</code> 至 <code>eN</code> 的所有节点的长度都小于 <code>254</code> 字节， 所以记录这些节点的长度只需要 <code>1</code> 字节长的 <code>prevlen</code> 属性， 换句话说， <code>e1</code> 至 <code>eN</code> 的所有节点的 <code>prevlen</code> 属性都是 <code>1</code> 字节长的。此时，如果我们在 <code>e1</code> 前面插入一个长度大于 254 的元素 <code>m</code>，因为 <code>e1</code> 的 <code>prevlen</code> 仅为 1 字节，无法保存大于 254 的数，因此，我们还要对 <code>ziplist</code> 进行空间重分配操作，使得 <code>e1</code> 能够保存 <code>m</code> 的长度，即将 <code>ziplist</code> 的大小再增加 4 字节，让 <code>e1</code> 的 <code>prevlen</code> 大小由 1 字节变为 5 字节，这种操作我们称为 <code>m</code> 对 <code>e1</code> 发生了 <strong>扩展</strong>。回到刚才的情况，现在麻烦来了，<code>e1</code> 大小发生了变化，肯定超过了原来的 254，此时 <code>e1</code> 需要对 <code>e2</code> 进行扩展，又到后面，<code>e2</code> 需要对 <code>e3</code> 进行扩展……程序需要不断地对压缩列表执行空间重分配操作， 直到 <code>eN</code> 为止。</p>
<p><code>Redis</code> 将这种在特殊情况下产生的连续多次空间扩展操作称之为 <strong>“连锁更新”（<code>cascade update</code>）</strong>。我们看看 <strong>连锁更新</strong> 的具体实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// p 指向第一个不需要更新的 entry
</span><span class="c1"></span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">__ziplistCascadeUpdate</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">zl</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">size_t</span> <span class="n">curlen</span> <span class="o">=</span> <span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">ZIPLIST_BYTES</span><span class="p">(</span><span class="n">zl</span><span class="p">)),</span> <span class="n">rawlen</span><span class="p">,</span> <span class="n">rawlensize</span><span class="p">;</span>
    <span class="n">size_t</span> <span class="n">offset</span><span class="p">,</span> <span class="n">noffset</span><span class="p">,</span> <span class="n">extra</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>
    <span class="n">zlentry</span> <span class="n">cur</span><span class="p">,</span> <span class="n">next</span><span class="p">;</span>

    <span class="c1">// 当 p 是 ziplist 的”尾巴“时停止更新
</span><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ZIP_END</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">zipEntry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur</span><span class="p">);</span>  <span class="c1">// 【1】将 entry 解码称为一个易于操作的 entry 结构体，细节见代码后解释
</span><span class="c1"></span>        <span class="n">rawlen</span> <span class="o">=</span> <span class="n">cur</span><span class="p">.</span><span class="n">headersize</span> <span class="o">+</span> <span class="n">cur</span><span class="p">.</span><span class="n">len</span><span class="p">;</span> <span class="c1">// 当前节点的长度
</span><span class="c1"></span>        <span class="n">rawlensize</span> <span class="o">=</span> <span class="n">zipStorePrevEntryLength</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="n">rawlen</span><span class="p">);</span>  <span class="c1">// 存储当前节点所需要的 prevlen 大小
</span><span class="c1"></span>
        <span class="c1">// 没有下一个节点，直接返回
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">rawlen</span><span class="p">]</span> <span class="o">==</span> <span class="n">ZIP_END</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>

        <span class="c1">// 获取 p 的下一个节点
</span><span class="c1"></span>        <span class="n">zipEntry</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="n">rawlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">next</span><span class="p">);</span>

        <span class="c1">// 如果下一个节点的 prevlen 等于当前节点的 长度，则没必要更新，直接退出循环
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="p">.</span><span class="n">prevrawlen</span> <span class="o">==</span> <span class="n">rawlen</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>

        <span class="c1">// 下一个节点的 prevlen 小于当前节点的长度(当前节点长度为 5 字节，next 的 prevlen 为1 字节)
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="p">.</span><span class="n">prevrawlensize</span> <span class="o">&lt;</span> <span class="n">rawlensize</span><span class="p">)</span> <span class="p">{</span>

            <span class="c1">// ziplist的地址可能发生改变，先记录 p 相对于zl起始位置的偏移量
</span><span class="c1"></span>            <span class="n">offset</span> <span class="o">=</span> <span class="n">p</span><span class="o">-</span><span class="n">zl</span><span class="p">;</span>
            <span class="c1">// 额外需要申请的空间 5 - 1 = 4
</span><span class="c1"></span>            <span class="n">extra</span> <span class="o">=</span> <span class="n">rawlensize</span><span class="o">-</span><span class="n">next</span><span class="p">.</span><span class="n">prevrawlensize</span><span class="p">;</span>
            <span class="c1">// 改变 ziplist 的容量
</span><span class="c1"></span>            <span class="n">zl</span> <span class="o">=</span> <span class="n">ziplistResize</span><span class="p">(</span><span class="n">zl</span><span class="p">,</span><span class="n">curlen</span><span class="o">+</span><span class="n">extra</span><span class="p">);</span>
            <span class="c1">// 重新计算 p 的位置
</span><span class="c1"></span>            <span class="n">p</span> <span class="o">=</span> <span class="n">zl</span><span class="o">+</span><span class="n">offset</span><span class="p">;</span>

            <span class="cm">/* Current pointer and offset for next element. */</span>
            <span class="n">np</span> <span class="o">=</span> <span class="n">p</span><span class="o">+</span><span class="n">rawlen</span><span class="p">;</span>  <span class="c1">// next 的新地址
</span><span class="c1"></span>            <span class="n">noffset</span> <span class="o">=</span> <span class="n">np</span><span class="o">-</span><span class="n">zl</span><span class="p">;</span>  <span class="c1">// next新地址相对于 ziplist 头部的偏移量
</span><span class="c1"></span>
            <span class="c1">// 更新 zltail
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">((</span><span class="n">zl</span><span class="o">+</span><span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">ZIPLIST_TAIL_OFFSET</span><span class="p">(</span><span class="n">zl</span><span class="p">)))</span> <span class="o">!=</span> <span class="n">np</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ZIPLIST_TAIL_OFFSET</span><span class="p">(</span><span class="n">zl</span><span class="p">)</span> <span class="o">=</span>
                    <span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">intrev32ifbe</span><span class="p">(</span><span class="n">ZIPLIST_TAIL_OFFSET</span><span class="p">(</span><span class="n">zl</span><span class="p">))</span><span class="o">+</span><span class="n">extra</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="c1">// 扩展 next 的 prevlen，并将数据拷贝
</span><span class="c1"></span>            <span class="n">memmove</span><span class="p">(</span><span class="n">np</span><span class="o">+</span><span class="n">rawlensize</span><span class="p">,</span>
                <span class="n">np</span><span class="o">+</span><span class="n">next</span><span class="p">.</span><span class="n">prevrawlensize</span><span class="p">,</span>
                <span class="n">curlen</span><span class="o">-</span><span class="n">noffset</span><span class="o">-</span><span class="n">next</span><span class="p">.</span><span class="n">prevrawlensize</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
            <span class="c1">// 在扩展后的 next 的 prevlen 中重新记录 p 的长度
</span><span class="c1"></span>            <span class="n">zipStorePrevEntryLength</span><span class="p">(</span><span class="n">np</span><span class="p">,</span><span class="n">rawlen</span><span class="p">);</span>

            <span class="cm">/* Advance the cursor */</span>
            <span class="c1">// 更新 p 为下一个 entry
</span><span class="c1"></span>            <span class="n">p</span> <span class="o">+=</span> <span class="n">rawlen</span><span class="p">;</span>
            <span class="c1">// 更新 p 的长度(需要加上扩展的 prevlen 的 extra 个字节)
</span><span class="c1"></span>            <span class="n">curlen</span> <span class="o">+=</span> <span class="n">extra</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// 这种情况下，next 的 prevlen 足够表示 当前 p 的长度
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="p">.</span><span class="n">prevrawlensize</span> <span class="o">&gt;</span> <span class="n">rawlensize</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// next 的 prevlen &gt; p 的长度(next.prevlen = 5 结点，p的长度小于 5 个结点)，此时应该 缩容，但出于性能以及操作的方便性(减少后续连锁更新的可能性)，我们通常不进行缩容，这个时候，直接将 next 的 prevlen 设置为 5 个结点
</span><span class="c1"></span>                <span class="n">zipStorePrevEntryLengthLarge</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="n">rawlen</span><span class="p">,</span><span class="n">rawlen</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// 相等
</span><span class="c1"></span>                <span class="n">zipStorePrevEntryLength</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="n">rawlen</span><span class="p">,</span><span class="n">rawlen</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="c1">// next 的长度并没有发生变化(没有缩容)，终止循环
</span><span class="c1"></span>            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">zl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>解释【1】：“辅助结构体” <code>zlentry</code>，这个结构体与 <code>ziplist</code> 中的一个实际 <code>entry</code> 相对应，其作用是为了更加方便地操作一个 实际的 <code>entry</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">zlentry</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">prevrawlensize</span><span class="p">;</span> <span class="c1">// 存储 prevrawlen 所需要的字节数，同样也有 1字节 和 5字节之分
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">prevrawlen</span><span class="p">;</span>     <span class="c1">// 对应 prevlen
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lensize</span><span class="p">;</span>        <span class="c1">// 存储 len 所需要的字节数
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>            <span class="c1">// 当前 entry 的长度
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">headersize</span><span class="p">;</span>     <span class="c1">// ziplist头部大小: prevrawlensize + lensize
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">encoding</span><span class="p">;</span>      <span class="c1">// 编码方式
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>            <span class="c1">// 指向某个实际 entry 的地址
</span><span class="c1"></span><span class="p">}</span> <span class="n">zlentry</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>其他的一些操作，比如删除、查找，过程与插入类似，无非就是各个 entry 地址的计算，删除时还有可能涉及到连锁更新。</strong> 这里不再描述，想了解的可以根据上面的思路自己研究源代码。</p>
<h4 id="63-总结">6.3 总结</h4>
<ul>
<li><code>ziplist</code>是 redis 为了节省内存，提升存储效率自定义的一种紧凑的数据结构，每一个 <code>entry</code> 都保存这上一个 <code>entry</code> 的长度，可以很方便地进行反向遍历；</li>
<li>添加和删除节点可能会引发连锁更新，极端情况下会更新整个<code>ziplist</code>，但是概率很小；</li>
<li>在 <code>Redis</code> 中，当元素个数较少时，哈希表(<code>hset</code> 等操作) 和 列表(<code>lpush</code> 等操作) 的底层结构都是 <code>ziplist</code>。</li>
</ul>
<h3 id="7-紧凑列表">7. 紧凑列表</h3>
<blockquote>
<p>源码文件：<a href="https://github.com/redis/redis/blob/unstable/src/listpack.h">listpack.h</a></p>
<p>实现文档：<a href="https://gist.github.com/antirez/66ffab20190ece8a7485bd9accfbc175">Listpack specification</a></p>
</blockquote>
<p>紧凑列表是 压缩列表 的升级版，目的是在未来代替 <code>ziplist</code>。</p>
<p>有时间再完善。</p>
<h2 id="二-redis-对象对应的数据结构">二、 <code>Redis</code> 对象对应的数据结构</h2>
<p>前面大致介绍了 <strong>简单动态字符串 <code>sds</code></strong>、<strong>双端链表 <code>adlist</code></strong>、<strong>字典 <code>dict</code></strong>、<strong>跳表 <code>skiplist</code></strong>、<strong>整数集合 <code>intset</code></strong> 和 <strong>压缩列表 <code>ziplist</code></strong> 等基础数据结构，同时我们知道 <code>Redis</code> 中有 <strong>字符串对象(string)</strong>、<strong>列表对象(list)</strong>、<strong>哈希对象(hash)</strong>、<strong>集合对象(set)</strong> 和 <strong>有序集合对象(zset)</strong> 等五种对象，他们都至少用了上面一种基础数据结构来实现。在 <code>Redis</code> 中，客户端的一条命令以及参数会被解释成一个 <code>robj</code> 结构体：</p>
<blockquote>
<p>源码文件： <a href="%5Bziplist.h%5D(https://github.com/redis/redis/blob/unstable/src/server.h)">server.h</a></p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">redisObject</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="nl">type</span> <span class="p">:</span> <span class="mi">4</span><span class="p">;</span>       <span class="c1">// 类型
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="nl">encoding</span> <span class="p">:</span> <span class="mi">4</span><span class="p">;</span>	 <span class="c1">// 编码
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="nl">lru</span> <span class="p">:</span> <span class="n">LRU_BITS</span><span class="p">;</span> <span class="c1">// 对象最后被访问的时间，我们暂时不关注 LRU
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">refcount</span><span class="p">;</span>			 <span class="c1">// 引用次数
</span><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>				 <span class="c1">// 指向实现对象的数据结构
</span><span class="c1"></span><span class="p">}</span> <span class="n">robj</span><span class="p">;</span>

<span class="cm">/* Object types */</span>
<span class="cp">#define OBJ_STRING 0 </span><span class="cm">/* String object. */</span><span class="cp">
</span><span class="cp">#define OBJ_LIST 1   </span><span class="cm">/* List object. */</span><span class="cp">
</span><span class="cp">#define OBJ_SET 2    </span><span class="cm">/* Set object. */</span><span class="cp">
</span><span class="cp">#define OBJ_ZSET 3   </span><span class="cm">/* Sorted set object. */</span><span class="cp">
</span><span class="cp">#define OBJ_HASH 4   </span><span class="cm">/* Hash object. */</span><span class="cp">
</span><span class="cp"></span>
<span class="cm">/* Objects encoding. Some kind of objects like Strings and Hashes can be
</span><span class="cm"> * internally represented in multiple ways. The &#39;encoding&#39; field of the object
</span><span class="cm"> * is set to one of this fields for this object. */</span>
<span class="cp">#define OBJ_ENCODING_RAW 0        </span><span class="c1">// 简单动态字符串 sds
</span><span class="c1"></span><span class="cp">#define OBJ_ENCODING_INT 1        </span><span class="c1">// long 类型
</span><span class="c1"></span><span class="cp">#define OBJ_ENCODING_HT 2         </span><span class="c1">// 字典 dict
</span><span class="c1"></span><span class="cp">#define OBJ_ENCODING_ZIPMAP 3     </span><span class="c1">// zipmap(弃用)
</span><span class="c1"></span><span class="cp">#define OBJ_ENCODING_LINKEDLIST 4 </span><span class="c1">// 双端链表 adlist
</span><span class="c1"></span><span class="cp">#define OBJ_ENCODING_ZIPLIST 5    </span><span class="c1">// 压缩列表 ziplist
</span><span class="c1"></span><span class="cp">#define OBJ_ENCODING_INTSET 6     </span><span class="c1">// 整数集合 intset
</span><span class="c1"></span><span class="cp">#define OBJ_ENCODING_SKIPLIST 7   </span><span class="c1">// 跳表 skiplist
</span><span class="c1"></span><span class="cp">#define OBJ_ENCODING_EMBSTR 8     </span><span class="c1">// 采用embstr编码的sds
</span><span class="c1"></span><span class="cp">#define OBJ_ENCODING_QUICKLIST 9  </span><span class="c1">// qunicklist，用于列表
</span><span class="c1"></span><span class="cp">#define OBJ_ENCODING_STREAM 10    </span><span class="c1">// 紧凑列表 listpack
</span><span class="c1"></span><span class="cp">#define LRU_BITS 24
</span></code></pre></td></tr></table>
</div>
</div><p><code>obj</code> 的作用大致为：</p>
<ul>
<li>为多种数据类型提供一种统一的表示方式。</li>
<li>允许同一类型的数据采用不同的内部表示，从而在某些情况下尽量节省内存。</li>
<li>支持对象共享和引用计数。当对象被共享的时候，只占用一份内存拷贝，进一步节省内存。</li>
</ul>
<p>说到底， <code>robj</code> 所表示的就是 <strong>五种 <code>Object types</code></strong> 和 <strong>11 中 <code>Object encoding</code></strong> 之间的对应方式，起到一个桥梁作用。这种对应关系可用如下的图来表示：</p>
<p><img src="https://pic.downk.cc/item/5f7a3a91160a154a67813577.png" alt="Redis对象与数据结构对应关系"></p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">JemmyHu(hujm20151021@gmail.com)</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-10-02 12:31
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/redis/">Redis</a>
          <a href="/tags/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">基础数据结构</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E8%B7%B3%E8%A1%A8/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">跳表原理以及Golang实现</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/mysql%E5%85%B3%E4%BA%8E%E7%B4%A2%E5%BC%95/">
            <span class="next-text nav-default">MySQL关于索引</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  
  <div id="vcomments"></div>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <script type="text/javascript">
    new Valine({
        el: '#vcomments' ,
        appId: 'LjkR3NaCog7bTVOnJNMmJjcM-gzGzoHsz',
        appKey: 'UQMdKbH71EeHJppAbtDwb5Rg',
        notify:  true ,
        verify:  false ,
        avatar:'monsterid',
        placeholder: '欢迎留言~',
        visitor:  false 
    });
  </script>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:hujm20151021@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/JemmyH" class="iconfont icon-github" title="github"></a>
  <a href="http://localhost:1313/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2020<span class="heart"><i class="iconfont icon-heart"></i></span><span>Jemmy</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script><script></script><script src="https://cdn.jsdelivr.net/npm/raphael@2.2.7/raphael.min.js" integrity="sha256-67By+NpOtm9ka1R6xpUefeGOY8kWWHHRAKlvaTJ7ONI=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/flowchart.js@1.8.0/release/flowchart.min.js" integrity="sha256-zNGWjubXoY6rb5MnmpBNefO0RgoVYfle9p0tvOQM+6k=" crossorigin="anonymous"></script><script></script><script src="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.js" integrity="sha256-4O4pS1SH31ZqrSO2A/2QJTVjTPqVe+jnYgOWUVr7EEc=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/snapsvg@0.5.1/dist/snap.svg-min.js" integrity="sha256-oI+elz+sIm+jpn8F/qEspKoKveTc5uKeFHNNVexe6d8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/underscore@1.8.3/underscore-min.js" integrity="sha256-obZACiHd7gkOk9iIL/pimWMTJ4W/pBsKu+oZnSeBIek=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/gh/bramp/js-sequence-diagrams@2.0.1/dist/sequence-diagram-min.js" integrity="sha384-8748Vn52gHJYJI0XEuPB2QlPVNUkJlJn9tHqKec6J3q2r9l8fvRxrgn/E5ZHV0sP" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/bramp/js-sequence-diagrams@2.0.1/dist/sequence-diagram-min.css" integrity="sha384-6QbLKJMz5dS3adWSeINZe74uSydBGFbnzaAYmp+tKyq60S7H2p6V7g1TysM5lAaF" crossorigin="anonymous">



<script type="text/javascript" src="/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
