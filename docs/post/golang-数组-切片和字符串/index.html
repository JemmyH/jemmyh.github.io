<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Golang-数组,切片和字符串 - Jemmy&#39;s blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="JemmyHu(hujm20151021@gmail.com)" /><meta name="description" content="在主流的编程语言中数组及其相关的数据结构是使用得最为频繁的，只有在它(们)不能满足时才会考虑链表、hash 表（hash 表可以看作是数组和链表" /><meta name="keywords" content="Jemmy, blog" />






<meta name="generator" content="Hugo 0.76.5 with theme even" />


<link rel="canonical" href="http://localhost:1313/post/golang-%E6%95%B0%E7%BB%84-%E5%88%87%E7%89%87%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.c7bc1becf36bcf6a9ebd25d2947e43a2eb745ddb0c9a32b43126fd7fa460c351.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Golang-数组,切片和字符串" />
<meta property="og:description" content="在主流的编程语言中数组及其相关的数据结构是使用得最为频繁的，只有在它(们)不能满足时才会考虑链表、hash 表（hash 表可以看作是数组和链表" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/post/golang-%E6%95%B0%E7%BB%84-%E5%88%87%E7%89%87%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/" />
<meta property="article:published_time" content="2020-09-16T02:15:54+00:00" />
<meta property="article:modified_time" content="2020-09-16T02:15:54+00:00" />
<meta itemprop="name" content="Golang-数组,切片和字符串">
<meta itemprop="description" content="在主流的编程语言中数组及其相关的数据结构是使用得最为频繁的，只有在它(们)不能满足时才会考虑链表、hash 表（hash 表可以看作是数组和链表">
<meta itemprop="datePublished" content="2020-09-16T02:15:54+00:00" />
<meta itemprop="dateModified" content="2020-09-16T02:15:54+00:00" />
<meta itemprop="wordCount" content="5765">



<meta itemprop="keywords" content="Golang,数组,切片,字符串," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Golang-数组,切片和字符串"/>
<meta name="twitter:description" content="在主流的编程语言中数组及其相关的数据结构是使用得最为频繁的，只有在它(们)不能满足时才会考虑链表、hash 表（hash 表可以看作是数组和链表"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Jemmy&#39;s blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">时间线</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Jemmy&#39;s blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">时间线</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Golang-数组,切片和字符串</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-09-16 02:15 </span>
        <div class="post-category">
            <a href="/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"> 技术博客 </a>
            <a href="/categories/%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/"> 技术细节 </a>
            <a href="/categories/golang/"> Golang </a>
            </div>
          <span class="more-meta"> 约 5765 字 </span>
          <span class="more-meta"> 预计阅读 12 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#一-数组array">一、 数组(Array)</a>
          <ul>
            <li><a href="#1-概述">1. 概述</a></li>
            <li><a href="#2-初始化">2. 初始化</a></li>
            <li><a href="#3-赋值与访问">3. 赋值与访问</a></li>
          </ul>
        </li>
        <li><a href="#二切片slice">二、切片(Slice)</a>
          <ul>
            <li><a href="#1-内部实现">1. 内部实现</a></li>
            <li><a href="#2-slice-的创建">2. slice 的创建</a></li>
            <li><a href="#3-关于-make-创建-slice">3. 关于 make 创建 slice</a></li>
            <li><a href="#4-切片截取">4. 切片截取</a></li>
            <li><a href="#5-append-扩容规则">5. append 扩容规则</a></li>
            <li><a href="#6-slice-作为函数参数">6. slice 作为函数参数</a></li>
          </ul>
        </li>
        <li><a href="#三字符串string">三、字符串(String)</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>在主流的编程语言中数组及其相关的数据结构是使用得最为频繁的，只有在它(们)不能满足时才会考虑链表、hash 表（hash 表可以看作是数组和链表的混合体）和更复杂的自定义数据结构。</p>
<p>Go 语言中数组、字符串和切片三者是密切相关的数据结构。这三种数据类型，在底层原始数据有着相同的内存结构，在上层，因为语法的限制而有着不同的行为表现。</p>
<h2 id="一-数组array">一、 数组(Array)</h2>
<h3 id="1-概述">1. 概述</h3>
<p>数组是由相同类型元素的集合组成的数据结构，计算机会为数组分配一块连续的内存来保存其中的元素，我们可以利用数组中元素的索引快速访问元素对应的存储地址。</p>
<p>数组作为一种基本的数据类型，我们通常都会从两个维度描述数组：类型 和 大小(能够存储的最大元素个数)：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 源码位于 /usr/local/go/src/cmd/compile/internal/types/type.go
</span><span class="c1">// Array contains Type fields specific to array types.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Array</span> <span class="kd">struct</span> <span class="p">{</span>
 <span class="nx">Elem</span>  <span class="o">*</span><span class="nx">Type</span> <span class="c1">// element type 元素类型
</span><span class="c1"></span> <span class="nx">Bound</span> <span class="kt">int64</span> <span class="c1">// number of elements; &lt;0 if unknown yet 最大元素个数，小于0表示未知
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// NewArray returns a new fixed-length array Type.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewArray</span><span class="p">(</span><span class="nx">elem</span> <span class="o">*</span><span class="nx">Type</span><span class="p">,</span> <span class="nx">bound</span> <span class="kt">int64</span><span class="p">)</span> <span class="o">*</span><span class="nx">Type</span> <span class="p">{</span>
 <span class="k">if</span> <span class="nx">bound</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
  <span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;NewArray: invalid bound %v&#34;</span><span class="p">,</span> <span class="nx">bound</span><span class="p">)</span>
 <span class="p">}</span>
 <span class="nx">t</span> <span class="o">:=</span> <span class="nf">New</span><span class="p">(</span><span class="nx">TARRAY</span><span class="p">)</span>
 <span class="nx">t</span><span class="p">.</span><span class="nx">Extra</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Array</span><span class="p">{</span><span class="nx">Elem</span><span class="p">:</span> <span class="nx">elem</span><span class="p">,</span> <span class="nx">Bound</span><span class="p">:</span> <span class="nx">bound</span><span class="p">}</span>
 <span class="nx">t</span><span class="p">.</span><span class="nf">SetNotInHeap</span><span class="p">(</span><span class="nx">elem</span><span class="p">.</span><span class="nf">NotInHeap</span><span class="p">())</span>
 <span class="k">return</span> <span class="nx">t</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>从上述代码可以看出，类型<code>Array</code>包含两个属性，一个是数组类型<code>Elem</code>，另一个是数组大小<code>Bound</code>。另外需要注意的是：<strong>Go 语言中数组在初始化之后大小无法改变</strong>。</p>
<h3 id="2-初始化">2. 初始化</h3>
<p>有两种初始化方式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">array1</span> <span class="p">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
<span class="nx">array2</span> <span class="p">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述两种声明方式在运行期间得到的结果是完全相同的，后一种声明方式在编译期间就会被“转换”成为前一种，这也就是编译器对数组大小的推导。</p>
<p>对第一种方式，那么变量的类型在编译进行到<strong>类型检查</strong>阶段就会被提取出来，随后会使用 <code>NewArray</code>函数创建包含数组大小的 <code>Array</code> 类型。</p>
<p>对第二种方式，在第一步会创建一个<code>Array{Elem: elem, Bound: -1}</code>，即其大小会是<code>-1</code>，不过这里的<code>-1</code>只是一个占位符，编译器会在后面的 <code>/usr/local/go/src/cmd/compile/internal/gc/typecheck.go</code> 中对数组大小进行推导，并更新其 <code>Bound</code> 值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// The result of typecheckcomplit MUST be assigned back to n, e.g.
</span><span class="c1">//  n.Left = typecheckcomplit(n.Left)
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">typecheckcomplit</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">Node</span><span class="p">)</span> <span class="p">(</span><span class="nx">res</span> <span class="o">*</span><span class="nx">Node</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
     <span class="c1">// Need to handle [...]T arrays specially.
</span><span class="c1"></span> <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Right</span><span class="p">.</span><span class="nx">Op</span> <span class="o">==</span> <span class="nx">OTARRAY</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Right</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Right</span><span class="p">.</span><span class="nx">Left</span><span class="p">.</span><span class="nx">Op</span> <span class="o">==</span> <span class="nx">ODDD</span> <span class="p">{</span>
  <span class="nx">n</span><span class="p">.</span><span class="nx">Right</span><span class="p">.</span><span class="nx">Right</span> <span class="p">=</span> <span class="nf">typecheck</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">Right</span><span class="p">.</span><span class="nx">Right</span><span class="p">,</span> <span class="nx">ctxType</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Right</span><span class="p">.</span><span class="nx">Right</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
   <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="p">=</span> <span class="kc">nil</span>
   <span class="k">return</span> <span class="nx">n</span>
  <span class="p">}</span>
  <span class="nx">elemType</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Right</span><span class="p">.</span><span class="nx">Right</span><span class="p">.</span><span class="nx">Type</span>

        <span class="c1">// typecheckarraylit type-checks a sequence of slice/array literal elements.
</span><span class="c1"></span>  <span class="nx">length</span> <span class="o">:=</span> <span class="nf">typecheckarraylit</span><span class="p">(</span><span class="nx">elemType</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">n</span><span class="p">.</span><span class="nx">List</span><span class="p">.</span><span class="nf">Slice</span><span class="p">(),</span> <span class="s">&#34;array literal&#34;</span><span class="p">)</span>

  <span class="nx">n</span><span class="p">.</span><span class="nx">Op</span> <span class="p">=</span> <span class="nx">OARRAYLIT</span>
  <span class="nx">n</span><span class="p">.</span><span class="nx">Type</span> <span class="p">=</span> <span class="nx">types</span><span class="p">.</span><span class="nf">NewArray</span><span class="p">(</span><span class="nx">elemType</span><span class="p">,</span> <span class="nx">length</span><span class="p">)</span>
  <span class="nx">n</span><span class="p">.</span><span class="nx">Right</span> <span class="p">=</span> <span class="kc">nil</span>
  <span class="k">return</span> <span class="nx">n</span>
 <span class="p">}</span>
    <span class="o">...</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>虽然在编译期这两种方式的实现方式不同，但在运行时这两中方式是完全等价的。事实上，<code>[...]T</code> 这种初始化方式也只是 Go 语言为我们提供的一种语法糖，当我们不想计算数组中的元素个数时可以偷个懒。</p>
<p>另：变量初始化的位置：</p>
<p>如果数组中元素的个数小于或者等于 4 个，那么所有的变量会直接在栈上初始化；如果数组元素大于 4 个，变量就会在静态存储区初始化然后拷贝到栈上，这些转换之后代码才会继续进入 <strong>中间代码生成</strong> 和 <strong>机器码生成</strong> 两个阶段，最后生成可以执行的二进制文件。</p>
<h3 id="3-赋值与访问">3. 赋值与访问</h3>
<p>Go 语言中数组是值语义。一个数组变量即表示整个数组，它并不是隐式的指向第一个元素的指针（比如 C 语言的数组），而是一个完整的值。当一个数组变量被赋值或者被传递的时候，实际上会复制整个数组。如果数组较大的话，数组的赋值也会有较大的开销。为了避免复制数组带来的开销，可以传递一个指向数组的指针，但是数组指针并不是数组。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">a</span> <span class="p">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span> <span class="c1">// a 是一个数组
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">b</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">a</span>                <span class="c1">// b 是指向数组的指针
</span><span class="c1"></span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>   <span class="c1">// 打印数组的前2个元素
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">b</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>   <span class="c1">// 通过数组指针访问数组元素的方式和数组类似
</span><span class="c1"></span>
<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">b</span> <span class="p">{</span>     <span class="c1">// 通过数组指针迭代数组的元素
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们可以用<code>for</code>循环来迭代数组。下面常见的几种方式都可以用来遍历数组：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;方式一：&#34;</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">a</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;a[%d]: %d\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;方式二：&#34;</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">a</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;a[%d]: %d\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;方式三：&#34;</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;a[%d]: %d\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
<span class="p">}</span>

<span class="c1">// 输出
</span><span class="c1"></span><span class="nx">方式一</span><span class="err">：</span>
<span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="mi">1</span>
<span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="mi">4</span>
<span class="nx">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="mi">3</span>
<span class="nx">方式二</span><span class="err">：</span>
<span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="mi">1</span>
<span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="mi">4</span>
<span class="nx">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="mi">3</span>
<span class="nx">方式三</span><span class="err">：</span>
<span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="mi">1</span>
<span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="mi">4</span>
<span class="nx">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="mi">3</span>
</code></pre></td></tr></table>
</div>
</div><p>用<code>for range</code>方式迭代的性能可能会更好一些，因为这种迭代可以保证不会出现数组越界的情形，每轮迭代对数组元素的访问时可以省去对下标越界的判断。</p>
<p>需要注意的是 <strong>长度为 0 的数组</strong>。<strong>长度为 0 的数组在内存中并不占用空间</strong>，有时候可以用于强调某种特有类型的操作时避免分配额外的内存空间，比如用于管道的同步操作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">c1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;c1&#34;</span><span class="p">)</span>
    <span class="nx">c1</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
<span class="p">}()</span>
<span class="o">&lt;-</span><span class="nx">c1</span>
</code></pre></td></tr></table>
</div>
</div><p>在此场景下我们并不关心管道中的具体数据以及类型，我们需要的只是管道的接收和发送操作用于消息的同步，此时，空数组作为管道类型可以减少管道元素赋值时的开销。当然一般更倾向于用无类型的匿名结构体代替：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">c2</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;c2&#34;</span><span class="p">)</span>
    <span class="nx">c2</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span> <span class="c1">// struct{}部分是类型, {}表示对应的结构体值
</span><span class="c1"></span><span class="p">}()</span>
<span class="o">&lt;-</span><span class="nx">c2</span>
</code></pre></td></tr></table>
</div>
</div><p>注：本节参考自<a href="https://chai2010.gitbooks.io/advanced-go-programming-book/content/ch1-basic/ch1-03-array-string-and-slice.html">Go 语言高级编程 1.4</a></p>
<h2 id="二切片slice">二、切片(Slice)</h2>
<p>切片和数组非常类似，可以用下标的方式访问，也会在访问越界时发生<code>panic</code>。但它比数组更加灵活，可以自动扩容。</p>
<h3 id="1-内部实现">1. 内部实现</h3>
<p>源代码位于： /usr/local/go/src/runtime/slice.go</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">slice</span> <span class="kd">struct</span> <span class="p">{</span>
 <span class="nx">array</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>  <span class="c1">// 指向底层数组的指针
</span><span class="c1"></span>    <span class="nx">len</span>   <span class="kt">int</span>             <span class="c1">// 长度(已经存放了多少个元素)
</span><span class="c1"></span>    <span class="nx">cap</span>   <span class="kt">int</span>             <span class="c1">// 容量(底层数组的元素个数)，其中 cap&gt;=len
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><img src="https://pic.downk.cc/item/5f5f9e28160a154a67fc3734.png" alt="slice底层结构"></p>
<p>需要注意的是，底层的数组是可以被多个 slice 同时指向的，因此，对一个 slice 元素进行操作可能会影响其他指向对应数组的 slice。</p>
<p><img src="https://pic.downk.cc/item/5f5fa4a5160a154a67fdbc36.png" alt="底层的数组是可以被多个slice同时指向"></p>
<h3 id="2-slice-的创建">2. slice 的创建</h3>
<table>
<thead>
<tr>
<th style="text-align:center">方式</th>
<th style="text-align:left">代码示例</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">直接声明</td>
<td style="text-align:left">var arr1 []int</td>
<td style="text-align:left">其实是一个<code>nil slice</code>，<code>array=nil,len=0,cap=0</code>。此时没有开辟内存作为底层数组。</td>
</tr>
<tr>
<td style="text-align:center">new</td>
<td style="text-align:left">arr2 := *new([]int)</td>
<td style="text-align:left">也是一个<code>nil slice</code>，没有开辟内存作为底层数组。也没有设置元素容量的地方，此时只能通过<code>append</code>来添加元素，不能使用下标。</td>
</tr>
<tr>
<td style="text-align:center">字面量</td>
<td style="text-align:left">arr3 := []int{1,2,3}</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">make</td>
<td style="text-align:left">arr4 := make([]int,2,5)</td>
<td style="text-align:left">切片类型、长度、容量，其中容量可以不传，默认等于长度。</td>
</tr>
<tr>
<td style="text-align:center">从切片或数组“截取”</td>
<td style="text-align:left">arr5 := arr4[1:2]</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h3 id="3-关于-make-创建-slice">3. 关于 make 创建 slice</h3>
<p>Go 编译器会在编译期，根据以下两个条件来判断在哪个位置创建 slice：</p>
<ol>
<li>切片的大小和容量是否足够小</li>
<li>切片是否发生了逃逸</li>
</ol>
<p>当<strong>要创建的切片非常小并且不会发生逃逸</strong>时，这部分操作会在编译期完成，并且创建在栈上或者静态存储区。如 <code>n := make([]int,3,4)</code> 会被直接转化成如下所示的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">arr</span> <span class="p">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">int</span>
<span class="nx">n</span> <span class="o">:=</span> <span class="nx">arr</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>当发生逃逸或者比较大时，会在运行时调用 <code>runtime.makeslice</code> 函数在堆上初始化。而<code>runtime.makeslice</code>函数非常简单：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// et是元素类型
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">makeslice</span><span class="p">(</span><span class="nx">et</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
 <span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">cap</span><span class="p">))</span>
    <span class="c1">// 判断len cap参数是否合法
</span><span class="c1"></span> <span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">mem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span> <span class="o">||</span> <span class="nx">len</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">len</span> <span class="p">&gt;</span> <span class="nx">cap</span> <span class="p">{</span>
  <span class="c1">// NOTE: Produce a &#39;len out of range&#39; error instead of a
</span><span class="c1"></span>  <span class="c1">// &#39;cap out of range&#39; error when someone does make([]T, bignumber).
</span><span class="c1"></span>  <span class="c1">// &#39;cap out of range&#39; is true too, but since the cap is only being
</span><span class="c1"></span>  <span class="c1">// supplied implicitly, saying len is clearer.
</span><span class="c1"></span>  <span class="c1">// See golang.org/issue/4085.
</span><span class="c1"></span>  <span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">et</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">len</span><span class="p">))</span>
  <span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">mem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span> <span class="o">||</span> <span class="nx">len</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
   <span class="nf">panicmakeslicelen</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="nf">panicmakeslicecap</span><span class="p">()</span>
 <span class="p">}</span>
 <span class="c1">// 在堆上申请一片连续的内存
</span><span class="c1"></span> <span class="k">return</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">mem</span><span class="p">,</span> <span class="nx">et</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个函数的主要作用就是 计算当前切片所占用的内存空间并在堆上申请一段连续的内存，所需的内存空间采用以下的方式计算：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">内存空间</span> <span class="o">=</span> 元素类型大小 * 切片容量cap
</code></pre></td></tr></table>
</div>
</div><p>而元素类型的大小参照如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">大小</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">bool, int8, uint8</td>
<td style="text-align:center">1 bit</td>
</tr>
<tr>
<td style="text-align:center">int16, uint16</td>
<td style="text-align:center">2 bit</td>
</tr>
<tr>
<td style="text-align:center">int32, uint32, float32</td>
<td style="text-align:center">4 bit</td>
</tr>
<tr>
<td style="text-align:center">int, int64, uint64, float64, pointer</td>
<td style="text-align:center">8 bit (1 个字节)</td>
</tr>
<tr>
<td style="text-align:center">string</td>
<td style="text-align:center">16 bit (2 个字节)</td>
</tr>
<tr>
<td style="text-align:center">长度为 n 的 array</td>
<td style="text-align:center">n * (对应的 type 的长度)</td>
</tr>
</tbody>
</table>
<blockquote>
<p>TIPS：1 字节(Byte） = 8 位(bit)</p>
</blockquote>
<p><code>mallocgc</code> 是专门用于内存申请的函数，后面会详细讲解。</p>
<h3 id="4-切片截取">4. 切片截取</h3>
<p><strong>截取</strong> 是创建切片的一种方式，可以从数组或者切片直接截取，同时需要制定截取的起始位置。</p>
<p>需要关注的是下面这种截取方式： <code>arr1 = data[low : high : max]</code>。这里的三个数字都是指原数组或切片的索引值，而非数量。</p>
<p>这里的 <strong><code>low</code>是最低索引值，是闭区间</strong>，也就是说第一个元素是位于<code>data</code>位于<code>low</code>索引处的元素；<code>high</code>是开区间，表示最后一个元素只能索引到 <code>high - 1</code>处；<code>max</code>也是开区间，表示容量为 <code>max - 1</code>。其中：<code>len = high - low</code>，<code>cap = max - low</code>，<code>max &gt;= high &gt;= low</code>。用下面的图来帮助说明：</p>
<p><img src="https://pic.downk.cc/item/5f60362b160a154a67184b54.png" alt="切片截取"></p>
<p>基于已有的数组或者切片创建新的切片，新 slice 和老 slice 会公用底层的数组，新老 slice 对底层数组的更改都会影响彼此。需要注意的是，如果某一方执行了<code>append</code>操作引起了 <strong>扩容</strong> ，移动到了新位置，两者就不会影响了。<strong>所以关键问题在于二者是否会共用底层数组</strong>。</p>
<p>我们通过一个例子来说明，该例子来自于<a href="https://github.com/qyuhen/book/blob/master/Go%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E5%9B%9B%E7%89%88.pdf">雨痕 Go 学习笔记 P43</a>，做了一些改造：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">slice</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>
    <span class="nx">s1</span> <span class="o">:=</span> <span class="nx">slice</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
    <span class="nx">s2</span> <span class="o">:=</span> <span class="nx">s1</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">6</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span>

    <span class="nx">s2</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s2</span><span class="p">,</span> <span class="mi">55</span><span class="p">)</span>
    <span class="nx">s2</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s2</span><span class="p">,</span> <span class="mi">77</span><span class="p">)</span>

    <span class="nx">s1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="mi">66</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s1</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s2</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 输出
</span><span class="c1"></span><span class="p">[</span><span class="mi">7</span> <span class="mi">6</span> <span class="mi">66</span><span class="p">]</span>
<span class="p">[</span><span class="mi">5</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">100</span> <span class="mi">200</span><span class="p">]</span>
<span class="p">[</span><span class="mi">9</span> <span class="mi">8</span> <span class="mi">7</span> <span class="mi">6</span> <span class="mi">66</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">100</span> <span class="mi">0</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>让我们一步步来分析：</p>
<p>首先，创建 <code>slice</code>、<code>s1</code> 和 <code>s2</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">slice</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>
<span class="nx">s1</span> <span class="o">:=</span> <span class="nx">slice</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>  <span class="c1">// len为3，cap默认到底层数组的结尾
</span><span class="c1"></span><span class="nx">s2</span> <span class="o">:=</span> <span class="nx">s1</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">6</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span>   <span class="c1">// len为4，cap为5
</span><span class="c1"></span>
<span class="c1">// 以上三个底层数组相同
</span></code></pre></td></tr></table>
</div>
</div><p><img src="https://pic.downk.cc/item/5f604d8b160a154a671d9c16.png" alt="初始化slice、s1和s2"></p>
<p>之后，向 <code>s2</code> 尾部追加一个元素：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">s2</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s2</span><span class="p">,</span> <span class="mi">55</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p><code>s2</code>的容量刚好还剩一个，直接追加，不会扩容。因为这三者此时还都共用同一个底层数组，所以这一改动，<code>slice</code>和<code>s1</code>都会受到影响：</p>
<p><img src="https://pic.downk.cc/item/5f604f7f160a154a671e0121.png" alt="向s2第一次追加一个元素"></p>
<p>再次向 <code>s2</code> 追加一个元素：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">s2</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s2</span><span class="p">,</span> <span class="mi">77</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>此时，<code>s2</code> 的容量不够用，需要扩容。简单来说，扩容是新申请一块更大(具体多大，后面会说到，假设为原来的 2 倍)的内存块，将原来的数据 copy 过去，<code>s2</code> 的<code>array</code>指针指向新申请的那块内存。再次 <code>append</code> 之后：</p>
<p><img src="https://pic.downk.cc/item/5f6050d1160a154a671e412b.png" alt="s2再次append后扩容"></p>
<p>最后，修改 <code>s1</code> 索引为 2 处的元素：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">s1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="mi">66</span>
</code></pre></td></tr></table>
</div>
</div><p>此时 <code>s2</code> 已经使用了新开辟的内存空间，不再指向<code>slice</code>和<code>s1</code>指向的那个数组，因此 <code>s2</code> 不会受影响：</p>
<p><img src="https://pic.downk.cc/item/5f605211160a154a671e80b5.png" alt="修改s1"></p>
<p>后面打印 <code>s1</code> 的时候，只会打印出 <code>s1</code> 长度以内的元素。所以，只会打印出 3 个元素，虽然它的底层数组不止 3 个元素。</p>
<h3 id="5-append-扩容规则">5. append 扩容规则</h3>
<p>之前说过，扩容是新申请一块更大的内存块，将原来的数据 copy 过去，原来切片的<code>array</code>指针指向新申请的那块内存。这里我们探讨这个“更大”到底是多大：</p>
<p><strong>第一步，预估扩容后的容量 newCap：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">data</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span>
<span class="nx">data</span> <span class="p">=</span> <span class="nf">appand</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>扩容前的容量 <code>oldCap = 2</code>，新增 3 个元素，理论上应该扩容到 <code>cap=5</code>，之后会进行预估，求得 <code>newCap</code> 规则如下：</p>
<ul>
<li>
<p>如果 $oldCap * 2 &lt; cap$，那么 <code>newCap = cap</code>；</p>
</li>
<li>
<p>否则</p>
<ul>
<li>如果 <code>扩容前元素个数oldLen &lt; 1024​</code> ，那么直接翻倍，即 <code>newCap = oldCap * 2</code>；</li>
<li>否则(即 <code>扩容前元素个数oldLen &gt;= 1024</code> )，就先扩容 四分之一，也就是 <strong>1.25 倍</strong>，即 <code>newCap = oldCap * 1.25</code>。</li>
</ul>
</li>
</ul>
<p>即：<img src="https://pic.downk.cc/item/5f605756160a154a671fb153.jpg" alt="预估规则"></p>
<p>这段规则的源码位于 <code>/usr/local/go/src/runtime/slice.go</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">growslice</span><span class="p">(</span><span class="nx">et</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">old</span> <span class="nx">slice</span><span class="p">,</span> <span class="nx">cap</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">slice</span> <span class="p">{</span>
 <span class="o">...</span>
    <span class="nx">newcap</span> <span class="o">:=</span> <span class="nx">old</span><span class="p">.</span><span class="nx">cap</span>
 <span class="nx">doublecap</span> <span class="o">:=</span> <span class="nx">newcap</span> <span class="o">+</span> <span class="nx">newcap</span>
 <span class="k">if</span> <span class="nx">cap</span> <span class="p">&gt;</span> <span class="nx">doublecap</span> <span class="p">{</span>
  <span class="nx">newcap</span> <span class="p">=</span> <span class="nx">cap</span>
 <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">old</span><span class="p">.</span><span class="nx">len</span> <span class="p">&lt;</span> <span class="mi">1024</span> <span class="p">{</span>
   <span class="nx">newcap</span> <span class="p">=</span> <span class="nx">doublecap</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
   <span class="c1">// Check 0 &lt; newcap to detect overflow
</span><span class="c1"></span>   <span class="c1">// and prevent an infinite loop.
</span><span class="c1"></span>   <span class="k">for</span> <span class="mi">0</span> <span class="p">&lt;</span> <span class="nx">newcap</span> <span class="o">&amp;&amp;</span> <span class="nx">newcap</span> <span class="p">&lt;</span> <span class="nx">cap</span> <span class="p">{</span>
    <span class="nx">newcap</span> <span class="o">+=</span> <span class="nx">newcap</span> <span class="o">/</span> <span class="mi">4</span>
   <span class="p">}</span>
   <span class="c1">// Set newcap to the requested cap when
</span><span class="c1"></span>   <span class="c1">// the newcap calculation overflowed.
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">newcap</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nx">newcap</span> <span class="p">=</span> <span class="nx">cap</span>
   <span class="p">}</span>
  <span class="p">}</span>
 <span class="p">}</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述例子中，<code>oldCap=2</code>，至少需要扩容到<code>cap=5</code>，根据预估规则，因为 <code>oldCap*2=4 &lt; 5</code>，因此 <code>newCap=cap=5</code>，即预估结果为<code>newCap=5</code>。</p>
<p><strong>第二步，确定实际分配的内存，匹配到合适的内存规格</strong></p>
<p><strong><code>理论上所需要内存 = 预估容量 * 元素类型大小</code></strong>，难道直接就会分配这么多的内存吗？并不是。</p>
<p>首先元素类型大小已在 “一.3”中说明过，此处 int 类型的大小是 8bit(1 个字节)。接着看<code>growslice</code>函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">growslice</span><span class="p">(</span><span class="nx">et</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">old</span> <span class="nx">slice</span><span class="p">,</span> <span class="nx">cap</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">slice</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="kd">var</span> <span class="nx">overflow</span> <span class="kt">bool</span>
 <span class="kd">var</span> <span class="nx">lenmem</span><span class="p">,</span> <span class="nx">newlenmem</span><span class="p">,</span> <span class="nx">capmem</span> <span class="kt">uintptr</span>
 <span class="c1">// Specialize for common values of et.size.
</span><span class="c1"></span> <span class="c1">// For 1 we don&#39;t need any division/multiplication.
</span><span class="c1"></span> <span class="c1">// For sys.PtrSize, compiler will optimize division/multiplication into a shift by a constant.
</span><span class="c1"></span> <span class="c1">// For powers of 2, use a variable shift.
</span><span class="c1"></span> <span class="k">switch</span> <span class="p">{</span>
 <span class="k">case</span> <span class="nx">et</span><span class="p">.</span><span class="nx">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
  <span class="nx">lenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="p">)</span>
  <span class="nx">newlenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">cap</span><span class="p">)</span>
  <span class="nx">capmem</span> <span class="p">=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">))</span>
  <span class="nx">overflow</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span>
  <span class="nx">newcap</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">capmem</span><span class="p">)</span>
    <span class="k">case</span> <span class="nx">et</span><span class="p">.</span><span class="nx">size</span> <span class="o">==</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">:</span>
  <span class="nx">lenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">old</span><span class="p">.</span><span class="nx">len</span><span class="p">)</span> <span class="o">*</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span>
  <span class="nx">newlenmem</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">cap</span><span class="p">)</span> <span class="o">*</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span>
  <span class="nx">capmem</span> <span class="p">=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">)</span> <span class="o">*</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span>
  <span class="nx">overflow</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">newcap</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span><span class="o">/</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span>
  <span class="nx">newcap</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">capmem</span> <span class="o">/</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span>
    <span class="o">...</span><span class="p">.</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在这里，<code>sys.PtrSize = 8</code>，<code>et</code>类型是 <code>int</code>，所以 <code>et.size == sys.PtrSize</code>为 <code>true</code>，则 <code>newcap * sys.PtrSize = 5 * 8 = 40</code>。我们看看 <code>roundupsize</code>这个函数，位于 <code>/usr/local/go/src/runtime/msize.go</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Returns size of the memory block that mallocgc will allocate if you ask for the size.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nx">size</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">uintptr</span> <span class="p">{</span>
 <span class="k">if</span> <span class="nx">size</span> <span class="p">&lt;</span> <span class="nx">_MaxSmallSize</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">size</span> <span class="o">&lt;=</span> <span class="nx">smallSizeMax</span><span class="o">-</span><span class="mi">8</span> <span class="p">{</span>
   <span class="k">return</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">class_to_size</span><span class="p">[</span><span class="nx">size_to_class8</span><span class="p">[(</span><span class="nx">size</span><span class="o">+</span><span class="nx">smallSizeDiv</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="nx">smallSizeDiv</span><span class="p">]])</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
   <span class="c1">// ...
</span><span class="c1"></span>  <span class="p">}</span>
 <span class="p">}</span>
 <span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中，<code>_MaxSmallSize = 32768</code>，<code>smallSizeMax = 1024</code>，<code>smallSizeDiv = 8</code>，而传进来的 <code>size = 40</code>。而：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">class_to_size</span> <span class="p">=</span> <span class="p">[</span><span class="nx">_NumSizeClasses</span><span class="p">]</span><span class="kt">uint16</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">48</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">96</span><span class="p">,</span> <span class="mi">112</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">144</span><span class="p">,</span> <span class="mi">160</span><span class="p">,</span> <span class="mi">176</span><span class="p">,</span> <span class="mi">192</span><span class="p">,</span> <span class="mi">208</span><span class="p">,</span> <span class="mi">224</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">288</span><span class="p">,</span> <span class="mi">320</span><span class="p">,</span> <span class="mi">352</span><span class="p">,</span> <span class="mi">384</span><span class="p">,</span> <span class="mi">416</span><span class="p">,</span> <span class="mi">448</span><span class="p">,</span> <span class="mi">480</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">576</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">704</span><span class="p">,</span> <span class="mi">768</span><span class="p">,</span> <span class="mi">896</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="mi">1152</span><span class="p">,</span> <span class="mi">1280</span><span class="p">,</span> <span class="mi">1408</span><span class="p">,</span> <span class="mi">1536</span><span class="p">,</span> <span class="mi">1792</span><span class="p">,</span> <span class="mi">2048</span><span class="p">,</span> <span class="mi">2304</span><span class="p">,</span> <span class="mi">2688</span><span class="p">,</span> <span class="mi">3072</span><span class="p">,</span> <span class="mi">3200</span><span class="p">,</span> <span class="mi">3456</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="mi">4864</span><span class="p">,</span> <span class="mi">5376</span><span class="p">,</span> <span class="mi">6144</span><span class="p">,</span> <span class="mi">6528</span><span class="p">,</span> <span class="mi">6784</span><span class="p">,</span> <span class="mi">6912</span><span class="p">,</span> <span class="mi">8192</span><span class="p">,</span> <span class="mi">9472</span><span class="p">,</span> <span class="mi">9728</span><span class="p">,</span> <span class="mi">10240</span><span class="p">,</span> <span class="mi">10880</span><span class="p">,</span> <span class="mi">12288</span><span class="p">,</span> <span class="mi">13568</span><span class="p">,</span> <span class="mi">14336</span><span class="p">,</span> <span class="mi">16384</span><span class="p">,</span> <span class="mi">18432</span><span class="p">,</span> <span class="mi">19072</span><span class="p">,</span> <span class="mi">20480</span><span class="p">,</span> <span class="mi">21760</span><span class="p">,</span> <span class="mi">24576</span><span class="p">,</span> <span class="mi">27264</span><span class="p">,</span> <span class="mi">28672</span><span class="p">,</span> <span class="mi">32768</span><span class="p">}</span>
<span class="kd">var</span> <span class="nx">size_to_class8</span> <span class="p">=</span> <span class="p">[</span><span class="nx">smallSizeMax</span><span class="o">/</span><span class="nx">smallSizeDiv</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="kt">uint8</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>所以上面<code>roundupsize</code>会返回：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">class_to_size</span><span class="p">[</span><span class="nx">size_to_class8</span><span class="p">[(</span><span class="nx">size</span><span class="o">+</span><span class="nx">smallSizeDiv</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="nx">smallSizeDiv</span><span class="p">]]</span> <span class="p">=</span> <span class="mi">48</span>
</code></pre></td></tr></table>
</div>
</div><p>在<code>growslice</code>中，<code>capmem = 48</code>，则最后计算得到的 <code>newcap = int(capmem / sys.PtrSize) = int(48 / 8) = 6</code>，即最终扩容后的容量为 <code>6</code>。而不是之前预估的 <code>5</code>。</p>
<p>总结一下，首先使用预估规则预估一下需要的容量(本例中为 5)，然后用这个容量乘以 slice 元素的大小(单位是 bit，本例中 int 为 8)，之后根据在 <code>class_to_size</code> 中选择合适大小的值，比如 40，那应该选择比 40 大的更小的那个 48，这就是申请到的真正的容量内存，最后用真正的容量大小除以元素大小，即可得到真正的扩容后的 slice 的<code>cap</code>。</p>
<h3 id="6-slice-作为函数参数">6. slice 作为函数参数</h3>
<p>函数调用处的参数称为 <strong>实参</strong>，函数定义处的参数称为 <strong>形参</strong>。形参是实参的拷贝，会生成一个新的切片，但二者指向底层数组的指针相同。</p>
<p><strong>当函数中没有出现扩容时：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">a</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>  <span class="c1">// 输出 [1,2,3,4,5,6]
</span><span class="c1"></span>    <span class="nf">t1</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>  <span class="c1">// 输出 [1,66,3,4,5,6]
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">t1</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">66</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>当函数中出现扩容时：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">a</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>  <span class="c1">// 输出 [1,2,3,4,5,6]
</span><span class="c1"></span>    <span class="nf">t1</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>  <span class="c1">// 输出 [1,2,3,4,5,6]
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">t2</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">s</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">66</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>扩容后，指向的底层数组不同，互不影响。</p>
<h2 id="三字符串string">三、字符串(String)</h2>
<p>字符串是 Go 语言中最常用的基础数据类型之一，虽然字符串往往被看做一个整体，但是实际上字符串是一片连续的内存空间，我们也可以将它理解成一个由字符组成的数组。</p>
<p>在设计上，Go 语言中的<code>string</code>是一个只读的字节数组。当然，只读只意味着字符串会分配到只读的内存空间并且这块内存不会被修改，在运行时我们其实还是可以将这段内存拷贝到堆或者栈上，将变量的类型转换成 <code>[]byte</code> 之后就可以进行，修改后通过类型转换就可以变回 <code>string</code>，Go 语言只是不支持直接修改 <code>string</code> 类型变量的内存空间。</p>
<p><code>string</code>的底层结构如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// /usr/local/go/src/runtime/string.go
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">stringStruct</span> <span class="kd">struct</span> <span class="p">{</span>
 <span class="nx">str</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
 <span class="nx">len</span> <span class="kt">int</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到和上面的切片结构非常相似，只是少了表示容量的<code>cap</code>。这是因为，字符串作为只读类型，我们并不会对齐进行扩容操作进而改变其自身的内存空间，<strong>所有在字符串上执行的写入操作都是通过拷贝实现的</strong>。</p>
<p>关于字符串，讨论最多的是 <code>string</code>和<code>[]byte</code>互相转换的性能问题，在底层是通过 <code>stringtoslicebyte</code> 和 <code>slicebytetostring</code>两个函数实现的，其中出现了内存分配的情况，这里不做细究。</p>
<p>在说<code>unsafe</code> 那篇文章里，提到了 <strong>实现<code>string</code>和<code>[]byte</code> 的零拷贝转换</strong>：这里再复习一下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">stringToBytes</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)[]</span><span class="kt">byte</span><span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">[]</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">s</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">bytesToString</span><span class="p">(</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span><span class="kt">string</span><span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">string</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">JemmyHu(hujm20151021@gmail.com)</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-09-16 02:15
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/golang/">Golang</a>
          <a href="/tags/%E6%95%B0%E7%BB%84/">数组</a>
          <a href="/tags/%E5%88%87%E7%89%87/">切片</a>
          <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/">字符串</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/golang-unsafe%E5%8C%85%E8%AF%A6%E8%A7%A3/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Golang-unsafe包详解</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/golang-%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/">
            <span class="next-text nav-default">Golang-关于函数调用</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  
  <div id="vcomments"></div>
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <script type="text/javascript">
    new Valine({
        el: '#vcomments' ,
        appId: 'LjkR3NaCog7bTVOnJNMmJjcM-gzGzoHsz',
        appKey: 'UQMdKbH71EeHJppAbtDwb5Rg',
        notify:  true ,
        verify:  false ,
        avatar:'monsterid',
        placeholder: '欢迎留言~',
        visitor:  false 
    });
  </script>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:hujm20151021@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/JemmyH" class="iconfont icon-github" title="github"></a>
  <a href="http://localhost:1313/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2020<span class="heart"><i class="iconfont icon-heart"></i></span><span>Jemmy</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script><script></script><script src="https://cdn.jsdelivr.net/npm/raphael@2.2.7/raphael.min.js" integrity="sha256-67By+NpOtm9ka1R6xpUefeGOY8kWWHHRAKlvaTJ7ONI=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/flowchart.js@1.8.0/release/flowchart.min.js" integrity="sha256-zNGWjubXoY6rb5MnmpBNefO0RgoVYfle9p0tvOQM+6k=" crossorigin="anonymous"></script><script></script><script src="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.js" integrity="sha256-4O4pS1SH31ZqrSO2A/2QJTVjTPqVe+jnYgOWUVr7EEc=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/snapsvg@0.5.1/dist/snap.svg-min.js" integrity="sha256-oI+elz+sIm+jpn8F/qEspKoKveTc5uKeFHNNVexe6d8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/underscore@1.8.3/underscore-min.js" integrity="sha256-obZACiHd7gkOk9iIL/pimWMTJ4W/pBsKu+oZnSeBIek=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/gh/bramp/js-sequence-diagrams@2.0.1/dist/sequence-diagram-min.js" integrity="sha384-8748Vn52gHJYJI0XEuPB2QlPVNUkJlJn9tHqKec6J3q2r9l8fvRxrgn/E5ZHV0sP" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/bramp/js-sequence-diagrams@2.0.1/dist/sequence-diagram-min.css" integrity="sha384-6QbLKJMz5dS3adWSeINZe74uSydBGFbnzaAYmp+tKyq60S7H2p6V7g1TysM5lAaF" crossorigin="anonymous">



<script type="text/javascript" src="/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
